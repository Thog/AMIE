{
  "instructions": {
    "base": {
      "ADC": {
        "authored": "Add with Carry adds two register values and the Carry flag value, and writes the\nresult to the destination register.",
        "heading": "ADC",
        "templates": {
          "NO_S": [
            "ADC  <Wd>, <Wn>, <Wm>",
            "ADC  <Xd>, <Xn>, <Xm>"
          ]
        }
      },
      "ADCS": {
        "authored": "Add with Carry, setting flags, adds two register values and the Carry flag\nvalue, and writes the result to the destination register. It updates the\ncondition flags based on the result.",
        "heading": "ADCS",
        "templates": {
          "S": [
            "ADCS  <Wd>, <Wn>, <Wm>",
            "ADCS  <Xd>, <Xn>, <Xm>"
          ]
        }
      },
      "ADDG": {
        "authored": "Add with Tag adds an immediate value scaled by the Tag granule to the address in\nthe source register, modifies the Logical Address Tag of the address using an\nimmediate value, and writes the result to the destination register. Tags\nspecified in GCR_EL1.Exclude are excluded from the possible outputs when\nmodifying the Logical Address Tag.",
        "heading": "ADDG",
        "templates": {
          "GENERAL": [
            "ADDG  <Xd|SP>, <Xn|SP>, #<uimm6>, #<uimm4>"
          ]
        }
      },
      "ADDS_addsub_ext": {
        "authored": "Add (extended register), setting flags, adds a register value and a sign or\nzero-extended register value, followed by an optional left shift amount, and\nwrites the result to the destination register. The argument that is extended\nfrom the <Rm> register can be a byte, halfword, word, or doubleword. It updates\nthe condition flags based on the result.",
        "heading": "ADDS (extended register)",
        "templates": {
          "S": [
            "ADDS  <Wd>, <Wn|WSP>, <Wm>{, <extend> {#<amount>}}",
            "ADDS  <Xd>, <Xn|SP>, <R><m>{, <extend> {#<amount>}}"
          ]
        }
      },
      "ADDS_addsub_imm": {
        "authored": "Add (immediate), setting flags, adds a register value and an optionally-shifted\nimmediate value, and writes the result to the destination register. It updates\nthe condition flags based on the result.",
        "heading": "ADDS (immediate)",
        "templates": {
          "S": [
            "ADDS  <Wd>, <Wn|WSP>, #<imm>{, <shift>}",
            "ADDS  <Xd>, <Xn|SP>, #<imm>{, <shift>}"
          ]
        }
      },
      "ADDS_addsub_shift": {
        "authored": "Add (shifted register), setting flags, adds a register value and an optionally-\nshifted register value, and writes the result to the destination register. It\nupdates the condition flags based on the result.",
        "heading": "ADDS (shifted register)",
        "templates": {
          "S": [
            "ADDS  <Wd>, <Wn>, <Wm>{, <shift> #<amount>}",
            "ADDS  <Xd>, <Xn>, <Xm>{, <shift> #<amount>}"
          ]
        }
      },
      "ADD_addsub_ext": {
        "authored": "Add (extended register) adds a register value and a sign or zero-extended\nregister value, followed by an optional left shift amount, and writes the result\nto the destination register. The argument that is extended from the <Rm>\nregister can be a byte, halfword, word, or doubleword.",
        "heading": "ADD (extended register)",
        "templates": {
          "NO_S": [
            "ADD  <Wd|WSP>, <Wn|WSP>, <Wm>{, <extend> {#<amount>}}",
            "ADD  <Xd|SP>, <Xn|SP>, <R><m>{, <extend> {#<amount>}}"
          ]
        }
      },
      "ADD_addsub_imm": {
        "authored": "Add (immediate) adds a register value and an optionally-shifted immediate value,\nand writes the result to the destination register.",
        "heading": "ADD (immediate)",
        "templates": {
          "NO_S": [
            "ADD  <Wd|WSP>, <Wn|WSP>, #<imm>{, <shift>}",
            "ADD  <Xd|SP>, <Xn|SP>, #<imm>{, <shift>}"
          ]
        }
      },
      "ADD_addsub_shift": {
        "authored": "Add (shifted register) adds a register value and an optionally-shifted register\nvalue, and writes the result to the destination register.",
        "heading": "ADD (shifted register)",
        "templates": {
          "NO_S": [
            "ADD  <Wd>, <Wn>, <Wm>{, <shift> #<amount>}",
            "ADD  <Xd>, <Xn>, <Xm>{, <shift> #<amount>}"
          ]
        }
      },
      "ADR": {
        "authored": "Form PC-relative address adds an immediate value to the PC value to form a PC-\nrelative address, and writes the result to the destination register.",
        "heading": "ADR",
        "templates": {
          "LITERAL": [
            "ADR  <Xd>, <label>"
          ]
        }
      },
      "ADRP": {
        "authored": "Form PC-relative address to 4KB page adds an immediate value that is shifted\nleft by 12 bits, to the PC value to form a PC-relative address, with the bottom\n12 bits masked out, and writes the result to the destination register.",
        "heading": "ADRP",
        "templates": {
          "LITERAL": [
            "ADRP  <Xd>, <label>"
          ]
        }
      },
      "ANDS_log_imm": {
        "authored": "Bitwise AND (immediate), setting flags, performs a bitwise AND of a register\nvalue and an immediate value, and writes the result to the destination register.\nIt updates the condition flags based on the result.",
        "heading": "ANDS (immediate)",
        "templates": {
          "S": [
            "ANDS  <Wd>, <Wn>, #<imm>",
            "ANDS  <Xd>, <Xn>, #<imm>"
          ]
        }
      },
      "ANDS_log_shift": {
        "authored": "Bitwise AND (shifted register), setting flags, performs a bitwise AND of a\nregister value and an optionally-shifted register value, and writes the result\nto the destination register. It updates the condition flags based on the result.",
        "heading": "ANDS (shifted register)",
        "templates": {
          "S": [
            "ANDS  <Wd>, <Wn>, <Wm>{, <shift> #<amount>}",
            "ANDS  <Xd>, <Xn>, <Xm>{, <shift> #<amount>}"
          ]
        }
      },
      "AND_log_imm": {
        "authored": "Bitwise AND (immediate) performs a bitwise AND of a register value and an\nimmediate value, and writes the result to the destination register.",
        "heading": "AND (immediate)",
        "templates": {
          "NO_S": [
            "AND  <Wd|WSP>, <Wn>, #<imm>",
            "AND  <Xd|SP>, <Xn>, #<imm>"
          ]
        }
      },
      "AND_log_shift": {
        "authored": "Bitwise AND (shifted register) performs a bitwise AND of a register value and an\noptionally-shifted register value, and writes the result to the destination\nregister.",
        "heading": "AND (shifted register)",
        "templates": {
          "NO_S": [
            "AND  <Wd>, <Wn>, <Wm>{, <shift> #<amount>}",
            "AND  <Xd>, <Xn>, <Xm>{, <shift> #<amount>}"
          ]
        }
      },
      "ASRV": {
        "authored": "Arithmetic Shift Right Variable shifts a register value right by a variable\nnumber of bits, shifting in copies of its sign bit, and writes the result to the\ndestination register. The remainder obtained by dividing the second source\nregister by the data size defines the number of bits by which the first source\nregister is right-shifted.",
        "heading": "ASRV",
        "templates": {
          "GENERAL": [
            "ASRV  <Wd>, <Wn>, <Wm>",
            "ASRV  <Xd>, <Xn>, <Xm>"
          ]
        }
      },
      "ASR_ASRV": {
        "authored": "Arithmetic Shift Right (register) shifts a register value right by a variable\nnumber of bits, shifting in copies of its sign bit, and writes the result to the\ndestination register. The remainder obtained by dividing the second source\nregister by the data size defines the number of bits by which the first source\nregister is right-shifted.",
        "heading": "ASR (register)",
        "templates": {
          "GENERAL": [
            "ASR  <Wd>, <Wn>, <Wm>",
            "ASR  <Xd>, <Xn>, <Xm>"
          ]
        }
      },
      "ASR_SBFM": {
        "authored": "Arithmetic Shift Right (immediate) shifts a register value right by an immediate\nnumber of bits, shifting in copies of the sign bit in the upper bits and zeros\nin the lower bits, and writes the result to the destination register.",
        "heading": "ASR (immediate)",
        "templates": {
          "SIGNED_FILL": [
            "ASR  <Wd>, <Wn>, #<shift>",
            "ASR  <Xd>, <Xn>, #<shift>"
          ]
        }
      },
      "AT_SYS": {
        "authored": "Address Translate. For more information, see op0==0b01, cache maintenance, TLB\nmaintenance, and address translation instructions.",
        "heading": "AT",
        "templates": {
          "SYSTEM": [
            "AT  <at_op>, <Xt>"
          ]
        }
      },
      "AUTDA": {
        "authored": "Authenticate Data address, using key A. This instruction authenticates a data\naddress, using a modifier and key A.\n\nThe address is in the general-purpose register that is specified by <Xd>.\n\nThe modifier is:\n  - In the general-purpose register or stack pointer that is specified by\n<Xn|SP> for AUTDA.\n  - The value zero, for AUTDZA.\n\nIf the authentication passes, the upper bits of the address are restored to\nenable subsequent use of the address. If the authentication fails, the upper\nbits are corrupted and any subsequent use of the address results in a\nTranslation fault.",
        "heading": "AUTDA, AUTDZA",
        "templates": {
          "GENERAL": [
            "AUTDA  <Xd>, <Xn|SP>",
            "AUTDZA  <Xd>"
          ]
        }
      },
      "AUTDB": {
        "authored": "Authenticate Data address, using key B. This instruction authenticates a data\naddress, using a modifier and key B.\n\nThe address is in the general-purpose register that is specified by <Xd>.\n\nThe modifier is:\n  - In the general-purpose register or stack pointer that is specified by\n<Xn|SP> for AUTDB.\n  - The value zero, for AUTDZB.\n\nIf the authentication passes, the upper bits of the address are restored to\nenable subsequent use of the address. If the authentication fails, the upper\nbits are corrupted and any subsequent use of the address results in a\nTranslation fault.",
        "heading": "AUTDB, AUTDZB",
        "templates": {
          "GENERAL": [
            "AUTDB  <Xd>, <Xn|SP>",
            "AUTDZB  <Xd>"
          ]
        }
      },
      "AUTIA": {
        "authored": "Authenticate Instruction address, using key A. This instruction authenticates an\ninstruction address, using a modifier and key A.\n\nThe address is:\n  - In the general-purpose register that is specified by <Xd> for AUTIA and\nAUTIZA.\n  - In X17, for AUTIA1716.\n  - In X30, for AUTIASP and AUTIAZ.\n\nThe modifier is:\n  - In the general-purpose register or stack pointer that is specified by\n<Xn|SP> for AUTIA.\n  - The value zero, for AUTIZA and AUTIAZ.\n  - In X16, for AUTIA1716.\n  - In SP, for AUTIASP.\n\nIf the authentication passes, the upper bits of the address are restored to\nenable subsequent use of the address. If the authentication fails, the upper\nbits are corrupted and any subsequent use of the address results in a\nTranslation fault.",
        "heading": "AUTIA, AUTIA1716, AUTIASP, AUTIAZ, AUTIZA",
        "templates": {
          "GENERAL": [
            "AUTIA  <Xd>, <Xn|SP>",
            "AUTIZA  <Xd>"
          ],
          "SYSTEM": [
            "AUTIA1716",
            "AUTIASP",
            "AUTIAZ"
          ]
        }
      },
      "AUTIB": {
        "authored": "Authenticate Instruction address, using key B. This instruction authenticates an\ninstruction address, using a modifier and key B.\n\nThe address is:\n  - In the general-purpose register that is specified by <Xd> for AUTIB and\nAUTIZB.\n  - In X17, for AUTIB1716.\n  - In X30, for AUTIBSP and AUTIBZ.\n\nThe modifier is:\n  - In the general-purpose register or stack pointer that is specified by\n<Xn|SP> for AUTIB.\n  - The value zero, for AUTIZB and AUTIBZ.\n  - In X16, for AUTIB1716.\n  - In SP, for AUTIBSP.\n\nIf the authentication passes, the upper bits of the address are restored to\nenable subsequent use of the address. If the authentication fails, the upper\nbits are corrupted and any subsequent use of the address results in a\nTranslation fault.",
        "heading": "AUTIB, AUTIB1716, AUTIBSP, AUTIBZ, AUTIZB",
        "templates": {
          "GENERAL": [
            "AUTIB  <Xd>, <Xn|SP>",
            "AUTIZB  <Xd>"
          ],
          "SYSTEM": [
            "AUTIB1716",
            "AUTIBSP",
            "AUTIBZ"
          ]
        }
      },
      "AXFLAG": {
        "authored": "Convert floating-point condition flags from Arm to external format. This\ninstruction converts the state of the PSTATE.{N,Z,C,V} flags from a form\nrepresenting the result of an Arm floating-point scalar compare instruction to\nan alternative representation required by some software.",
        "heading": "AXFLAG",
        "templates": {
          "SYSTEM": [
            "AXFLAG"
          ]
        }
      },
      "BFC_BFM": {
        "authored": "Bitfield Clear sets a bitfield of <width> bits at bit position <lsb> of the\ndestination register to zero, leaving the other destination bits unchanged.",
        "heading": "BFC",
        "templates": {
          "NOFILL": [
            "BFC  <Wd>, #<lsb>, #<width>",
            "BFC  <Xd>, #<lsb>, #<width>"
          ]
        }
      },
      "BFI_BFM": {
        "authored": "Bitfield Insert copies a bitfield of <width> bits from the least significant\nbits of the source register to bit position <lsb> of the destination register,\nleaving the other destination bits unchanged.",
        "heading": "BFI",
        "templates": {
          "NOFILL": [
            "BFI  <Wd>, <Wn>, #<lsb>, #<width>",
            "BFI  <Xd>, <Xn>, #<lsb>, #<width>"
          ]
        }
      },
      "BFM": {
        "authored": "Bitfield Move is usually accessed via one of its aliases, which are always\npreferred for disassembly.\n\nIf <imms> is greater than or equal to <immr>, this copies a bitfield of\n(<imms>-<immr>+1) bits starting from bit position <immr> in the source register\nto the least significant bits of the destination register.\n\nIf <imms> is less than <immr>, this copies a bitfield of (<imms>+1) bits from\nthe least significant bits of the source register to bit position\n(regsize-<immr>) of the destination register, where regsize is the destination\nregister size of 32 or 64 bits.\n\nIn both cases the other bits of the destination register remain unchanged.",
        "heading": "BFM",
        "templates": {
          "NOFILL": [
            "BFM  <Wd>, <Wn>, #<immr>, #<imms>",
            "BFM  <Xd>, <Xn>, #<immr>, #<imms>"
          ]
        }
      },
      "BFXIL_BFM": {
        "authored": "Bitfield Extract and Insert Low copies a bitfield of <width> bits starting from\nbit position <lsb> in the source register to the least significant bits of the\ndestination register, leaving the other destination bits unchanged.",
        "heading": "BFXIL",
        "templates": {
          "NOFILL": [
            "BFXIL  <Wd>, <Wn>, #<lsb>, #<width>",
            "BFXIL  <Xd>, <Xn>, #<lsb>, #<width>"
          ]
        }
      },
      "BICS": {
        "authored": "Bitwise Bit Clear (shifted register), setting flags, performs a bitwise AND of a\nregister value and the complement of an optionally-shifted register value, and\nwrites the result to the destination register. It updates the condition flags\nbased on the result.",
        "heading": "BICS (shifted register)",
        "templates": {
          "S": [
            "BICS  <Wd>, <Wn>, <Wm>{, <shift> #<amount>}",
            "BICS  <Xd>, <Xn>, <Xm>{, <shift> #<amount>}"
          ]
        }
      },
      "BIC_log_shift": {
        "authored": "Bitwise Bit Clear (shifted register) performs a bitwise AND of a register value\nand the complement of an optionally-shifted register value, and writes the\nresult to the destination register.",
        "heading": "BIC (shifted register)",
        "templates": {
          "NO_S": [
            "BIC  <Wd>, <Wn>, <Wm>{, <shift> #<amount>}",
            "BIC  <Xd>, <Xn>, <Xm>{, <shift> #<amount>}"
          ]
        }
      },
      "BL": {
        "authored": "Branch with Link branches to a PC-relative offset, setting the register X30 to\nPC+4. It provides a hint that this is a subroutine call.",
        "heading": "BL",
        "templates": {
          "BR26": [
            "BL  <label>"
          ]
        }
      },
      "BLR": {
        "authored": "Branch with Link to Register calls a subroutine at an address in a register,\nsetting register X30 to PC+4.",
        "heading": "BLR",
        "templates": {
          "GENERAL": [
            "BLR  <Xn>"
          ]
        }
      },
      "BLRA": {
        "authored": "Branch with Link to Register, with pointer authentication. This instruction\nauthenticates the address in the general-purpose register that is specified by\n<Xn>, using a modifier and the specified key, and calls a subroutine at the\nauthenticated address, setting register X30 to PC+4.\n\nThe modifier is:\n  - In the general-purpose register or stack pointer that is specified by\n<Xm|SP> for BLRAA and BLRAB.\n  - The value zero, for BLRAAZ and BLRABZ.\n\nKey A is used for BLRAA and BLRAAZ, and key B is used for BLRAB and BLRABZ.\n\nIf the authentication passes, the PE continues execution at the target of the\nbranch. If the authentication fails, a Translation fault is generated.\n\nThe authenticated address is not written back to the general-purpose register.",
        "heading": "BLRAA, BLRAAZ, BLRAB, BLRABZ",
        "templates": {
          "GENERAL": [
            "BLRAAZ  <Xn>",
            "BLRAA  <Xn>, <Xm|SP>",
            "BLRABZ  <Xn>",
            "BLRAB  <Xn>, <Xm|SP>"
          ]
        }
      },
      "BR": {
        "authored": "Branch to Register branches unconditionally to an address in a register, with a\nhint that this is not a subroutine return.",
        "heading": "BR",
        "templates": {
          "GENERAL": [
            "BR  <Xn>"
          ]
        }
      },
      "BRA": {
        "authored": "Branch to Register, with pointer authentication. This instruction authenticates\nthe address in the general-purpose register that is specified by <Xn>, using a\nmodifier and the specified key, and branches to the authenticated address.\n\nThe modifier is:\n  - In the general-purpose register or stack pointer that is specified by\n<Xm|SP> for BRAA and BRAB.\n  - The value zero, for BRAAZ and BRABZ.\n\nKey A is used for BRAA and BRAAZ, and key B is used for BRAB and BRABZ.\n\nIf the authentication passes, the PE continues execution at the target of the\nbranch. If the authentication fails, a Translation fault is generated.\n\nThe authenticated address is not written back to the general-purpose register.",
        "heading": "BRAA, BRAAZ, BRAB, BRABZ",
        "templates": {
          "GENERAL": [
            "BRAAZ  <Xn>",
            "BRAA  <Xn>, <Xm|SP>",
            "BRABZ  <Xn>",
            "BRAB  <Xn>, <Xm|SP>"
          ]
        }
      },
      "BRK": {
        "authored": "Breakpoint instruction. A BRK instruction generates a Breakpoint Instruction\nexception. The PE records the exception in ESR_ELx, using the EC value 0x3c, and\ncaptures the value of the immediate argument in ESR_ELx.ISS.",
        "heading": "BRK",
        "templates": {
          "SYSTEM": [
            "BRK  #<imm>"
          ]
        }
      },
      "BTI": {
        "authored": "Branch Target Identification. A BTI instruction is used to guard against the\nexecution of instructions which are not the intended target of a branch.\n\nOutside of a guarded memory region, a BTI instruction executes as a NOP. Within\na guarded memory region while PSTATE.BTYPE != 0b00, a BTI instruction compatible\nwith the current value of PSTATE.BTYPE will not generate a Branch Target\nException and will allow execution of subsequent instructions within the memory\nregion.\n\nThe operand <targets> passed to a BTI instruction determines the values of\nPSTATE.BTYPE which the BTI instruction is compatible with.\n\nWithin a guarded memory region, while PSTATE.BTYPE\n\n!= 0b00, all instructions will generate a Branch Target\n\nException, other than BRK, BTI, HLT, PACIASP,\n\nand PACIBSP, which may not. See the individual instructions for details.",
        "heading": "BTI",
        "templates": {
          "SYSTEM": [
            "BTI  {<targets>}"
          ]
        }
      },
      "B_cond": {
        "authored": "Branch conditionally to a label at a PC-relative offset, with a hint that this\nis not a subroutine call or return.",
        "heading": "B.cond",
        "templates": {
          "BR19": [
            "B.<cond>  <label>"
          ]
        }
      },
      "B_uncond": {
        "authored": "Branch causes an unconditional branch to a label at a PC-relative offset, with a\nhint that this is not a subroutine call or return.",
        "heading": "B",
        "templates": {
          "BR26": [
            "B  <label>"
          ]
        }
      },
      "CAS": {
        "authored": "Compare and Swap word or doubleword in memory reads a 32-bit word or 64-bit\ndoubleword from memory, and compares it against the value held in a first\nregister. If the comparison is equal, the value in a second register is written\nto memory. If the write is performed, the read and write occur atomically such\nthat no other modification of the memory location can take place between the\nread and write.\n  - CASA and CASAL load from memory with acquire semantics.\n  - CASL and CASAL store to memory with release semantics.\n  - CAS has neither acquire nor release semantics.\n\nFor more information about memory ordering semantics see Load-Acquire, Store-\nRelease.\n\nFor information about memory accesses see Load/Store addressing modes.\n\nThe architecture permits that the data read clears any exclusive monitors\nassociated with that location, even if the compare subsequently fails.\n\nIf the instruction generates a synchronous Data Abort, the register which is\ncompared and loaded, that is <Ws>, or <Xs>, is restored to the value held in the\nregister before the instruction was executed.",
        "heading": "CAS, CASA, CASAL, CASL",
        "templates": {
          "BASE_REGISTER": [
            "CAS  <Ws>, <Wt>, [<Xn|SP>{,#0}]",
            "CASA  <Ws>, <Wt>, [<Xn|SP>{,#0}]",
            "CASAL  <Ws>, <Wt>, [<Xn|SP>{,#0}]",
            "CASL  <Ws>, <Wt>, [<Xn|SP>{,#0}]",
            "CAS  <Xs>, <Xt>, [<Xn|SP>{,#0}]",
            "CASA  <Xs>, <Xt>, [<Xn|SP>{,#0}]",
            "CASAL  <Xs>, <Xt>, [<Xn|SP>{,#0}]",
            "CASL  <Xs>, <Xt>, [<Xn|SP>{,#0}]"
          ]
        }
      },
      "CASB": {
        "authored": "Compare and Swap byte in memory reads an 8-bit byte from memory, and compares it\nagainst the value held in a first register. If the comparison is equal, the\nvalue in a second register is written to memory. If the write is performed, the\nread and write occur atomically such that no other modification of the memory\nlocation can take place between the read and write.\n  - CASAB and CASALB load from memory with acquire semantics.\n  - CASLB and CASALB store to memory with release semantics.\n  - CASB has neither acquire nor release semantics.\n\nFor more information about memory ordering semantics see Load-Acquire, Store-\nRelease.\n\nFor information about memory accesses see Load/Store addressing modes.\n\nThe architecture permits that the data read clears any exclusive monitors\nassociated with that location, even if the compare subsequently fails.\n\nIf the instruction generates a synchronous Data Abort, the register which is\ncompared and loaded, that is <Ws>, is restored to the values held in the\nregister before the instruction was executed.",
        "heading": "CASB, CASAB, CASALB, CASLB",
        "templates": {
          "BASE_REGISTER": [
            "CASAB  <Ws>, <Wt>, [<Xn|SP>{,#0}]",
            "CASALB  <Ws>, <Wt>, [<Xn|SP>{,#0}]",
            "CASB  <Ws>, <Wt>, [<Xn|SP>{,#0}]",
            "CASLB  <Ws>, <Wt>, [<Xn|SP>{,#0}]"
          ]
        }
      },
      "CASH": {
        "authored": "Compare and Swap halfword in memory reads a 16-bit halfword from memory, and\ncompares it against the value held in a first register. If the comparison is\nequal, the value in a second register is written to memory. If the write is\nperformed, the read and write occur atomically such that no other modification\nof the memory location can take place between the read and write.\n  - CASAH and CASALH load from memory with acquire semantics.\n  - CASLH and CASALH store to memory with release semantics.\n  - CAS has neither acquire nor release semantics.\n\nFor more information about memory ordering semantics see Load-Acquire, Store-\nRelease.\n\nFor information about memory accesses see Load/Store addressing modes.\n\nThe architecture permits that the data read clears any exclusive monitors\nassociated with that location, even if the compare subsequently fails.\n\nIf the instruction generates a synchronous Data Abort, the register which is\ncompared and loaded, that is <Ws>, is restored to the values held in the\nregister before the instruction was executed.",
        "heading": "CASH, CASAH, CASALH, CASLH",
        "templates": {
          "BASE_REGISTER": [
            "CASAH  <Ws>, <Wt>, [<Xn|SP>{,#0}]",
            "CASALH  <Ws>, <Wt>, [<Xn|SP>{,#0}]",
            "CASH  <Ws>, <Wt>, [<Xn|SP>{,#0}]",
            "CASLH  <Ws>, <Wt>, [<Xn|SP>{,#0}]"
          ]
        }
      },
      "CASP": {
        "authored": "Compare and Swap Pair of words or doublewords in memory reads a pair of 32-bit\nwords or 64-bit doublewords from memory, and compares them against the values\nheld in the first pair of registers. If the comparison is equal, the values in\nthe second pair of registers are written to memory. If the writes are performed,\nthe reads and writes occur atomically such that no other modification of the\nmemory location can take place between the reads and writes.\n  - CASPA and CASPAL load from memory with acquire semantics.\n  - CASPL and CASPAL store to memory with release semantics.\n  - CAS has neither acquire nor release semantics.\n\nFor more information about memory ordering semantics see Load-Acquire, Store-\nRelease.\n\nFor information about memory accesses see Load/Store addressing modes.\n\nThe architecture permits that the data read clears any exclusive monitors\nassociated with that location, even if the compare subsequently fails.\n\nIf the instruction generates a synchronous Data Abort, the registers which are\ncompared and loaded, that is <Ws> and <W(s+1)>, or <Xs> and <X(s+1)>, are\nrestored to the values held in the registers before the instruction was\nexecuted.",
        "heading": "CASP, CASPA, CASPAL, CASPL",
        "templates": {
          "BASE_REGISTER": [
            "CASP  <Ws>, <W(s+1)>, <Wt>, <W(t+1)>, [<Xn|SP>{,#0}]",
            "CASPA  <Ws>, <W(s+1)>, <Wt>, <W(t+1)>, [<Xn|SP>{,#0}]",
            "CASPAL  <Ws>, <W(s+1)>, <Wt>, <W(t+1)>, [<Xn|SP>{,#0}]",
            "CASPL  <Ws>, <W(s+1)>, <Wt>, <W(t+1)>, [<Xn|SP>{,#0}]",
            "CASP  <Xs>, <X(s+1)>, <Xt>, <X(t+1)>, [<Xn|SP>{,#0}]",
            "CASPA  <Xs>, <X(s+1)>, <Xt>, <X(t+1)>, [<Xn|SP>{,#0}]",
            "CASPAL  <Xs>, <X(s+1)>, <Xt>, <X(t+1)>, [<Xn|SP>{,#0}]",
            "CASPL  <Xs>, <X(s+1)>, <Xt>, <X(t+1)>, [<Xn|SP>{,#0}]"
          ]
        }
      },
      "CBNZ": {
        "authored": "Compare and Branch on Nonzero compares the value in a register with zero, and\nconditionally branches to a label at a PC-relative offset if the comparison is\nnot equal. It provides a hint that this is not a subroutine call or return. This\ninstruction does not affect the condition flags.",
        "heading": "CBNZ",
        "templates": {
          "BR19": [
            "CBNZ  <Wt>, <label>",
            "CBNZ  <Xt>, <label>"
          ]
        }
      },
      "CBZ": {
        "authored": "Compare and Branch on Zero compares the value in a register with zero, and\nconditionally branches to a label at a PC-relative offset if the comparison is\nequal. It provides a hint that this is not a subroutine call or return. This\ninstruction does not affect condition flags.",
        "heading": "CBZ",
        "templates": {
          "BR19": [
            "CBZ  <Wt>, <label>",
            "CBZ  <Xt>, <label>"
          ]
        }
      },
      "CCMN_imm": {
        "authored": "Conditional Compare Negative (immediate) sets the value of the condition flags\nto the result of the comparison of a register value and a negated immediate\nvalue if the condition is TRUE, and an immediate value otherwise.",
        "heading": "CCMN (immediate)",
        "templates": {
          "IMM5U": [
            "CCMN  <Wn>, #<imm>, #<nzcv>, <cond>",
            "CCMN  <Xn>, #<imm>, #<nzcv>, <cond>"
          ]
        }
      },
      "CCMN_reg": {
        "authored": "Conditional Compare Negative (register) sets the value of the condition flags to\nthe result of the comparison of a register value and the inverse of another\nregister value if the condition is TRUE, and an immediate value otherwise.",
        "heading": "CCMN (register)",
        "templates": {
          "GENERAL": [
            "CCMN  <Wn>, <Wm>, #<nzcv>, <cond>",
            "CCMN  <Xn>, <Xm>, #<nzcv>, <cond>"
          ]
        }
      },
      "CCMP_imm": {
        "authored": "Conditional Compare (immediate) sets the value of the condition flags to the\nresult of the comparison of a register value and an immediate value if the\ncondition is TRUE, and an immediate value otherwise.",
        "heading": "CCMP (immediate)",
        "templates": {
          "IMM5U": [
            "CCMP  <Wn>, #<imm>, #<nzcv>, <cond>",
            "CCMP  <Xn>, #<imm>, #<nzcv>, <cond>"
          ]
        }
      },
      "CCMP_reg": {
        "authored": "Conditional Compare (register) sets the value of the condition flags to the\nresult of the comparison of two registers if the condition is TRUE, and an\nimmediate value otherwise.",
        "heading": "CCMP (register)",
        "templates": {
          "GENERAL": [
            "CCMP  <Wn>, <Wm>, #<nzcv>, <cond>",
            "CCMP  <Xn>, <Xm>, #<nzcv>, <cond>"
          ]
        }
      },
      "CFINV": {
        "authored": "Invert Carry Flag. This instruction inverts the value of the PSTATE.C flag.",
        "heading": "CFINV",
        "templates": {
          "SYSTEM": [
            "CFINV"
          ]
        }
      },
      "CFP_SYS": {
        "authored": "Control Flow Prediction Restriction by Context prevents control flow predictions\nthat predict execution addresses, based on information gathered from earlier\nexecution within a particular execution context, from allowing later speculative\nexecution within that context to be observable through side-channels.\n\nFor more information, see CFP RCTX, Control Flow Prediction Restriction by\nContext.",
        "heading": "CFP",
        "templates": {
          "SYSTEM": [
            "CFP  RCTX, <Xt>"
          ]
        }
      },
      "CINC_CSINC": {
        "authored": "Conditional Increment returns, in the destination register, the value of the\nsource register incremented by 1 if the condition is TRUE, and otherwise returns\nthe value of the source register.",
        "heading": "CINC",
        "templates": {
          "GENERAL": [
            "CINC  <Wd>, <Wn>, <cond>",
            "CINC  <Xd>, <Xn>, <cond>"
          ]
        }
      },
      "CINV_CSINV": {
        "authored": "Conditional Invert returns, in the destination register, the bitwise inversion\nof the value of the source register if the condition is TRUE, and otherwise\nreturns the value of the source register.",
        "heading": "CINV",
        "templates": {
          "GENERAL": [
            "CINV  <Wd>, <Wn>, <cond>",
            "CINV  <Xd>, <Xn>, <cond>"
          ]
        }
      },
      "CLREX": {
        "authored": "Clear Exclusive clears the local monitor of the executing PE.",
        "heading": "CLREX",
        "templates": {
          "SYSTEM": [
            "CLREX  {#<imm>}"
          ]
        }
      },
      "CLS_int": {
        "authored": "Count Leading Sign bits counts the number of leading bits of the source register\nthat have the same value as the most significant bit of the register, and writes\nthe result to the destination register. This count does not include the most\nsignificant bit of the source register.",
        "heading": "CLS",
        "templates": {
          "GENERAL": [
            "CLS  <Wd>, <Wn>",
            "CLS  <Xd>, <Xn>"
          ]
        }
      },
      "CLZ_int": {
        "authored": "Count Leading Zeros counts the number of binary zero bits before the first\nbinary one bit in the value of the source register, and writes the result to the\ndestination register.",
        "heading": "CLZ",
        "templates": {
          "GENERAL": [
            "CLZ  <Wd>, <Wn>",
            "CLZ  <Xd>, <Xn>"
          ]
        }
      },
      "CMN_ADDS_addsub_ext": {
        "authored": "Compare Negative (extended register) adds a register value and a sign or zero-\nextended register value, followed by an optional left shift amount. The argument\nthat is extended from the <Rm> register can be a byte, halfword, word, or\ndoubleword. It updates the condition flags based on the result, and discards the\nresult.",
        "heading": "CMN (extended register)",
        "templates": {
          "S": [
            "CMN  <Wn|WSP>, <Wm>{, <extend> {#<amount>}}",
            "CMN  <Xn|SP>, <R><m>{, <extend> {#<amount>}}"
          ]
        }
      },
      "CMN_ADDS_addsub_imm": {
        "authored": "Compare Negative (immediate) adds a register value and an optionally-shifted\nimmediate value. It updates the condition flags based on the result, and\ndiscards the result.",
        "heading": "CMN (immediate)",
        "templates": {
          "S": [
            "CMN  <Wn|WSP>, #<imm>{, <shift>}",
            "CMN  <Xn|SP>, #<imm>{, <shift>}"
          ]
        }
      },
      "CMN_ADDS_addsub_shift": {
        "authored": "Compare Negative (shifted register) adds a register value and an optionally-\nshifted register value. It updates the condition flags based on the result, and\ndiscards the result.",
        "heading": "CMN (shifted register)",
        "templates": {
          "S": [
            "CMN  <Wn>, <Wm>{, <shift> #<amount>}",
            "CMN  <Xn>, <Xm>{, <shift> #<amount>}"
          ]
        }
      },
      "CMPP_SUBPS": {
        "authored": "Compare with Tag subtracts the 56-bit address held in the second source register\nfrom the 56-bit address held in the first source register, updates the condition\nflags based on the result of the subtraction, and discards the result.",
        "heading": "CMPP",
        "templates": {
          "GENERAL": [
            "CMPP  <Xn|SP>, <Xm|SP>"
          ]
        }
      },
      "CMP_SUBS_addsub_ext": {
        "authored": "Compare (extended register) subtracts a sign or zero-extended register value,\nfollowed by an optional left shift amount, from a register value. The argument\nthat is extended from the <Rm> register can be a byte, halfword, word, or\ndoubleword. It updates the condition flags based on the result, and discards the\nresult.",
        "heading": "CMP (extended register)",
        "templates": {
          "S": [
            "CMP  <Wn|WSP>, <Wm>{, <extend> {#<amount>}}",
            "CMP  <Xn|SP>, <R><m>{, <extend> {#<amount>}}"
          ]
        }
      },
      "CMP_SUBS_addsub_imm": {
        "authored": "Compare (immediate) subtracts an optionally-shifted immediate value from a\nregister value. It updates the condition flags based on the result, and discards\nthe result.",
        "heading": "CMP (immediate)",
        "templates": {
          "S": [
            "CMP  <Wn|WSP>, #<imm>{, <shift>}",
            "CMP  <Xn|SP>, #<imm>{, <shift>}"
          ]
        }
      },
      "CMP_SUBS_addsub_shift": {
        "authored": "Compare (shifted register) subtracts an optionally-shifted register value from a\nregister value. It updates the condition flags based on the result, and discards\nthe result.",
        "heading": "CMP (shifted register)",
        "templates": {
          "S": [
            "CMP  <Wn>, <Wm>{, <shift> #<amount>}",
            "CMP  <Xn>, <Xm>{, <shift> #<amount>}"
          ]
        }
      },
      "CNEG_CSNEG": {
        "authored": "Conditional Negate returns, in the destination register, the negated value of\nthe source register if the condition is TRUE, and otherwise returns the value of\nthe source register.",
        "heading": "CNEG",
        "templates": {
          "GENERAL": [
            "CNEG  <Wd>, <Wn>, <cond>",
            "CNEG  <Xd>, <Xn>, <cond>"
          ]
        }
      },
      "CPP_SYS": {
        "authored": "Cache Prefetch Prediction Restriction by Context prevents cache allocation\npredictions, based on information gathered from earlier execution within a\nparticular execution context, from allowing later speculative execution within\nthat context to be observable through side-channels.\n\nFor more information, see CPP RCTX, Cache Prefetch Prediction Restriction by\nContext.",
        "heading": "CPP",
        "templates": {
          "SYSTEM": [
            "CPP  RCTX, <Xt>"
          ]
        }
      },
      "CRC32": {
        "authored": "CRC32 checksum performs a cyclic redundancy check (CRC) calculation on a value\nheld in a general-purpose register. It takes an input CRC value in the first\nsource operand, performs a CRC on the input value in the second source operand,\nand returns the output CRC value. The second source operand can be 8, 16, 32, or\n64 bits. To align with common usage, the bit order of the values is reversed as\npart of the operation, and the polynomial 0x04C11DB7 is used for the CRC\ncalculation.\n\nIn Armv8-A, this is an optional instruction, and in Armv8.1 it is mandatory for\nall implementations to implement it.\n\nID_AA64ISAR0_EL1.CRC32 indicates whether this instruction is supported.",
        "heading": "CRC32B, CRC32H, CRC32W, CRC32X",
        "templates": {
          "CRC": [
            "CRC32B  <Wd>, <Wn>, <Wm>",
            "CRC32H  <Wd>, <Wn>, <Wm>",
            "CRC32W  <Wd>, <Wn>, <Wm>",
            "CRC32X  <Wd>, <Wn>, <Xm>"
          ]
        }
      },
      "CRC32C": {
        "authored": "CRC32 checksum performs a cyclic redundancy check (CRC) calculation on a value\nheld in a general-purpose register. It takes an input CRC value in the first\nsource operand, performs a CRC on the input value in the second source operand,\nand returns the output CRC value. The second source operand can be 8, 16, 32, or\n64 bits. To align with common usage, the bit order of the values is reversed as\npart of the operation, and the polynomial 0x1EDC6F41 is used for the CRC\ncalculation.\n\nIn Armv8-A, this is an optional instruction, and in Armv8.1 it is mandatory for\nall implementations to implement it.\n\nID_AA64ISAR0_EL1.CRC32 indicates whether this instruction is supported.",
        "heading": "CRC32CB, CRC32CH, CRC32CW, CRC32CX",
        "templates": {
          "CRC": [
            "CRC32CB  <Wd>, <Wn>, <Wm>",
            "CRC32CH  <Wd>, <Wn>, <Wm>",
            "CRC32CW  <Wd>, <Wn>, <Wm>",
            "CRC32CX  <Wd>, <Wn>, <Xm>"
          ]
        }
      },
      "CSDB": {
        "authored": "Consumption of Speculative Data Barrier is a memory barrier that controls\nspeculative execution and data value prediction.\n\nNo instruction other than branch instructions appearing in program order after\nthe CSDB can be speculatively executed using the results of any:\n  - Data value predictions of any instructions.\n  - PSTATE.{N,Z,C,V} predictions of any instructions other than conditional\nbranch instructions appearing in program order before the CSDB that have not\nbeen architecturally resolved.\n  - Predictions of SVE predication state for any SVE instructions.\n\nFor purposes of the definition of CSDB, PSTATE.{N,Z,C,V} is not considered a\ndata value. This definition permits:\n  - Control flow speculation before and after the CSDB.\n  - Speculative execution of conditional data processing instructions after the\nCSDB, unless they use the results of data value or PSTATE.{N,Z,C,V} predictions\nof instructions appearing in program order before the CSDB that have not been\narchitecturally resolved.",
        "heading": "CSDB",
        "templates": {
          "SYSTEM": [
            "CSDB"
          ]
        }
      },
      "CSEL": {
        "authored": "If the condition is true, Conditional Select writes the value of the first\nsource register to the destination register. If the condition is false, it\nwrites the value of the second source register to the destination register.",
        "heading": "CSEL",
        "templates": {
          "GENERAL": [
            "CSEL  <Wd>, <Wn>, <Wm>, <cond>",
            "CSEL  <Xd>, <Xn>, <Xm>, <cond>"
          ]
        }
      },
      "CSETM_CSINV": {
        "authored": "Conditional Set Mask sets all bits of the destination register to 1 if the\ncondition is TRUE, and otherwise sets all bits to 0.",
        "heading": "CSETM",
        "templates": {
          "GENERAL": [
            "CSETM  <Wd>, <cond>",
            "CSETM  <Xd>, <cond>"
          ]
        }
      },
      "CSET_CSINC": {
        "authored": "Conditional Set sets the destination register to 1 if the condition is TRUE, and\notherwise sets it to 0.",
        "heading": "CSET",
        "templates": {
          "GENERAL": [
            "CSET  <Wd>, <cond>",
            "CSET  <Xd>, <cond>"
          ]
        }
      },
      "CSINC": {
        "authored": "Conditional Select Increment returns, in the destination register, the value of\nthe first source register if the condition is TRUE, and otherwise returns the\nvalue of the second source register incremented by 1.",
        "heading": "CSINC",
        "templates": {
          "GENERAL": [
            "CSINC  <Wd>, <Wn>, <Wm>, <cond>",
            "CSINC  <Xd>, <Xn>, <Xm>, <cond>"
          ]
        }
      },
      "CSINV": {
        "authored": "Conditional Select Invert returns, in the destination register, the value of the\nfirst source register if the condition is TRUE, and otherwise returns the\nbitwise inversion value of the second source register.",
        "heading": "CSINV",
        "templates": {
          "GENERAL": [
            "CSINV  <Wd>, <Wn>, <Wm>, <cond>",
            "CSINV  <Xd>, <Xn>, <Xm>, <cond>"
          ]
        }
      },
      "CSNEG": {
        "authored": "Conditional Select Negation returns, in the destination register, the value of\nthe first source register if the condition is TRUE, and otherwise returns the\nnegated value of the second source register.",
        "heading": "CSNEG",
        "templates": {
          "GENERAL": [
            "CSNEG  <Wd>, <Wn>, <Wm>, <cond>",
            "CSNEG  <Xd>, <Xn>, <Xm>, <cond>"
          ]
        }
      },
      "DCPS1": {
        "authored": "Debug Change PE State to EL1, when executed in Debug state:\n  - If executed at EL0 changes the current Exception level and SP to EL1 using\nSP_EL1.\n  - Otherwise, if executed at ELx, selects SP_ELx.\n\nThe target exception level of a DCPS1 instruction is:\n  - EL1 if the instruction is executed at EL0.\n  - Otherwise, the Exception level at which the instruction is executed.\n\nWhen the target Exception level of a DCPS1 instruction is ELx, on executing this\ninstruction:\n  - ELR_ELx becomes unknown.\n  - SPSR_ELx becomes unknown.\n  - ESR_ELx becomes unknown.\n  - DLR_EL0 and DSPSR_EL0 become unknown.\n  - The endianness is set according to SCTLR_ELx.EE.\n\nThis instruction is undefined at EL0 in Non-secure state if EL2 is implemented\nand HCR_EL2.TGE == 1.\n\nThis instruction is always undefined in Non-debug state.\n\nFor more information on the operation of the DCPSn instructions, see DCPS.",
        "heading": "DCPS1",
        "templates": {
          "SYSTEM": [
            "DCPS1  {#<imm>}"
          ]
        }
      },
      "DCPS2": {
        "authored": "Debug Change PE State to EL2, when executed in Debug state:\n  - If executed at EL0 or EL1 changes the current Exception level and SP to EL2\nusing SP_EL2.\n  - Otherwise, if executed at ELx, selects SP_ELx.\n\nThe target exception level of a DCPS2 instruction is:\n  - EL2 if the instruction is executed at an exception level that is not EL3.\n  - EL3 if the instruction is executed at EL3.\n\nWhen the target Exception level of a DCPS2 instruction is ELx, on executing this\ninstruction:\n  - ELR_ELx becomes unknown.\n  - SPSR_ELx becomes unknown.\n  - ESR_ELx becomes unknown.\n  - DLR_EL0 and DSPSR_EL0 become unknown.\n  - The endianness is set according to SCTLR_ELx.EE.\n\nThis instruction is undefined at the following exception levels:\n  - All exception levels if EL2 is not implemented.\n  - At EL0 and EL1 if EL2 is disabled in the current Security state.\n\nThis instruction is always undefined in Non-debug state.\n\nFor more information on the operation of the DCPSn instructions, see DCPS.",
        "heading": "DCPS2",
        "templates": {
          "SYSTEM": [
            "DCPS2  {#<imm>}"
          ]
        }
      },
      "DCPS3": {
        "authored": "Debug Change PE State to EL3, when executed in Debug state:\n  - If executed at EL3 selects SP_EL3.\n  - Otherwise, changes the current Exception level and SP to EL3 using SP_EL3.\n\nThe target exception level of a DCPS3 instruction is EL3.\n\nOn executing a DCPS3 instruction:\n  - ELR_EL3 becomes unknown.\n  - SPSR_EL3 becomes unknown.\n  - ESR_EL3 becomes unknown.\n  - DLR_EL0 and DSPSR_EL0 become unknown.\n  - The endianness is set according to SCTLR_EL3.EE.\n\nThis instruction is undefined at all exception levels if either:\n  - EDSCR.SDD == 1.\n  - EL3 is not implemented.\n\nThis instruction is always undefined in Non-debug state.\n\nFor more information on the operation of the DCPSn instructions, see DCPS.",
        "heading": "DCPS3",
        "templates": {
          "SYSTEM": [
            "DCPS3  {#<imm>}"
          ]
        }
      },
      "DC_SYS": {
        "authored": "Data Cache operation. For more information, see op0==0b01, cache maintenance,\nTLB maintenance, and address translation instructions.",
        "heading": "DC",
        "templates": {
          "SYSTEM": [
            "DC  <dc_op>, <Xt>"
          ]
        }
      },
      "DGH": {
        "authored": "DGH is a hint instruction. A DGH instruction is not expected to be performance\noptimal to merge memory accesses with Normal Non-cacheable or Device-GRE\nattributes appearing in program order before the hint instruction with any\nmemory accesses appearing after the hint instruction into a single memory\ntransaction on an interconnect.",
        "heading": "DGH",
        "templates": {
          "SYSTEM": [
            "DGH"
          ]
        }
      },
      "DMB": {
        "authored": "Data Memory Barrier is a memory barrier that ensures the ordering of\nobservations of memory accesses, see Data Memory Barrier.",
        "heading": "DMB",
        "templates": {
          "SYSTEM": [
            "DMB  <option>|#<imm>"
          ]
        }
      },
      "DRPS": {
        "authored": null,
        "heading": "DRPS",
        "templates": {
          "SYSTEM": [
            "DRPS"
          ]
        }
      },
      "DSB": {
        "authored": "Data Synchronization Barrier is a memory barrier that ensures the completion of\nmemory accesses, see Data Synchronization Barrier.\n\nA DSB instruction with the nXS qualifier is complete when the subset of these\nmemory accesses with the XS attribute set to 0 are complete. It does not require\nthat memory accesses with the XS attribute set to 1 are complete.",
        "heading": "DSB",
        "templates": {
          "DSB_MEMORY": [
            "DSB  <option>|#<imm>"
          ],
          "DSB_NXS": [
            "DSB  <option>nXS|#<imm>"
          ]
        }
      },
      "DVP_SYS": {
        "authored": "Data Value Prediction Restriction by Context prevents data value predictions,\nbased on information gathered from earlier execution within an particular\nexecution context, from allowing later speculative execution within that context\nto be observable through side-channels.\n\nFor more information, see DVP RCTX, Data Value Prediction Restriction by\nContext.",
        "heading": "DVP",
        "templates": {
          "SYSTEM": [
            "DVP  RCTX, <Xt>"
          ]
        }
      },
      "EON": {
        "authored": "Bitwise Exclusive OR NOT (shifted register) performs a bitwise Exclusive OR NOT\nof a register value and an optionally-shifted register value, and writes the\nresult to the destination register.",
        "heading": "EON (shifted register)",
        "templates": {
          "NO_S": [
            "EON  <Wd>, <Wn>, <Wm>{, <shift> #<amount>}",
            "EON  <Xd>, <Xn>, <Xm>{, <shift> #<amount>}"
          ]
        }
      },
      "EOR_log_imm": {
        "authored": "Bitwise Exclusive OR (immediate) performs a bitwise Exclusive OR of a register\nvalue and an immediate value, and writes the result to the destination register.",
        "heading": "EOR (immediate)",
        "templates": {
          "NO_S": [
            "EOR  <Wd|WSP>, <Wn>, #<imm>",
            "EOR  <Xd|SP>, <Xn>, #<imm>"
          ]
        }
      },
      "EOR_log_shift": {
        "authored": "Bitwise Exclusive OR (shifted register) performs a bitwise Exclusive OR of a\nregister value and an optionally-shifted register value, and writes the result\nto the destination register.",
        "heading": "EOR (shifted register)",
        "templates": {
          "GENERAL": [
            "EOR  <Wd>, <Wn>, <Wm>{, <shift> #<amount>}",
            "EOR  <Xd>, <Xn>, <Xm>{, <shift> #<amount>}"
          ]
        }
      },
      "ERET": {
        "authored": "Exception Return using the ELR and SPSR for the current Exception level. When\nexecuted, the PE restores PSTATE from the SPSR, and branches to the address held\nin the ELR.\n\nThe PE checks the SPSR for the current Exception level for an illegal return\nevent. See Illegal return events from AArch64 state.\n\nERET is undefined at EL0.",
        "heading": "ERET",
        "templates": {
          "SYSTEM": [
            "ERET"
          ]
        }
      },
      "ERETA": {
        "authored": "Exception Return, with pointer authentication. This instruction authenticates\nthe address in ELR, using SP as the modifier and the specified key, the PE\nrestores PSTATE from the SPSR for the current Exception level, and branches to\nthe authenticated address.\n\nKey A is used for ERETAA, and key B is used for ERETAB.\n\nIf the authentication passes, the PE continues execution at the target of the\nbranch. If the authentication fails, a Translation fault is generated.\n\nThe authenticated address is not written back to ELR.\n\nThe PE checks the SPSR for the current Exception level for an illegal return\nevent. See Illegal return events from AArch64 state.\n\nERETAA and ERETAB are undefined at EL0.",
        "heading": "ERETAA, ERETAB",
        "templates": {
          "GENERAL": [
            "ERETAA",
            "ERETAB"
          ]
        }
      },
      "ESB": {
        "authored": "Error Synchronization Barrier is an error synchronization event that might also\nupdate DISR_EL1 and VDISR_EL2.\n\nThis instruction can be used at all Exception levels and in Debug state.\n\nIn Debug state, this instruction behaves as if SError interrupts are masked at\nall Exception levels. See Error Synchronization Barrier in the Arm(R)\nReliability, Availability, and Serviceability (RAS) Specification, Armv8, for\nArmv8-A architecture profile.\n\nIf the RAS Extension is not implemented, this instruction executes as a NOP.",
        "heading": "ESB",
        "templates": {
          "SYSTEM": [
            "ESB"
          ]
        }
      },
      "EXTR": {
        "authored": "Extract register extracts a register from a pair of registers.",
        "heading": "EXTR",
        "templates": {
          "GENERAL": [
            "EXTR  <Wd>, <Wn>, <Wm>, #<lsb>",
            "EXTR  <Xd>, <Xn>, <Xm>, #<lsb>"
          ]
        }
      },
      "GMI": {
        "authored": "Tag Mask Insert inserts the tag in the first source register into the excluded\nset specified in the second source register, writing the new excluded set to the\ndestination register.",
        "heading": "GMI",
        "templates": {
          "GENERAL": [
            "GMI  <Xd>, <Xn|SP>, <Xm>"
          ]
        }
      },
      "HINT": {
        "authored": "Hint instruction is for the instruction set space that is reserved for\narchitectural hint instructions.\n\nSome encodings described here are not allocated in this revision of the\narchitecture, and behave as NOPs. These encodings might be allocated to other\nhint functionality in future revisions of the architecture and therefore must\nnot be used by software.",
        "heading": "HINT",
        "templates": {
          "SYSTEM": [
            "HINT  #<imm>"
          ]
        }
      },
      "HLT": {
        "authored": "Halt instruction. An HLT instruction can generate a Halt Instruction debug\nevent, which causes entry into Debug state.",
        "heading": "HLT",
        "templates": {
          "SYSTEM": [
            "HLT  #<imm>"
          ]
        }
      },
      "HVC": {
        "authored": "Hypervisor Call causes an exception to EL2. Non-secure software executing at EL1\ncan use this instruction to call the hypervisor to request a service.\n\nThe HVC instruction is undefined:\n  - At EL0.\n  - At EL1 if EL2 is not enabled in the current Security state.\n  - When SCR_EL3.HCE is set to 0.\n\nOn executing an HVC instruction, the PE records the exception as a Hypervisor\nCall exception in ESR_ELx, using the EC value 0x16, and the value of the\nimmediate argument.",
        "heading": "HVC",
        "templates": {
          "SYSTEM": [
            "HVC  #<imm>"
          ]
        }
      },
      "IC_SYS": {
        "authored": "Instruction Cache operation. For more information, see op0==0b01, cache\nmaintenance, TLB maintenance, and address translation instructions.",
        "heading": "IC",
        "templates": {
          "SYSTEM": [
            "IC  <ic_op>{, <Xt>}"
          ]
        }
      },
      "IRG": {
        "authored": "Insert Random Tag inserts a random Logical Address Tag into the address in the\nfirst source register, and writes the result to the destination register. Any\ntags specified in the optional second source register or in GCR_EL1.Exclude are\nexcluded from the selection of the random Logical Address Tag.",
        "heading": "IRG",
        "templates": {
          "GENERAL": [
            "IRG  <Xd|SP>, <Xn|SP>{, <Xm>}"
          ]
        }
      },
      "ISB": {
        "authored": "Instruction Synchronization Barrier flushes the pipeline in the PE and is a\ncontext synchronization event. For more information, see Instruction\nSynchronization Barrier (ISB).",
        "heading": "ISB",
        "templates": {
          "SYSTEM": [
            "ISB  {<option>|#<imm>}"
          ]
        }
      },
      "LD64B": {
        "authored": "Single-copy Atomic 64-byte Load derives an address from a base register value,\nloads eight 64-bit doublewords from a memory location, and writes them to\nconsecutive registers, Xt to X(t+7). The data that is loaded is atomic and is\nrequired to be 64-byte aligned.",
        "heading": "LD64B",
        "templates": {
          "GENERAL": [
            "LD64B  <Xt>, [<Xn|SP> {,#0}]"
          ]
        }
      },
      "LDADD": {
        "authored": "Atomic add on word or doubleword in memory atomically loads a 32-bit word or\n64-bit doubleword from memory, adds the value held in a register to it, and\nstores the result back to memory. The value initially loaded from memory is\nreturned in the destination register.\n  - If the destination register is not one of WZR or XZR, LDADDA and LDADDAL\nload from memory with acquire semantics.\n  - LDADDL and LDADDAL store to memory with release semantics.\n  - LDADD has neither acquire nor release semantics.\n\nFor more information about memory ordering semantics see Load-Acquire, Store-\nRelease.\n\nFor information about memory accesses see Load/Store addressing modes.",
        "heading": "LDADD, LDADDA, LDADDAL, LDADDL",
        "templates": {
          "GENERAL": [
            "LDADD  <Ws>, <Wt>, [<Xn|SP>]",
            "LDADDA  <Ws>, <Wt>, [<Xn|SP>]",
            "LDADDAL  <Ws>, <Wt>, [<Xn|SP>]",
            "LDADDL  <Ws>, <Wt>, [<Xn|SP>]",
            "LDADD  <Xs>, <Xt>, [<Xn|SP>]",
            "LDADDA  <Xs>, <Xt>, [<Xn|SP>]",
            "LDADDAL  <Xs>, <Xt>, [<Xn|SP>]",
            "LDADDL  <Xs>, <Xt>, [<Xn|SP>]"
          ]
        }
      },
      "LDADDB": {
        "authored": "Atomic add on byte in memory atomically loads an 8-bit byte from memory, adds\nthe value held in a register to it, and stores the result back to memory. The\nvalue initially loaded from memory is returned in the destination register.\n  - If the destination register is not WZR, LDADDAB and LDADDALB load from\nmemory with acquire semantics.\n  - LDADDLB and LDADDALB store to memory with release semantics.\n  - LDADDB has neither acquire nor release semantics.\n\nFor more information about memory ordering semantics see Load-Acquire, Store-\nRelease.\n\nFor information about memory accesses see Load/Store addressing modes.",
        "heading": "LDADDB, LDADDAB, LDADDALB, LDADDLB",
        "templates": {
          "GENERAL": [
            "LDADDAB  <Ws>, <Wt>, [<Xn|SP>]",
            "LDADDALB  <Ws>, <Wt>, [<Xn|SP>]",
            "LDADDB  <Ws>, <Wt>, [<Xn|SP>]",
            "LDADDLB  <Ws>, <Wt>, [<Xn|SP>]"
          ]
        }
      },
      "LDADDH": {
        "authored": "Atomic add on halfword in memory atomically loads a 16-bit halfword from memory,\nadds the value held in a register to it, and stores the result back to memory.\nThe value initially loaded from memory is returned in the destination register.\n  - If the destination register is not WZR, LDADDAH and LDADDALH load from\nmemory with acquire semantics.\n  - LDADDLH and LDADDALH store to memory with release semantics.\n  - LDADDH has neither acquire nor release semantics.\n\nFor more information about memory ordering semantics see Load-Acquire, Store-\nRelease.\n\nFor information about memory accesses see Load/Store addressing modes.",
        "heading": "LDADDH, LDADDAH, LDADDALH, LDADDLH",
        "templates": {
          "GENERAL": [
            "LDADDAH  <Ws>, <Wt>, [<Xn|SP>]",
            "LDADDALH  <Ws>, <Wt>, [<Xn|SP>]",
            "LDADDH  <Ws>, <Wt>, [<Xn|SP>]",
            "LDADDLH  <Ws>, <Wt>, [<Xn|SP>]"
          ]
        }
      },
      "LDAPR": {
        "authored": "Load-Acquire RCpc Register derives an address from a base register value, loads\na 32-bit word or 64-bit doubleword from the derived address in memory, and\nwrites it to a register.\n\nThe instruction has memory ordering semantics as described in Load-Acquire,\nLoad-AcquirePC, and Store-Release, except that:\n  - There is no ordering requirement, separate from the requirements of a Load-\nAcquirePC or a Store-Release, created by having a Store-Release followed by a\nLoad-AcquirePC instruction.\n  - The reading of a value written by a Store-Release by a Load-AcquirePC\ninstruction by the same observer does not make the write of the Store-Release\nglobally observed.\n\nThis difference in memory ordering is not described in the pseudocode.\n\nFor information about memory accesses, see Load/Store addressing modes.",
        "heading": "LDAPR",
        "templates": {
          "GENERAL": [
            "LDAPR  <Wt>, [<Xn|SP> {,#0}]",
            "LDAPR  <Xt>, [<Xn|SP> {,#0}]"
          ]
        }
      },
      "LDAPRB": {
        "authored": "Load-Acquire RCpc Register Byte derives an address from a base register value,\nloads a byte from the derived address in memory, zero-extends it and writes it\nto a register.\n\nThe instruction has memory ordering semantics as described in Load-Acquire,\nLoad-AcquirePC, and Store-Release, except that:\n  - There is no ordering requirement, separate from the requirements of a Load-\nAcquirePC or a Store-Release, created by having a Store-Release followed by a\nLoad-AcquirePC instruction.\n  - The reading of a value written by a Store-Release by a Load-AcquirePC\ninstruction by the same observer does not make the write of the Store-Release\nglobally observed.\n\nThis difference in memory ordering is not described in the pseudocode.\n\nFor information about memory accesses, see Load/Store addressing modes.",
        "heading": "LDAPRB",
        "templates": {
          "GENERAL": [
            "LDAPRB  <Wt>, [<Xn|SP> {,#0}]"
          ]
        }
      },
      "LDAPRH": {
        "authored": "Load-Acquire RCpc Register Halfword derives an address from a base register\nvalue, loads a halfword from the derived address in memory, zero-extends it and\nwrites it to a register.\n\nThe instruction has memory ordering semantics as described in Load-Acquire,\nLoad-AcquirePC, and Store-Release, except that:\n  - There is no ordering requirement, separate from the requirements of a Load-\nAcquirePC or a Store-Release, created by having a Store-Release followed by a\nLoad-AcquirePC instruction.\n  - The reading of a value written by a Store-Release by a Load-AcquirePC\ninstruction by the same observer does not make the write of the Store-Release\nglobally observed.\n\nThis difference in memory ordering is not described in the pseudocode.\n\nFor information about memory accesses, see Load/Store addressing modes.",
        "heading": "LDAPRH",
        "templates": {
          "GENERAL": [
            "LDAPRH  <Wt>, [<Xn|SP> {,#0}]"
          ]
        }
      },
      "LDAPURB": {
        "authored": "Load-Acquire RCpc Register Byte (unscaled) calculates an address from a base\nregister and an immediate offset, loads a byte from memory, zero-extends it, and\nwrites it to a register.\n\nThe instruction has memory ordering semantics as described in Load-Acquire,\nLoad-AcquirePC, and Store-Release, except that:\n  - There is no ordering requirement, separate from the requirements of a Load-\nAcquirePC or a Store-Release, created by having a Store-Release followed by a\nLoad-AcquirePC instruction.\n  - The reading of a value written by a Store-Release by a Load-AcquirePC\ninstruction by the same observer does not make the write of the Store-Release\nglobally observed.\n\nThis difference in memory ordering is not described in the pseudocode.\n\nFor information about memory accesses, see Load/Store addressing modes.",
        "heading": "LDAPURB",
        "templates": {
          "BASE_PLUS_OFFSET": [
            "LDAPURB  <Wt>, [<Xn|SP>{, #<simm>}]"
          ]
        }
      },
      "LDAPURH": {
        "authored": "Load-Acquire RCpc Register Halfword (unscaled) calculates an address from a base\nregister and an immediate offset, loads a halfword from memory, zero-extends it,\nand writes it to a register.\n\nThe instruction has memory ordering semantics as described in Load-Acquire,\nLoad-AcquirePC, and Store-Release, except that:\n  - There is no ordering requirement, separate from the requirements of a Load-\nAcquirePC or a Store-Release, created by having a Store-Release followed by a\nLoad-AcquirePC instruction.\n  - The reading of a value written by a Store-Release by a Load-AcquirePC\ninstruction by the same observer does not make the write of the Store-Release\nglobally observed.\n\nThis difference in memory ordering is not described in the pseudocode.\n\nFor information about memory accesses, see Load/Store addressing modes.",
        "heading": "LDAPURH",
        "templates": {
          "BASE_PLUS_OFFSET": [
            "LDAPURH  <Wt>, [<Xn|SP>{, #<simm>}]"
          ]
        }
      },
      "LDAPURSB": {
        "authored": "Load-Acquire RCpc Register Signed Byte (unscaled) calculates an address from a\nbase register and an immediate offset, loads a signed byte from memory, sign-\nextends it, and writes it to a register.\n\nThe instruction has memory ordering semantics as described in Load-Acquire,\nLoad-AcquirePC, and Store-Release, except that:\n  - There is no ordering requirement, separate from the requirements of a Load-\nAcquirePC or a Store-Release, created by having a Store-Release followed by a\nLoad-AcquirePC instruction.\n  - The reading of a value written by a Store-Release by a Load-AcquirePC\ninstruction by the same observer does not make the write of the Store-Release\nglobally observed.\n\nThis difference in memory ordering is not described in the pseudocode.\n\nFor information about memory accesses, see Load/Store addressing modes.",
        "heading": "LDAPURSB",
        "templates": {
          "BASE_PLUS_OFFSET": [
            "LDAPURSB  <Wt>, [<Xn|SP>{, #<simm>}]",
            "LDAPURSB  <Xt>, [<Xn|SP>{, #<simm>}]"
          ]
        }
      },
      "LDAPURSH": {
        "authored": "Load-Acquire RCpc Register Signed Halfword (unscaled) calculates an address from\na base register and an immediate offset, loads a signed halfword from memory,\nsign-extends it, and writes it to a register.\n\nThe instruction has memory ordering semantics as described in Load-Acquire,\nLoad-AcquirePC, and Store-Release, except that:\n  - There is no ordering requirement, separate from the requirements of a Load-\nAcquirePC or a Store-Release, created by having a Store-Release followed by a\nLoad-AcquirePC instruction.\n  - The reading of a value written by a Store-Release by a Load-AcquirePC\ninstruction by the same observer does not make the write of the Store-Release\nglobally observed.\n\nThis difference in memory ordering is not described in the pseudocode.\n\nFor information about memory accesses, see Load/Store addressing modes.",
        "heading": "LDAPURSH",
        "templates": {
          "BASE_PLUS_OFFSET": [
            "LDAPURSH  <Wt>, [<Xn|SP>{, #<simm>}]",
            "LDAPURSH  <Xt>, [<Xn|SP>{, #<simm>}]"
          ]
        }
      },
      "LDAPURSW": {
        "authored": "Load-Acquire RCpc Register Signed Word (unscaled) calculates an address from a\nbase register and an immediate offset, loads a signed word from memory, sign-\nextends it, and writes it to a register.\n\nThe instruction has memory ordering semantics as described in Load-Acquire,\nLoad-AcquirePC, and Store-Release, except that:\n  - There is no ordering requirement, separate from the requirements of a Load-\nAcquirePC or a Store-Release, created by having a Store-Release followed by a\nLoad-AcquirePC instruction.\n  - The reading of a value written by a Store-Release by a Load-AcquirePC\ninstruction by the same observer does not make the write of the Store-Release\nglobally observed.\n\nThis difference in memory ordering is not described in the pseudocode.\n\nFor information about memory accesses, see Load/Store addressing modes.",
        "heading": "LDAPURSW",
        "templates": {
          "BASE_PLUS_OFFSET": [
            "LDAPURSW  <Xt>, [<Xn|SP>{, #<simm>}]"
          ]
        }
      },
      "LDAPUR_gen": {
        "authored": "Load-Acquire RCpc Register (unscaled) calculates an address from a base register\nand an immediate offset, loads a 32-bit word or 64-bit doubleword from memory,\nzero-extends it, and writes it to a register.\n\nThe instruction has memory ordering semantics as described in Load-Acquire,\nLoad-AcquirePC, and Store-Release, except that:\n  - There is no ordering requirement, separate from the requirements of a Load-\nAcquirePC or a Store-Release, created by having a Store-Release followed by a\nLoad-AcquirePC instruction.\n  - The reading of a value written by a Store-Release by a Load-AcquirePC\ninstruction by the same observer does not make the write of the Store-Release\nglobally observed.\n\nThis difference in memory ordering is not described in the pseudocode.\n\nFor information about memory accesses, see Load/Store addressing modes.",
        "heading": "LDAPUR",
        "templates": {
          "BASE_PLUS_OFFSET": [
            "LDAPUR  <Wt>, [<Xn|SP>{, #<simm>}]",
            "LDAPUR  <Xt>, [<Xn|SP>{, #<simm>}]"
          ]
        }
      },
      "LDAR": {
        "authored": "Load-Acquire Register derives an address from a base register value, loads a\n32-bit word or 64-bit doubleword from memory, and writes it to a register. The\ninstruction also has memory ordering semantics as described in Load-Acquire,\nStore-Release. For information about memory accesses, see Load/Store addressing\nmodes.\n\nFor this instruction, if the destination is WZR/XZR, it is impossible for\nsoftware to observe the presence of the acquire semantic other than its effect\non the arrival at endpoints.",
        "heading": "LDAR",
        "templates": {
          "BASE_REGISTER": [
            "LDAR  <Wt>, [<Xn|SP>{,#0}]",
            "LDAR  <Xt>, [<Xn|SP>{,#0}]"
          ]
        }
      },
      "LDARB": {
        "authored": "Load-Acquire Register Byte derives an address from a base register value, loads\na byte from memory, zero-extends it and writes it to a register. The instruction\nalso has memory ordering semantics as described in Load-Acquire, Store-Release.\nFor information about memory accesses, see Load/Store addressing modes.\n\nFor this instruction, if the destination is WZR/XZR, it is impossible for\nsoftware to observe the presence of the acquire semantic other than its effect\non the arrival at endpoints.",
        "heading": "LDARB",
        "templates": {
          "BASE_REGISTER": [
            "LDARB  <Wt>, [<Xn|SP>{,#0}]"
          ]
        }
      },
      "LDARH": {
        "authored": "Load-Acquire Register Halfword derives an address from a base register value,\nloads a halfword from memory, zero-extends it, and writes it to a register. The\ninstruction also has memory ordering semantics as described in Load-Acquire,\nStore-Release. For information about memory accesses, see Load/Store addressing\nmodes.\n\nFor this instruction, if the destination is WZR/XZR, it is impossible for\nsoftware to observe the presence of the acquire semantic other than its effect\non the arrival at endpoints.",
        "heading": "LDARH",
        "templates": {
          "BASE_REGISTER": [
            "LDARH  <Wt>, [<Xn|SP>{,#0}]"
          ]
        }
      },
      "LDAXP": {
        "authored": "Load-Acquire Exclusive Pair of Registers derives an address from a base register\nvalue, loads two 32-bit words or two 64-bit doublewords from memory, and writes\nthem to two registers. A 32-bit pair requires the address to be doubleword\naligned and is single-copy atomic at doubleword granularity. A 64-bit pair\nrequires the address to be quadword aligned and is single-copy atomic for each\ndoubleword at doubleword granularity. The PE marks the physical address being\naccessed as an exclusive access. This exclusive access mark is checked by Store\nExclusive instructions. See Synchronization and semaphores. The instruction also\nhas memory ordering semantics as described in Load-Acquire, Store-Release. For\ninformation about memory accesses see Load/Store addressing modes.",
        "heading": "LDAXP",
        "templates": {
          "BASE_REGISTER": [
            "LDAXP  <Wt1>, <Wt2>, [<Xn|SP>{,#0}]",
            "LDAXP  <Xt1>, <Xt2>, [<Xn|SP>{,#0}]"
          ]
        }
      },
      "LDAXR": {
        "authored": "Load-Acquire Exclusive Register derives an address from a base register value,\nloads a 32-bit word or 64-bit doubleword from memory, and writes it to a\nregister. The memory access is atomic. The PE marks the physical address being\naccessed as an exclusive access. This exclusive access mark is checked by Store\nExclusive instructions. See Synchronization and semaphores. The instruction also\nhas memory ordering semantics as described in Load-Acquire, Store-Release. For\ninformation about memory accesses see Load/Store addressing modes.",
        "heading": "LDAXR",
        "templates": {
          "BASE_REGISTER": [
            "LDAXR  <Wt>, [<Xn|SP>{,#0}]",
            "LDAXR  <Xt>, [<Xn|SP>{,#0}]"
          ]
        }
      },
      "LDAXRB": {
        "authored": "Load-Acquire Exclusive Register Byte derives an address from a base register\nvalue, loads a byte from memory, zero-extends it and writes it to a register.\nThe memory access is atomic. The PE marks the physical address being accessed as\nan exclusive access. This exclusive access mark is checked by Store Exclusive\ninstructions. See Synchronization and semaphores. The instruction also has\nmemory ordering semantics as described in Load-Acquire, Store-Release. For\ninformation about memory accesses see Load/Store addressing modes.",
        "heading": "LDAXRB",
        "templates": {
          "BASE_REGISTER": [
            "LDAXRB  <Wt>, [<Xn|SP>{,#0}]"
          ]
        }
      },
      "LDAXRH": {
        "authored": "Load-Acquire Exclusive Register Halfword derives an address from a base register\nvalue, loads a halfword from memory, zero-extends it and writes it to a\nregister. The memory access is atomic. The PE marks the physical address being\naccessed as an exclusive access. This exclusive access mark is checked by Store\nExclusive instructions. See Synchronization and semaphores. The instruction also\nhas memory ordering semantics as described in Load-Acquire, Store-Release. For\ninformation about memory accesses see Load/Store addressing modes.",
        "heading": "LDAXRH",
        "templates": {
          "BASE_REGISTER": [
            "LDAXRH  <Wt>, [<Xn|SP>{,#0}]"
          ]
        }
      },
      "LDCLR": {
        "authored": "Atomic bit clear on word or doubleword in memory atomically loads a 32-bit word\nor 64-bit doubleword from memory, performs a bitwise AND with the complement of\nthe value held in a register on it, and stores the result back to memory. The\nvalue initially loaded from memory is returned in the destination register.\n  - If the destination register is not one of WZR or XZR, LDCLRA and LDCLRAL\nload from memory with acquire semantics.\n  - LDCLRL and LDCLRAL store to memory with release semantics.\n  - LDCLR has neither acquire nor release semantics.\n\nFor more information about memory ordering semantics see Load-Acquire, Store-\nRelease.\n\nFor information about memory accesses see Load/Store addressing modes.",
        "heading": "LDCLR, LDCLRA, LDCLRAL, LDCLRL",
        "templates": {
          "GENERAL": [
            "LDCLR  <Ws>, <Wt>, [<Xn|SP>]",
            "LDCLRA  <Ws>, <Wt>, [<Xn|SP>]",
            "LDCLRAL  <Ws>, <Wt>, [<Xn|SP>]",
            "LDCLRL  <Ws>, <Wt>, [<Xn|SP>]",
            "LDCLR  <Xs>, <Xt>, [<Xn|SP>]",
            "LDCLRA  <Xs>, <Xt>, [<Xn|SP>]",
            "LDCLRAL  <Xs>, <Xt>, [<Xn|SP>]",
            "LDCLRL  <Xs>, <Xt>, [<Xn|SP>]"
          ]
        }
      },
      "LDCLRB": {
        "authored": "Atomic bit clear on byte in memory atomically loads an 8-bit byte from memory,\nperforms a bitwise AND with the complement of the value held in a register on\nit, and stores the result back to memory. The value initially loaded from memory\nis returned in the destination register.\n  - If the destination register is not WZR, LDCLRAB and LDCLRALB load from\nmemory with acquire semantics.\n  - LDCLRLB and LDCLRALB store to memory with release semantics.\n  - LDCLRB has neither acquire nor release semantics.\n\nFor more information about memory ordering semantics see Load-Acquire, Store-\nRelease.\n\nFor information about memory accesses see Load/Store addressing modes.",
        "heading": "LDCLRB, LDCLRAB, LDCLRALB, LDCLRLB",
        "templates": {
          "GENERAL": [
            "LDCLRAB  <Ws>, <Wt>, [<Xn|SP>]",
            "LDCLRALB  <Ws>, <Wt>, [<Xn|SP>]",
            "LDCLRB  <Ws>, <Wt>, [<Xn|SP>]",
            "LDCLRLB  <Ws>, <Wt>, [<Xn|SP>]"
          ]
        }
      },
      "LDCLRH": {
        "authored": "Atomic bit clear on halfword in memory atomically loads a 16-bit halfword from\nmemory, performs a bitwise AND with the complement of the value held in a\nregister on it, and stores the result back to memory. The value initially loaded\nfrom memory is returned in the destination register.\n  - If the destination register is not WZR, LDCLRAH and LDCLRALH load from\nmemory with acquire semantics.\n  - LDCLRLH and LDCLRALH store to memory with release semantics.\n  - LDCLRH has neither acquire nor release semantics.\n\nFor more information about memory ordering semantics see Load-Acquire, Store-\nRelease.\n\nFor information about memory accesses see Load/Store addressing modes.",
        "heading": "LDCLRH, LDCLRAH, LDCLRALH, LDCLRLH",
        "templates": {
          "GENERAL": [
            "LDCLRAH  <Ws>, <Wt>, [<Xn|SP>]",
            "LDCLRALH  <Ws>, <Wt>, [<Xn|SP>]",
            "LDCLRH  <Ws>, <Wt>, [<Xn|SP>]",
            "LDCLRLH  <Ws>, <Wt>, [<Xn|SP>]"
          ]
        }
      },
      "LDEOR": {
        "authored": "Atomic exclusive OR on word or doubleword in memory atomically loads a 32-bit\nword or 64-bit doubleword from memory, performs an exclusive OR with the value\nheld in a register on it, and stores the result back to memory. The value\ninitially loaded from memory is returned in the destination register.\n  - If the destination register is not one of WZR or XZR, LDEORA and LDEORAL\nload from memory with acquire semantics.\n  - LDEORL and LDEORAL store to memory with release semantics.\n  - LDEOR has neither acquire nor release semantics.\n\nFor more information about memory ordering semantics see Load-Acquire, Store-\nRelease.\n\nFor information about memory accesses see Load/Store addressing modes.",
        "heading": "LDEOR, LDEORA, LDEORAL, LDEORL",
        "templates": {
          "GENERAL": [
            "LDEOR  <Ws>, <Wt>, [<Xn|SP>]",
            "LDEORA  <Ws>, <Wt>, [<Xn|SP>]",
            "LDEORAL  <Ws>, <Wt>, [<Xn|SP>]",
            "LDEORL  <Ws>, <Wt>, [<Xn|SP>]",
            "LDEOR  <Xs>, <Xt>, [<Xn|SP>]",
            "LDEORA  <Xs>, <Xt>, [<Xn|SP>]",
            "LDEORAL  <Xs>, <Xt>, [<Xn|SP>]",
            "LDEORL  <Xs>, <Xt>, [<Xn|SP>]"
          ]
        }
      },
      "LDEORB": {
        "authored": "Atomic exclusive OR on byte in memory atomically loads an 8-bit byte from\nmemory, performs an exclusive OR with the value held in a register on it, and\nstores the result back to memory. The value initially loaded from memory is\nreturned in the destination register.\n  - If the destination register is not WZR, LDEORAB and LDEORALB load from\nmemory with acquire semantics.\n  - LDEORLB and LDEORALB store to memory with release semantics.\n  - LDEORB has neither acquire nor release semantics.\n\nFor more information about memory ordering semantics see Load-Acquire, Store-\nRelease.\n\nFor information about memory accesses see Load/Store addressing modes.",
        "heading": "LDEORB, LDEORAB, LDEORALB, LDEORLB",
        "templates": {
          "GENERAL": [
            "LDEORAB  <Ws>, <Wt>, [<Xn|SP>]",
            "LDEORALB  <Ws>, <Wt>, [<Xn|SP>]",
            "LDEORB  <Ws>, <Wt>, [<Xn|SP>]",
            "LDEORLB  <Ws>, <Wt>, [<Xn|SP>]"
          ]
        }
      },
      "LDEORH": {
        "authored": "Atomic exclusive OR on halfword in memory atomically loads a 16-bit halfword\nfrom memory, performs an exclusive OR with the value held in a register on it,\nand stores the result back to memory. The value initially loaded from memory is\nreturned in the destination register.\n  - If the destination register is not WZR, LDEORAH and LDEORALH load from\nmemory with acquire semantics.\n  - LDEORLH and LDEORALH store to memory with release semantics.\n  - LDEORH has neither acquire nor release semantics.\n\nFor more information about memory ordering semantics see Load-Acquire, Store-\nRelease.\n\nFor information about memory accesses see Load/Store addressing modes.",
        "heading": "LDEORH, LDEORAH, LDEORALH, LDEORLH",
        "templates": {
          "GENERAL": [
            "LDEORAH  <Ws>, <Wt>, [<Xn|SP>]",
            "LDEORALH  <Ws>, <Wt>, [<Xn|SP>]",
            "LDEORH  <Ws>, <Wt>, [<Xn|SP>]",
            "LDEORLH  <Ws>, <Wt>, [<Xn|SP>]"
          ]
        }
      },
      "LDG": {
        "authored": "Load Allocation Tag loads an Allocation Tag from a memory address, generates a\nLogical Address Tag from the Allocation Tag and merges it into the destination\nregister. The address used for the load is calculated from the base register and\nan immediate signed offset scaled by the Tag granule.",
        "heading": "LDG",
        "templates": {
          "GENERAL": [
            "LDG  <Xt>, [<Xn|SP>{, #<simm>}]"
          ]
        }
      },
      "LDGM": {
        "authored": "Load Tag Multiple reads a naturally aligned block of N Allocation Tags, where\nthe size of N is identified in GMID_EL1.BS, and writes the Allocation Tag read\nfrom address A to the destination register at 4*A<7:4>+3:4*A<7:4>. Bits of the\ndestination register not written with an Allocation Tag are set to 0.\n\nThis instruction is undefined at EL0.\n\nThis instruction generates an Unchecked access.\n\nIf ID_AA64PFR1_EL1.MTE != 0b0010, this instruction is undefined.",
        "heading": "LDGM",
        "templates": {
          "GENERAL": [
            "LDGM  <Xt>, [<Xn|SP>]"
          ]
        }
      },
      "LDLAR": {
        "authored": "Load LOAcquire Register loads a 32-bit word or 64-bit doubleword from memory,\nand writes it to a register. The instruction also has memory ordering semantics\nas described in Load LOAcquire, Store LORelease. For information about memory\naccesses, see Load/Store addressing modes.\n\nFor this instruction, if the destination is WZR/XZR, it is impossible for\nsoftware to observe the presence of the acquire semantic other than its effect\non the arrival at endpoints.",
        "heading": "LDLAR",
        "templates": {
          "BASE_REGISTER": [
            "LDLAR  <Wt>, [<Xn|SP>{,#0}]",
            "LDLAR  <Xt>, [<Xn|SP>{,#0}]"
          ]
        }
      },
      "LDLARB": {
        "authored": "Load LOAcquire Register Byte loads a byte from memory, zero-extends it and\nwrites it to a register. The instruction also has memory ordering semantics as\ndescribed in Load LOAcquire, Store LORelease. For information about memory\naccesses, see Load/Store addressing modes.\n\nFor this instruction, if the destination is WZR/XZR, it is impossible for\nsoftware to observe the presence of the acquire semantic other than its effect\non the arrival at endpoints.",
        "heading": "LDLARB",
        "templates": {
          "BASE_REGISTER": [
            "LDLARB  <Wt>, [<Xn|SP>{,#0}]"
          ]
        }
      },
      "LDLARH": {
        "authored": "Load LOAcquire Register Halfword loads a halfword from memory, zero-extends it,\nand writes it to a register. The instruction also has memory ordering semantics\nas described in Load LOAcquire, Store LORelease. For information about memory\naccesses, see Load/Store addressing modes.\n\nFor this instruction, if the destination is WZR/XZR, it is impossible for\nsoftware to observe the presence of the acquire semantic other than its effect\non the arrival at endpoints.",
        "heading": "LDLARH",
        "templates": {
          "BASE_REGISTER": [
            "LDLARH  <Wt>, [<Xn|SP>{,#0}]"
          ]
        }
      },
      "LDNP_gen": {
        "authored": "Load Pair of Registers, with non-temporal hint, calculates an address from a\nbase register value and an immediate offset, loads two 32-bit words or two\n64-bit doublewords from memory, and writes them to two registers.\n\nFor information about memory accesses, see Load/Store addressing modes. For\ninformation about Non-temporal pair instructions, see Load/Store Non-temporal\npair.",
        "heading": "LDNP",
        "templates": {
          "SIGNED_SCALED_OFFSET": [
            "LDNP  <Wt1>, <Wt2>, [<Xn|SP>{, #<imm>}]",
            "LDNP  <Xt1>, <Xt2>, [<Xn|SP>{, #<imm>}]"
          ]
        }
      },
      "LDPSW": {
        "authored": "Load Pair of Registers Signed Word calculates an address from a base register\nvalue and an immediate offset, loads two 32-bit words from memory, sign-extends\nthem, and writes them to two registers. For information about memory accesses,\nsee Load/Store addressing modes.",
        "heading": "LDPSW",
        "templates": {
          "POST_INDEXED": [
            "LDPSW  <Xt1>, <Xt2>, [<Xn|SP>], #<imm>"
          ],
          "PRE_INDEXED": [
            "LDPSW  <Xt1>, <Xt2>, [<Xn|SP>, #<imm>]!"
          ],
          "SIGNED_SCALED_OFFSET": [
            "LDPSW  <Xt1>, <Xt2>, [<Xn|SP>{, #<imm>}]"
          ]
        }
      },
      "LDP_gen": {
        "authored": "Load Pair of Registers calculates an address from a base register value and an\nimmediate offset, loads two 32-bit words or two 64-bit doublewords from memory,\nand writes them to two registers. For information about memory accesses, see\nLoad/Store addressing modes.",
        "heading": "LDP",
        "templates": {
          "POST_INDEXED": [
            "LDP  <Wt1>, <Wt2>, [<Xn|SP>], #<imm>",
            "LDP  <Xt1>, <Xt2>, [<Xn|SP>], #<imm>"
          ],
          "PRE_INDEXED": [
            "LDP  <Wt1>, <Wt2>, [<Xn|SP>, #<imm>]!",
            "LDP  <Xt1>, <Xt2>, [<Xn|SP>, #<imm>]!"
          ],
          "SIGNED_SCALED_OFFSET": [
            "LDP  <Wt1>, <Wt2>, [<Xn|SP>{, #<imm>}]",
            "LDP  <Xt1>, <Xt2>, [<Xn|SP>{, #<imm>}]"
          ]
        }
      },
      "LDRA": {
        "authored": "Load Register, with pointer authentication. This instruction authenticates an\naddress from a base register using a modifier of zero and the specified key,\nadds an immediate offset to the authenticated address, and loads a 64-bit\ndoubleword from memory at this resulting address into a register.\n\nKey A is used for LDRAA, and key B is used for LDRAB.\n\nIf the authentication passes, the PE behaves the same as for an LDR instruction.\nIf the authentication fails, a Translation fault is generated.\n\nThe authenticated address is not written back to the base register, unless the\npre-indexed variant of the instruction is used. In this case, the address that\nis written back to the base register does not include the pointer authentication\ncode.\n\nFor information about memory accesses, see Load/Store addressing modes.",
        "heading": "LDRAA, LDRAB",
        "templates": {
          "BASE_PLUS_OFFSET": [
            "LDRAA  <Xt>, [<Xn|SP>{, #<simm>}]",
            "LDRAA  <Xt>, [<Xn|SP>{, #<simm>}]!",
            "LDRAB  <Xt>, [<Xn|SP>{, #<simm>}]",
            "LDRAB  <Xt>, [<Xn|SP>{, #<simm>}]!"
          ]
        }
      },
      "LDRB_imm": {
        "authored": "Load Register Byte (immediate) loads a byte from memory, zero-extends it, and\nwrites the result to a register. The address that is used for the load is\ncalculated from a base register and an immediate offset. For information about\nmemory accesses, see Load/Store addressing modes.",
        "heading": "LDRB (immediate)",
        "templates": {
          "POST_INDEXED": [
            "LDRB  <Wt>, [<Xn|SP>], #<simm>"
          ],
          "PRE_INDEXED": [
            "LDRB  <Wt>, [<Xn|SP>, #<simm>]!"
          ],
          "UNSIGNED_SCALED_OFFSET": [
            "LDRB  <Wt>, [<Xn|SP>{, #<pimm>}]"
          ]
        }
      },
      "LDRB_reg": {
        "authored": "Load Register Byte (register) calculates an address from a base register value\nand an offset register value, loads a byte from memory, zero-extends it, and\nwrites it to a register. For information about memory accesses, see Load/Store\naddressing modes.",
        "heading": "LDRB (register)",
        "templates": {
          "32": [
            "LDRB  <Wt>, [<Xn|SP>, (<Wm>|<Xm>), <extend> {<amount>}]",
            "LDRB  <Wt>, [<Xn|SP>, <Xm>{, LSL <amount>}]"
          ]
        }
      },
      "LDRH_imm": {
        "authored": "Load Register Halfword (immediate) loads a halfword from memory, zero-extends\nit, and writes the result to a register. The address that is used for the load\nis calculated from a base register and an immediate offset. For information\nabout memory accesses, see Load/Store addressing modes.",
        "heading": "LDRH (immediate)",
        "templates": {
          "POST_INDEXED": [
            "LDRH  <Wt>, [<Xn|SP>], #<simm>"
          ],
          "PRE_INDEXED": [
            "LDRH  <Wt>, [<Xn|SP>, #<simm>]!"
          ],
          "UNSIGNED_SCALED_OFFSET": [
            "LDRH  <Wt>, [<Xn|SP>{, #<pimm>}]"
          ]
        }
      },
      "LDRH_reg": {
        "authored": "Load Register Halfword (register) calculates an address from a base register\nvalue and an offset register value, loads a halfword from memory, zero-extends\nit, and writes it to a register. For information about memory accesses, see\nLoad/Store addressing modes.",
        "heading": "LDRH (register)",
        "templates": {
          "32": [
            "LDRH  <Wt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]"
          ]
        }
      },
      "LDRSB_imm": {
        "authored": "Load Register Signed Byte (immediate) loads a byte from memory, sign-extends it\nto either 32 bits or 64 bits, and writes the result to a register. The address\nthat is used for the load is calculated from a base register and an immediate\noffset. For information about memory accesses, see Load/Store addressing modes.",
        "heading": "LDRSB (immediate)",
        "templates": {
          "POST_INDEXED": [
            "LDRSB  <Wt>, [<Xn|SP>], #<simm>",
            "LDRSB  <Xt>, [<Xn|SP>], #<simm>"
          ],
          "PRE_INDEXED": [
            "LDRSB  <Wt>, [<Xn|SP>, #<simm>]!",
            "LDRSB  <Xt>, [<Xn|SP>, #<simm>]!"
          ],
          "UNSIGNED_SCALED_OFFSET": [
            "LDRSB  <Wt>, [<Xn|SP>{, #<pimm>}]",
            "LDRSB  <Xt>, [<Xn|SP>{, #<pimm>}]"
          ]
        }
      },
      "LDRSB_reg": {
        "authored": "Load Register Signed Byte (register) calculates an address from a base register\nvalue and an offset register value, loads a byte from memory, sign-extends it,\nand writes it to a register. For information about memory accesses, see\nLoad/Store addressing modes.",
        "heading": "LDRSB (register)",
        "templates": {
          "GENERAL": [
            "LDRSB  <Wt>, [<Xn|SP>, (<Wm>|<Xm>), <extend> {<amount>}]",
            "LDRSB  <Wt>, [<Xn|SP>, <Xm>{, LSL <amount>}]",
            "LDRSB  <Xt>, [<Xn|SP>, (<Wm>|<Xm>), <extend> {<amount>}]",
            "LDRSB  <Xt>, [<Xn|SP>, <Xm>{, LSL <amount>}]"
          ]
        }
      },
      "LDRSH_imm": {
        "authored": "Load Register Signed Halfword (immediate) loads a halfword from memory, sign-\nextends it to 32 bits or 64 bits, and writes the result to a register. The\naddress that is used for the load is calculated from a base register and an\nimmediate offset. For information about memory accesses, see Load/Store\naddressing modes.",
        "heading": "LDRSH (immediate)",
        "templates": {
          "POST_INDEXED": [
            "LDRSH  <Wt>, [<Xn|SP>], #<simm>",
            "LDRSH  <Xt>, [<Xn|SP>], #<simm>"
          ],
          "PRE_INDEXED": [
            "LDRSH  <Wt>, [<Xn|SP>, #<simm>]!",
            "LDRSH  <Xt>, [<Xn|SP>, #<simm>]!"
          ],
          "UNSIGNED_SCALED_OFFSET": [
            "LDRSH  <Wt>, [<Xn|SP>{, #<pimm>}]",
            "LDRSH  <Xt>, [<Xn|SP>{, #<pimm>}]"
          ]
        }
      },
      "LDRSH_reg": {
        "authored": "Load Register Signed Halfword (register) calculates an address from a base\nregister value and an offset register value, loads a halfword from memory, sign-\nextends it, and writes it to a register. For information about memory accesses\nsee Load/Store addressing modes.",
        "heading": "LDRSH (register)",
        "templates": {
          "GENERAL": [
            "LDRSH  <Wt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]",
            "LDRSH  <Xt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]"
          ]
        }
      },
      "LDRSW_imm": {
        "authored": "Load Register Signed Word (immediate) loads a word from memory, sign-extends it\nto 64 bits, and writes the result to a register. The address that is used for\nthe load is calculated from a base register and an immediate offset. For\ninformation about memory accesses, see Load/Store addressing modes.",
        "heading": "LDRSW (immediate)",
        "templates": {
          "POST_INDEXED": [
            "LDRSW  <Xt>, [<Xn|SP>], #<simm>"
          ],
          "PRE_INDEXED": [
            "LDRSW  <Xt>, [<Xn|SP>, #<simm>]!"
          ],
          "UNSIGNED_SCALED_OFFSET": [
            "LDRSW  <Xt>, [<Xn|SP>{, #<pimm>}]"
          ]
        }
      },
      "LDRSW_lit": {
        "authored": "Load Register Signed Word (literal) calculates an address from the PC value and\nan immediate offset, loads a word from memory, and writes it to a register. For\ninformation about memory accesses, see Load/Store addressing modes.",
        "heading": "LDRSW (literal)",
        "templates": {
          "LITERAL": [
            "LDRSW  <Xt>, <label>"
          ]
        }
      },
      "LDRSW_reg": {
        "authored": "Load Register Signed Word (register) calculates an address from a base register\nvalue and an offset register value, loads a word from memory, sign-extends it to\nform a 64-bit value, and writes it to a register. The offset register value can\nbe shifted left by 0 or 2 bits. For information about memory accesses, see\nLoad/Store addressing modes.",
        "heading": "LDRSW (register)",
        "templates": {
          "64": [
            "LDRSW  <Xt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]"
          ]
        }
      },
      "LDR_imm_gen": {
        "authored": "Load Register (immediate) loads a word or doubleword from memory and writes it\nto a register. The address that is used for the load is calculated from a base\nregister and an immediate offset. For information about memory accesses, see\nLoad/Store addressing modes. The Unsigned offset variant scales the immediate\noffset value by the size of the value accessed before adding it to the base\nregister value.",
        "heading": "LDR (immediate)",
        "templates": {
          "POST_INDEXED": [
            "LDR  <Wt>, [<Xn|SP>], #<simm>",
            "LDR  <Xt>, [<Xn|SP>], #<simm>"
          ],
          "PRE_INDEXED": [
            "LDR  <Wt>, [<Xn|SP>, #<simm>]!",
            "LDR  <Xt>, [<Xn|SP>, #<simm>]!"
          ],
          "UNSIGNED_SCALED_OFFSET": [
            "LDR  <Wt>, [<Xn|SP>{, #<pimm>}]",
            "LDR  <Xt>, [<Xn|SP>{, #<pimm>}]"
          ]
        }
      },
      "LDR_lit_gen": {
        "authored": "Load Register (literal) calculates an address from the PC value and an immediate\noffset, loads a word from memory, and writes it to a register. For information\nabout memory accesses, see Load/Store addressing modes.",
        "heading": "LDR (literal)",
        "templates": {
          "LITERAL": [
            "LDR  <Wt>, <label>",
            "LDR  <Xt>, <label>"
          ]
        }
      },
      "LDR_reg_gen": {
        "authored": "Load Register (register) calculates an address from a base register value and an\noffset register value, loads a word from memory, and writes it to a register.\nThe offset register value can optionally be shifted and extended. For\ninformation about memory accesses, see Load/Store addressing modes.",
        "heading": "LDR (register)",
        "templates": {
          "GENERAL": [
            "LDR  <Wt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]",
            "LDR  <Xt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]"
          ]
        }
      },
      "LDSET": {
        "authored": "Atomic bit set on word or doubleword in memory atomically loads a 32-bit word or\n64-bit doubleword from memory, performs a bitwise OR with the value held in a\nregister on it, and stores the result back to memory. The value initially loaded\nfrom memory is returned in the destination register.\n  - If the destination register is not one of WZR or XZR, LDSETA and LDSETAL\nload from memory with acquire semantics.\n  - LDSETL and LDSETAL store to memory with release semantics.\n  - LDSET has neither acquire nor release semantics.\n\nFor more information about memory ordering semantics see Load-Acquire, Store-\nRelease.\n\nFor information about memory accesses see Load/Store addressing modes.",
        "heading": "LDSET, LDSETA, LDSETAL, LDSETL",
        "templates": {
          "GENERAL": [
            "LDSET  <Ws>, <Wt>, [<Xn|SP>]",
            "LDSETA  <Ws>, <Wt>, [<Xn|SP>]",
            "LDSETAL  <Ws>, <Wt>, [<Xn|SP>]",
            "LDSETL  <Ws>, <Wt>, [<Xn|SP>]",
            "LDSET  <Xs>, <Xt>, [<Xn|SP>]",
            "LDSETA  <Xs>, <Xt>, [<Xn|SP>]",
            "LDSETAL  <Xs>, <Xt>, [<Xn|SP>]",
            "LDSETL  <Xs>, <Xt>, [<Xn|SP>]"
          ]
        }
      },
      "LDSETB": {
        "authored": "Atomic bit set on byte in memory atomically loads an 8-bit byte from memory,\nperforms a bitwise OR with the value held in a register on it, and stores the\nresult back to memory. The value initially loaded from memory is returned in the\ndestination register.\n  - If the destination register is not WZR, LDSETAB and LDSETALB load from\nmemory with acquire semantics.\n  - LDSETLB and LDSETALB store to memory with release semantics.\n  - LDSETB has neither acquire nor release semantics.\n\nFor more information about memory ordering semantics see Load-Acquire, Store-\nRelease.\n\nFor information about memory accesses see Load/Store addressing modes.",
        "heading": "LDSETB, LDSETAB, LDSETALB, LDSETLB",
        "templates": {
          "GENERAL": [
            "LDSETAB  <Ws>, <Wt>, [<Xn|SP>]",
            "LDSETALB  <Ws>, <Wt>, [<Xn|SP>]",
            "LDSETB  <Ws>, <Wt>, [<Xn|SP>]",
            "LDSETLB  <Ws>, <Wt>, [<Xn|SP>]"
          ]
        }
      },
      "LDSETH": {
        "authored": "Atomic bit set on halfword in memory atomically loads a 16-bit halfword from\nmemory, performs a bitwise OR with the value held in a register on it, and\nstores the result back to memory. The value initially loaded from memory is\nreturned in the destination register.\n  - If the destination register is not WZR, LDSETAH and LDSETALH load from\nmemory with acquire semantics.\n  - LDSETLH and LDSETALH store to memory with release semantics.\n  - LDSETH has neither acquire nor release semantics.\n\nFor more information about memory ordering semantics see Load-Acquire, Store-\nRelease.\n\nFor information about memory accesses see Load/Store addressing modes.",
        "heading": "LDSETH, LDSETAH, LDSETALH, LDSETLH",
        "templates": {
          "GENERAL": [
            "LDSETAH  <Ws>, <Wt>, [<Xn|SP>]",
            "LDSETALH  <Ws>, <Wt>, [<Xn|SP>]",
            "LDSETH  <Ws>, <Wt>, [<Xn|SP>]",
            "LDSETLH  <Ws>, <Wt>, [<Xn|SP>]"
          ]
        }
      },
      "LDSMAX": {
        "authored": "Atomic signed maximum on word or doubleword in memory atomically loads a 32-bit\nword or 64-bit doubleword from memory, compares it against the value held in a\nregister, and stores the larger value back to memory, treating the values as\nsigned numbers. The value initially loaded from memory is returned in the\ndestination register.\n  - If the destination register is not one of WZR or XZR, LDSMAXA and LDSMAXAL\nload from memory with acquire semantics.\n  - LDSMAXL and LDSMAXAL store to memory with release semantics.\n  - LDSMAX has neither acquire nor release semantics.\n\nFor more information about memory ordering semantics see Load-Acquire, Store-\nRelease.\n\nFor information about memory accesses see Load/Store addressing modes.",
        "heading": "LDSMAX, LDSMAXA, LDSMAXAL, LDSMAXL",
        "templates": {
          "GENERAL": [
            "LDSMAX  <Ws>, <Wt>, [<Xn|SP>]",
            "LDSMAXA  <Ws>, <Wt>, [<Xn|SP>]",
            "LDSMAXAL  <Ws>, <Wt>, [<Xn|SP>]",
            "LDSMAXL  <Ws>, <Wt>, [<Xn|SP>]",
            "LDSMAX  <Xs>, <Xt>, [<Xn|SP>]",
            "LDSMAXA  <Xs>, <Xt>, [<Xn|SP>]",
            "LDSMAXAL  <Xs>, <Xt>, [<Xn|SP>]",
            "LDSMAXL  <Xs>, <Xt>, [<Xn|SP>]"
          ]
        }
      },
      "LDSMAXB": {
        "authored": "Atomic signed maximum on byte in memory atomically loads an 8-bit byte from\nmemory, compares it against the value held in a register, and stores the larger\nvalue back to memory, treating the values as signed numbers. The value initially\nloaded from memory is returned in the destination register.\n  - If the destination register is not WZR, LDSMAXAB and LDSMAXALB load from\nmemory with acquire semantics.\n  - LDSMAXLB and LDSMAXALB store to memory with release semantics.\n  - LDSMAXB has neither acquire nor release semantics.\n\nFor more information about memory ordering semantics see Load-Acquire, Store-\nRelease.\n\nFor information about memory accesses see Load/Store addressing modes.",
        "heading": "LDSMAXB, LDSMAXAB, LDSMAXALB, LDSMAXLB",
        "templates": {
          "GENERAL": [
            "LDSMAXAB  <Ws>, <Wt>, [<Xn|SP>]",
            "LDSMAXALB  <Ws>, <Wt>, [<Xn|SP>]",
            "LDSMAXB  <Ws>, <Wt>, [<Xn|SP>]",
            "LDSMAXLB  <Ws>, <Wt>, [<Xn|SP>]"
          ]
        }
      },
      "LDSMAXH": {
        "authored": "Atomic signed maximum on halfword in memory atomically loads a 16-bit halfword\nfrom memory, compares it against the value held in a register, and stores the\nlarger value back to memory, treating the values as signed numbers. The value\ninitially loaded from memory is returned in the destination register.\n  - If the destination register is not WZR, LDSMAXAH and LDSMAXALH load from\nmemory with acquire semantics.\n  - LDSMAXLH and LDSMAXALH store to memory with release semantics.\n  - LDSMAXH has neither acquire nor release semantics.\n\nFor more information about memory ordering semantics see Load-Acquire, Store-\nRelease.\n\nFor information about memory accesses see Load/Store addressing modes.",
        "heading": "LDSMAXH, LDSMAXAH, LDSMAXALH, LDSMAXLH",
        "templates": {
          "GENERAL": [
            "LDSMAXAH  <Ws>, <Wt>, [<Xn|SP>]",
            "LDSMAXALH  <Ws>, <Wt>, [<Xn|SP>]",
            "LDSMAXH  <Ws>, <Wt>, [<Xn|SP>]",
            "LDSMAXLH  <Ws>, <Wt>, [<Xn|SP>]"
          ]
        }
      },
      "LDSMIN": {
        "authored": "Atomic signed minimum on word or doubleword in memory atomically loads a 32-bit\nword or 64-bit doubleword from memory, compares it against the value held in a\nregister, and stores the smaller value back to memory, treating the values as\nsigned numbers. The value initially loaded from memory is returned in the\ndestination register.\n  - If the destination register is not one of WZR or XZR, LDSMINA and LDSMINAL\nload from memory with acquire semantics.\n  - LDSMINL and LDSMINAL store to memory with release semantics.\n  - LDSMIN has neither acquire nor release semantics.\n\nFor more information about memory ordering semantics see Load-Acquire, Store-\nRelease.\n\nFor information about memory accesses see Load/Store addressing modes.",
        "heading": "LDSMIN, LDSMINA, LDSMINAL, LDSMINL",
        "templates": {
          "GENERAL": [
            "LDSMIN  <Ws>, <Wt>, [<Xn|SP>]",
            "LDSMINA  <Ws>, <Wt>, [<Xn|SP>]",
            "LDSMINAL  <Ws>, <Wt>, [<Xn|SP>]",
            "LDSMINL  <Ws>, <Wt>, [<Xn|SP>]",
            "LDSMIN  <Xs>, <Xt>, [<Xn|SP>]",
            "LDSMINA  <Xs>, <Xt>, [<Xn|SP>]",
            "LDSMINAL  <Xs>, <Xt>, [<Xn|SP>]",
            "LDSMINL  <Xs>, <Xt>, [<Xn|SP>]"
          ]
        }
      },
      "LDSMINB": {
        "authored": "Atomic signed minimum on byte in memory atomically loads an 8-bit byte from\nmemory, compares it against the value held in a register, and stores the smaller\nvalue back to memory, treating the values as signed numbers. The value initially\nloaded from memory is returned in the destination register.\n  - If the destination register is not WZR, LDSMINAB and LDSMINALB load from\nmemory with acquire semantics.\n  - LDSMINLB and LDSMINALB store to memory with release semantics.\n  - LDSMINB has neither acquire nor release semantics.\n\nFor more information about memory ordering semantics see Load-Acquire, Store-\nRelease.\n\nFor information about memory accesses see Load/Store addressing modes.",
        "heading": "LDSMINB, LDSMINAB, LDSMINALB, LDSMINLB",
        "templates": {
          "GENERAL": [
            "LDSMINAB  <Ws>, <Wt>, [<Xn|SP>]",
            "LDSMINALB  <Ws>, <Wt>, [<Xn|SP>]",
            "LDSMINB  <Ws>, <Wt>, [<Xn|SP>]",
            "LDSMINLB  <Ws>, <Wt>, [<Xn|SP>]"
          ]
        }
      },
      "LDSMINH": {
        "authored": "Atomic signed minimum on halfword in memory atomically loads a 16-bit halfword\nfrom memory, compares it against the value held in a register, and stores the\nsmaller value back to memory, treating the values as signed numbers. The value\ninitially loaded from memory is returned in the destination register.\n  - If the destination register is not WZR, LDSMINAH and LDSMINALH load from\nmemory with acquire semantics.\n  - LDSMINLH and LDSMINALH store to memory with release semantics.\n  - LDSMINH has neither acquire nor release semantics.\n\nFor more information about memory ordering semantics see Load-Acquire, Store-\nRelease.\n\nFor information about memory accesses see Load/Store addressing modes.",
        "heading": "LDSMINH, LDSMINAH, LDSMINALH, LDSMINLH",
        "templates": {
          "GENERAL": [
            "LDSMINAH  <Ws>, <Wt>, [<Xn|SP>]",
            "LDSMINALH  <Ws>, <Wt>, [<Xn|SP>]",
            "LDSMINH  <Ws>, <Wt>, [<Xn|SP>]",
            "LDSMINLH  <Ws>, <Wt>, [<Xn|SP>]"
          ]
        }
      },
      "LDTR": {
        "authored": "Load Register (unprivileged) loads a word or doubleword from memory, and writes\nit to a register. The address that is used for the load is calculated from a\nbase register and an immediate offset.\n\nMemory accesses made by the instruction behave as if the instruction was\nexecuted at EL0 if the Effective value of PSTATE.UAO is 0 and either:\n  - The instruction is executed at EL1.\n  - The instruction is executed at EL2 when the Effective value of HCR_EL2.{E2H,\nTGE} is {1, 1}.\n\nOtherwise, the memory access operates with the restrictions determined by the\nException level at which the instruction is executed. For information about\nmemory accesses, see Load/Store addressing modes.",
        "heading": "LDTR",
        "templates": {
          "BASE_PLUS_OFFSET": [
            "LDTR  <Wt>, [<Xn|SP>{, #<simm>}]",
            "LDTR  <Xt>, [<Xn|SP>{, #<simm>}]"
          ]
        }
      },
      "LDTRB": {
        "authored": "Load Register Byte (unprivileged) loads a byte from memory, zero-extends it, and\nwrites the result to a register. The address that is used for the load is\ncalculated from a base register and an immediate offset.\n\nMemory accesses made by the instruction behave as if the instruction was\nexecuted at EL0 if the Effective value of PSTATE.UAO is 0 and either:\n  - The instruction is executed at EL1.\n  - The instruction is executed at EL2 when the Effective value of HCR_EL2.{E2H,\nTGE} is {1, 1}.\n\nOtherwise, the memory access operates with the restrictions determined by the\nException level at which the instruction is executed. For information about\nmemory accesses, see Load/Store addressing modes.",
        "heading": "LDTRB",
        "templates": {
          "BASE_PLUS_OFFSET": [
            "LDTRB  <Wt>, [<Xn|SP>{, #<simm>}]"
          ]
        }
      },
      "LDTRH": {
        "authored": "Load Register Halfword (unprivileged) loads a halfword from memory, zero-extends\nit, and writes the result to a register. The address that is used for the load\nis calculated from a base register and an immediate offset.\n\nMemory accesses made by the instruction behave as if the instruction was\nexecuted at EL0 if the Effective value of PSTATE.UAO is 0 and either:\n  - The instruction is executed at EL1.\n  - The instruction is executed at EL2 when the Effective value of HCR_EL2.{E2H,\nTGE} is {1, 1}.\n\nOtherwise, the memory access operates with the restrictions determined by the\nException level at which the instruction is executed. For information about\nmemory accesses, see Load/Store addressing modes.",
        "heading": "LDTRH",
        "templates": {
          "BASE_PLUS_OFFSET": [
            "LDTRH  <Wt>, [<Xn|SP>{, #<simm>}]"
          ]
        }
      },
      "LDTRSB": {
        "authored": "Load Register Signed Byte (unprivileged) loads a byte from memory, sign-extends\nit to 32 bits or 64 bits, and writes the result to a register. The address that\nis used for the load is calculated from a base register and an immediate offset.\n\nMemory accesses made by the instruction behave as if the instruction was\nexecuted at EL0 if the Effective value of PSTATE.UAO is 0 and either:\n  - The instruction is executed at EL1.\n  - The instruction is executed at EL2 when the Effective value of HCR_EL2.{E2H,\nTGE} is {1, 1}.\n\nOtherwise, the memory access operates with the restrictions determined by the\nException level at which the instruction is executed. For information about\nmemory accesses, see Load/Store addressing modes.",
        "heading": "LDTRSB",
        "templates": {
          "BASE_PLUS_OFFSET": [
            "LDTRSB  <Wt>, [<Xn|SP>{, #<simm>}]",
            "LDTRSB  <Xt>, [<Xn|SP>{, #<simm>}]"
          ]
        }
      },
      "LDTRSH": {
        "authored": "Load Register Signed Halfword (unprivileged) loads a halfword from memory, sign-\nextends it to 32 bits or 64 bits, and writes the result to a register. The\naddress that is used for the load is calculated from a base register and an\nimmediate offset.\n\nMemory accesses made by the instruction behave as if the instruction was\nexecuted at EL0 if the Effective value of PSTATE.UAO is 0 and either:\n  - The instruction is executed at EL1.\n  - The instruction is executed at EL2 when the Effective value of HCR_EL2.{E2H,\nTGE} is {1, 1}.\n\nOtherwise, the memory access operates with the restrictions determined by the\nException level at which the instruction is executed. For information about\nmemory accesses, see Load/Store addressing modes.",
        "heading": "LDTRSH",
        "templates": {
          "BASE_PLUS_OFFSET": [
            "LDTRSH  <Wt>, [<Xn|SP>{, #<simm>}]",
            "LDTRSH  <Xt>, [<Xn|SP>{, #<simm>}]"
          ]
        }
      },
      "LDTRSW": {
        "authored": "Load Register Signed Word (unprivileged) loads a word from memory, sign-extends\nit to 64 bits, and writes the result to a register. The address that is used for\nthe load is calculated from a base register and an immediate offset.\n\nMemory accesses made by the instruction behave as if the instruction was\nexecuted at EL0 if the Effective value of PSTATE.UAO is 0 and either:\n  - The instruction is executed at EL1.\n  - The instruction is executed at EL2 when the Effective value of HCR_EL2.{E2H,\nTGE} is {1, 1}.\n\nOtherwise, the memory access operates with the restrictions determined by the\nException level at which the instruction is executed. For information about\nmemory accesses, see Load/Store addressing modes.",
        "heading": "LDTRSW",
        "templates": {
          "BASE_PLUS_OFFSET": [
            "LDTRSW  <Xt>, [<Xn|SP>{, #<simm>}]"
          ]
        }
      },
      "LDUMAX": {
        "authored": "Atomic unsigned maximum on word or doubleword in memory atomically loads a\n32-bit word or 64-bit doubleword from memory, compares it against the value held\nin a register, and stores the larger value back to memory, treating the values\nas unsigned numbers. The value initially loaded from memory is returned in the\ndestination register.\n  - If the destination register is not one of WZR or XZR, LDUMAXA and LDUMAXAL\nload from memory with acquire semantics.\n  - LDUMAXL and LDUMAXAL store to memory with release semantics.\n  - LDUMAX has neither acquire nor release semantics.\n\nFor more information about memory ordering semantics see Load-Acquire, Store-\nRelease.\n\nFor information about memory accesses see Load/Store addressing modes.",
        "heading": "LDUMAX, LDUMAXA, LDUMAXAL, LDUMAXL",
        "templates": {
          "GENERAL": [
            "LDUMAX  <Ws>, <Wt>, [<Xn|SP>]",
            "LDUMAXA  <Ws>, <Wt>, [<Xn|SP>]",
            "LDUMAXAL  <Ws>, <Wt>, [<Xn|SP>]",
            "LDUMAXL  <Ws>, <Wt>, [<Xn|SP>]",
            "LDUMAX  <Xs>, <Xt>, [<Xn|SP>]",
            "LDUMAXA  <Xs>, <Xt>, [<Xn|SP>]",
            "LDUMAXAL  <Xs>, <Xt>, [<Xn|SP>]",
            "LDUMAXL  <Xs>, <Xt>, [<Xn|SP>]"
          ]
        }
      },
      "LDUMAXB": {
        "authored": "Atomic unsigned maximum on byte in memory atomically loads an 8-bit byte from\nmemory, compares it against the value held in a register, and stores the larger\nvalue back to memory, treating the values as unsigned numbers. The value\ninitially loaded from memory is returned in the destination register.\n  - If the destination register is not WZR, LDUMAXAB and LDUMAXALB load from\nmemory with acquire semantics.\n  - LDUMAXLB and LDUMAXALB store to memory with release semantics.\n  - LDUMAXB has neither acquire nor release semantics.\n\nFor more information about memory ordering semantics see Load-Acquire, Store-\nRelease.\n\nFor information about memory accesses see Load/Store addressing modes.",
        "heading": "LDUMAXB, LDUMAXAB, LDUMAXALB, LDUMAXLB",
        "templates": {
          "GENERAL": [
            "LDUMAXAB  <Ws>, <Wt>, [<Xn|SP>]",
            "LDUMAXALB  <Ws>, <Wt>, [<Xn|SP>]",
            "LDUMAXB  <Ws>, <Wt>, [<Xn|SP>]",
            "LDUMAXLB  <Ws>, <Wt>, [<Xn|SP>]"
          ]
        }
      },
      "LDUMAXH": {
        "authored": "Atomic unsigned maximum on halfword in memory atomically loads a 16-bit halfword\nfrom memory, compares it against the value held in a register, and stores the\nlarger value back to memory, treating the values as unsigned numbers. The value\ninitially loaded from memory is returned in the destination register.\n  - If the destination register is not WZR, LDUMAXAH and LDUMAXALH load from\nmemory with acquire semantics.\n  - LDUMAXLH and LDUMAXALH store to memory with release semantics.\n  - LDUMAXH has neither acquire nor release semantics.\n\nFor more information about memory ordering semantics see Load-Acquire, Store-\nRelease.\n\nFor information about memory accesses see Load/Store addressing modes.",
        "heading": "LDUMAXH, LDUMAXAH, LDUMAXALH, LDUMAXLH",
        "templates": {
          "GENERAL": [
            "LDUMAXAH  <Ws>, <Wt>, [<Xn|SP>]",
            "LDUMAXALH  <Ws>, <Wt>, [<Xn|SP>]",
            "LDUMAXH  <Ws>, <Wt>, [<Xn|SP>]",
            "LDUMAXLH  <Ws>, <Wt>, [<Xn|SP>]"
          ]
        }
      },
      "LDUMIN": {
        "authored": "Atomic unsigned minimum on word or doubleword in memory atomically loads a\n32-bit word or 64-bit doubleword from memory, compares it against the value held\nin a register, and stores the smaller value back to memory, treating the values\nas unsigned numbers. The value initially loaded from memory is returned in the\ndestination register.\n  - If the destination register is not one of WZR or XZR, LDUMINA and LDUMINAL\nload from memory with acquire semantics.\n  - LDUMINL and LDUMINAL store to memory with release semantics.\n  - LDUMIN has neither acquire nor release semantics.\n\nFor more information about memory ordering semantics see Load-Acquire, Store-\nRelease.\n\nFor information about memory accesses see Load/Store addressing modes.",
        "heading": "LDUMIN, LDUMINA, LDUMINAL, LDUMINL",
        "templates": {
          "GENERAL": [
            "LDUMIN  <Ws>, <Wt>, [<Xn|SP>]",
            "LDUMINA  <Ws>, <Wt>, [<Xn|SP>]",
            "LDUMINAL  <Ws>, <Wt>, [<Xn|SP>]",
            "LDUMINL  <Ws>, <Wt>, [<Xn|SP>]",
            "LDUMIN  <Xs>, <Xt>, [<Xn|SP>]",
            "LDUMINA  <Xs>, <Xt>, [<Xn|SP>]",
            "LDUMINAL  <Xs>, <Xt>, [<Xn|SP>]",
            "LDUMINL  <Xs>, <Xt>, [<Xn|SP>]"
          ]
        }
      },
      "LDUMINB": {
        "authored": "Atomic unsigned minimum on byte in memory atomically loads an 8-bit byte from\nmemory, compares it against the value held in a register, and stores the smaller\nvalue back to memory, treating the values as unsigned numbers. The value\ninitially loaded from memory is returned in the destination register.\n  - If the destination register is not WZR, LDUMINAB and LDUMINALB load from\nmemory with acquire semantics.\n  - LDUMINLB and LDUMINALB store to memory with release semantics.\n  - LDUMINB has neither acquire nor release semantics.\n\nFor more information about memory ordering semantics see Load-Acquire, Store-\nRelease.\n\nFor information about memory accesses see Load/Store addressing modes.",
        "heading": "LDUMINB, LDUMINAB, LDUMINALB, LDUMINLB",
        "templates": {
          "GENERAL": [
            "LDUMINAB  <Ws>, <Wt>, [<Xn|SP>]",
            "LDUMINALB  <Ws>, <Wt>, [<Xn|SP>]",
            "LDUMINB  <Ws>, <Wt>, [<Xn|SP>]",
            "LDUMINLB  <Ws>, <Wt>, [<Xn|SP>]"
          ]
        }
      },
      "LDUMINH": {
        "authored": "Atomic unsigned minimum on halfword in memory atomically loads a 16-bit halfword\nfrom memory, compares it against the value held in a register, and stores the\nsmaller value back to memory, treating the values as unsigned numbers. The value\ninitially loaded from memory is returned in the destination register.\n  - If the destination register is not WZR, LDUMINAH and LDUMINALH load from\nmemory with acquire semantics.\n  - LDUMINLH and LDUMINALH store to memory with release semantics.\n  - LDUMINH has neither acquire nor release semantics.\n\nFor more information about memory ordering semantics see Load-Acquire, Store-\nRelease.\n\nFor information about memory accesses see Load/Store addressing modes.",
        "heading": "LDUMINH, LDUMINAH, LDUMINALH, LDUMINLH",
        "templates": {
          "GENERAL": [
            "LDUMINAH  <Ws>, <Wt>, [<Xn|SP>]",
            "LDUMINALH  <Ws>, <Wt>, [<Xn|SP>]",
            "LDUMINH  <Ws>, <Wt>, [<Xn|SP>]",
            "LDUMINLH  <Ws>, <Wt>, [<Xn|SP>]"
          ]
        }
      },
      "LDURB": {
        "authored": "Load Register Byte (unscaled) calculates an address from a base register and an\nimmediate offset, loads a byte from memory, zero-extends it, and writes it to a\nregister. For information about memory accesses, see Load/Store addressing\nmodes.",
        "heading": "LDURB",
        "templates": {
          "BASE_PLUS_OFFSET": [
            "LDURB  <Wt>, [<Xn|SP>{, #<simm>}]"
          ]
        }
      },
      "LDURH": {
        "authored": "Load Register Halfword (unscaled) calculates an address from a base register and\nan immediate offset, loads a halfword from memory, zero-extends it, and writes\nit to a register. For information about memory accesses, see Load/Store\naddressing modes.",
        "heading": "LDURH",
        "templates": {
          "BASE_PLUS_OFFSET": [
            "LDURH  <Wt>, [<Xn|SP>{, #<simm>}]"
          ]
        }
      },
      "LDURSB": {
        "authored": "Load Register Signed Byte (unscaled) calculates an address from a base register\nand an immediate offset, loads a signed byte from memory, sign-extends it, and\nwrites it to a register. For information about memory accesses, see Load/Store\naddressing modes.",
        "heading": "LDURSB",
        "templates": {
          "BASE_PLUS_OFFSET": [
            "LDURSB  <Wt>, [<Xn|SP>{, #<simm>}]",
            "LDURSB  <Xt>, [<Xn|SP>{, #<simm>}]"
          ]
        }
      },
      "LDURSH": {
        "authored": "Load Register Signed Halfword (unscaled) calculates an address from a base\nregister and an immediate offset, loads a signed halfword from memory, sign-\nextends it, and writes it to a register. For information about memory accesses,\nsee Load/Store addressing modes.",
        "heading": "LDURSH",
        "templates": {
          "BASE_PLUS_OFFSET": [
            "LDURSH  <Wt>, [<Xn|SP>{, #<simm>}]",
            "LDURSH  <Xt>, [<Xn|SP>{, #<simm>}]"
          ]
        }
      },
      "LDURSW": {
        "authored": "Load Register Signed Word (unscaled) calculates an address from a base register\nand an immediate offset, loads a signed word from memory, sign-extends it, and\nwrites it to a register. For information about memory accesses, see Load/Store\naddressing modes.",
        "heading": "LDURSW",
        "templates": {
          "BASE_PLUS_OFFSET": [
            "LDURSW  <Xt>, [<Xn|SP>{, #<simm>}]"
          ]
        }
      },
      "LDUR_gen": {
        "authored": "Load Register (unscaled) calculates an address from a base register and an\nimmediate offset, loads a 32-bit word or 64-bit doubleword from memory, zero-\nextends it, and writes it to a register. For information about memory accesses,\nsee Load/Store addressing modes.",
        "heading": "LDUR",
        "templates": {
          "BASE_PLUS_OFFSET": [
            "LDUR  <Wt>, [<Xn|SP>{, #<simm>}]",
            "LDUR  <Xt>, [<Xn|SP>{, #<simm>}]"
          ]
        }
      },
      "LDXP": {
        "authored": "Load Exclusive Pair of Registers derives an address from a base register value,\nloads two 32-bit words or two 64-bit doublewords from memory, and writes them to\ntwo registers. A 32-bit pair requires the address to be doubleword aligned and\nis single-copy atomic at doubleword granularity. A 64-bit pair requires the\naddress to be quadword aligned and is single-copy atomic for each doubleword at\ndoubleword granularity. The PE marks the physical address being accessed as an\nexclusive access. This exclusive access mark is checked by Store Exclusive\ninstructions. See Synchronization and semaphores. For information about memory\naccesses see Load/Store addressing modes.",
        "heading": "LDXP",
        "templates": {
          "BASE_REGISTER": [
            "LDXP  <Wt1>, <Wt2>, [<Xn|SP>{,#0}]",
            "LDXP  <Xt1>, <Xt2>, [<Xn|SP>{,#0}]"
          ]
        }
      },
      "LDXR": {
        "authored": "Load Exclusive Register derives an address from a base register value, loads a\n32-bit word or a 64-bit doubleword from memory, and writes it to a register. The\nmemory access is atomic. The PE marks the physical address being accessed as an\nexclusive access. This exclusive access mark is checked by Store Exclusive\ninstructions. See Synchronization and semaphores. For information about memory\naccesses see Load/Store addressing modes.",
        "heading": "LDXR",
        "templates": {
          "BASE_REGISTER": [
            "LDXR  <Wt>, [<Xn|SP>{,#0}]",
            "LDXR  <Xt>, [<Xn|SP>{,#0}]"
          ]
        }
      },
      "LDXRB": {
        "authored": "Load Exclusive Register Byte derives an address from a base register value,\nloads a byte from memory, zero-extends it and writes it to a register. The\nmemory access is atomic. The PE marks the physical address being accessed as an\nexclusive access. This exclusive access mark is checked by Store Exclusive\ninstructions. See Synchronization and semaphores. For information about memory\naccesses see Load/Store addressing modes.",
        "heading": "LDXRB",
        "templates": {
          "BASE_REGISTER": [
            "LDXRB  <Wt>, [<Xn|SP>{,#0}]"
          ]
        }
      },
      "LDXRH": {
        "authored": "Load Exclusive Register Halfword derives an address from a base register value,\nloads a halfword from memory, zero-extends it and writes it to a register. The\nmemory access is atomic. The PE marks the physical address being accessed as an\nexclusive access. This exclusive access mark is checked by Store Exclusive\ninstructions. See Synchronization and semaphores. For information about memory\naccesses see Load/Store addressing modes.",
        "heading": "LDXRH",
        "templates": {
          "BASE_REGISTER": [
            "LDXRH  <Wt>, [<Xn|SP>{,#0}]"
          ]
        }
      },
      "LSLV": {
        "authored": "Logical Shift Left Variable shifts a register value left by a variable number of\nbits, shifting in zeros, and writes the result to the destination register. The\nremainder obtained by dividing the second source register by the data size\ndefines the number of bits by which the first source register is left-shifted.",
        "heading": "LSLV",
        "templates": {
          "GENERAL": [
            "LSLV  <Wd>, <Wn>, <Wm>",
            "LSLV  <Xd>, <Xn>, <Xm>"
          ]
        }
      },
      "LSL_LSLV": {
        "authored": "Logical Shift Left (register) shifts a register value left by a variable number\nof bits, shifting in zeros, and writes the result to the destination register.\nThe remainder obtained by dividing the second source register by the data size\ndefines the number of bits by which the first source register is left-shifted.",
        "heading": "LSL (register)",
        "templates": {
          "GENERAL": [
            "LSL  <Wd>, <Wn>, <Wm>",
            "LSL  <Xd>, <Xn>, <Xm>"
          ]
        }
      },
      "LSL_UBFM": {
        "authored": "Logical Shift Left (immediate) shifts a register value left by an immediate\nnumber of bits, shifting in zeros, and writes the result to the destination\nregister.",
        "heading": "LSL (immediate)",
        "templates": {
          "ZERO_FILL": [
            "LSL  <Wd>, <Wn>, #<shift>",
            "LSL  <Xd>, <Xn>, #<shift>"
          ]
        }
      },
      "LSRV": {
        "authored": "Logical Shift Right Variable shifts a register value right by a variable number\nof bits, shifting in zeros, and writes the result to the destination register.\nThe remainder obtained by dividing the second source register by the data size\ndefines the number of bits by which the first source register is right-shifted.",
        "heading": "LSRV",
        "templates": {
          "GENERAL": [
            "LSRV  <Wd>, <Wn>, <Wm>",
            "LSRV  <Xd>, <Xn>, <Xm>"
          ]
        }
      },
      "LSR_LSRV": {
        "authored": "Logical Shift Right (register) shifts a register value right by a variable\nnumber of bits, shifting in zeros, and writes the result to the destination\nregister. The remainder obtained by dividing the second source register by the\ndata size defines the number of bits by which the first source register is\nright-shifted.",
        "heading": "LSR (register)",
        "templates": {
          "GENERAL": [
            "LSR  <Wd>, <Wn>, <Wm>",
            "LSR  <Xd>, <Xn>, <Xm>"
          ]
        }
      },
      "LSR_UBFM": {
        "authored": "Logical Shift Right (immediate) shifts a register value right by an immediate\nnumber of bits, shifting in zeros, and writes the result to the destination\nregister.",
        "heading": "LSR (immediate)",
        "templates": {
          "ZERO_FILL": [
            "LSR  <Wd>, <Wn>, #<shift>",
            "LSR  <Xd>, <Xn>, #<shift>"
          ]
        }
      },
      "MADD": {
        "authored": "Multiply-Add multiplies two register values, adds a third register value, and\nwrites the result to the destination register.",
        "heading": "MADD",
        "templates": {
          "GENERAL": [
            "MADD  <Wd>, <Wn>, <Wm>, <Wa>",
            "MADD  <Xd>, <Xn>, <Xm>, <Xa>"
          ]
        }
      },
      "MNEG_MSUB": {
        "authored": "Multiply-Negate multiplies two register values, negates the product, and writes\nthe result to the destination register.",
        "heading": "MNEG",
        "templates": {
          "GENERAL": [
            "MNEG  <Wd>, <Wn>, <Wm>",
            "MNEG  <Xd>, <Xn>, <Xm>"
          ]
        }
      },
      "MOVK": {
        "authored": "Move wide with keep moves an optionally-shifted 16-bit immediate value into a\nregister, keeping other bits unchanged.",
        "heading": "MOVK",
        "templates": {
          "IMM18_PACKED": [
            "MOVK  <Wd>, #<imm>{, LSL #<shift>}",
            "MOVK  <Xd>, #<imm>{, LSL #<shift>}"
          ]
        }
      },
      "MOVN": {
        "authored": "Move wide with NOT moves the inverse of an optionally-shifted 16-bit immediate\nvalue to a register.",
        "heading": "MOVN",
        "templates": {
          "IMM18_PACKED": [
            "MOVN  <Wd>, #<imm>{, LSL #<shift>}",
            "MOVN  <Xd>, #<imm>{, LSL #<shift>}"
          ]
        }
      },
      "MOVZ": {
        "authored": "Move wide with zero moves an optionally-shifted 16-bit immediate value to a\nregister.",
        "heading": "MOVZ",
        "templates": {
          "IMM18_PACKED": [
            "MOVZ  <Wd>, #<imm>{, LSL #<shift>}",
            "MOVZ  <Xd>, #<imm>{, LSL #<shift>}"
          ]
        }
      },
      "MOV_ADD_addsub_imm": {
        "authored": null,
        "heading": "MOV (to/from SP)",
        "templates": {
          "NO_S": [
            "MOV  <Wd|WSP>, <Wn|WSP>",
            "MOV  <Xd|SP>, <Xn|SP>"
          ]
        }
      },
      "MOV_MOVN": {
        "authored": "Move (inverted wide immediate) moves an inverted 16-bit immediate value to a\nregister.",
        "heading": "MOV (inverted wide immediate)",
        "templates": {
          "IMM18_PACKED": [
            "MOV  <Wd>, #<imm>",
            "MOV  <Xd>, #<imm>"
          ]
        }
      },
      "MOV_MOVZ": {
        "authored": "Move (wide immediate) moves a 16-bit immediate value to a register.",
        "heading": "MOV (wide immediate)",
        "templates": {
          "IMM18_PACKED": [
            "MOV  <Wd>, #<imm>",
            "MOV  <Xd>, #<imm>"
          ]
        }
      },
      "MOV_ORR_log_imm": {
        "authored": "Move (bitmask immediate) writes a bitmask immediate value to a register.",
        "heading": "MOV (bitmask immediate)",
        "templates": {
          "NO_S": [
            "MOV  <Wd|WSP>, #<imm>",
            "MOV  <Xd|SP>, #<imm>"
          ]
        }
      },
      "MOV_ORR_log_shift": {
        "authored": "Move (register) copies the value in a source register to the destination\nregister.",
        "heading": "MOV (register)",
        "templates": {
          "NO_S": [
            "MOV  <Wd>, <Wm>",
            "MOV  <Xd>, <Xm>"
          ]
        }
      },
      "MRS": {
        "authored": "Move System Register allows the PE to read an AArch64 System register into a\ngeneral-purpose register.",
        "heading": "MRS",
        "templates": {
          "SYSTEM": [
            "MRS  <Xt>, (<systemreg>|S<op0>_<op1>_<Cn>_<Cm>_<op2>)"
          ]
        }
      },
      "MSR_imm": {
        "authored": "Move immediate value to Special Register moves an immediate value to selected\nbits of the PSTATE. For more information, see Process state, PSTATE.\n\nThe bits that can be written by this instruction are:\n  - PSTATE.D, PSTATE.A, PSTATE.I, PSTATE.F, and PSTATE.SP.\n  - If FEAT_SSBS is implemented, PSTATE.SSBS.\n  - If FEAT_PAN is implemented, PSTATE.PAN.\n  - If FEAT_UAO is implemented, PSTATE.UAO.\n  - If FEAT_DIT is implemented, PSTATE.DIT.\n  - If FEAT_MTE is implemented, PSTATE.TCO.",
        "heading": "MSR (immediate)",
        "templates": {
          "SYSTEM": [
            "MSR  <pstatefield>, #<imm>"
          ]
        }
      },
      "MSR_reg": {
        "authored": "Move general-purpose register to System Register allows the PE to write an\nAArch64 System register from a general-purpose register.",
        "heading": "MSR (register)",
        "templates": {
          "SYSTEM": [
            "MSR  (<systemreg>|S<op0>_<op1>_<Cn>_<Cm>_<op2>), <Xt>"
          ]
        }
      },
      "MSUB": {
        "authored": "Multiply-Subtract multiplies two register values, subtracts the product from a\nthird register value, and writes the result to the destination register.",
        "heading": "MSUB",
        "templates": {
          "GENERAL": [
            "MSUB  <Wd>, <Wn>, <Wm>, <Wa>",
            "MSUB  <Xd>, <Xn>, <Xm>, <Xa>"
          ]
        }
      },
      "MUL_MADD": {
        "authored": null,
        "heading": "MUL",
        "templates": {
          "GENERAL": [
            "MUL  <Wd>, <Wn>, <Wm>",
            "MUL  <Xd>, <Xn>, <Xm>"
          ]
        }
      },
      "MVN_ORN_log_shift": {
        "authored": "Bitwise NOT writes the bitwise inverse of a register value to the destination\nregister.",
        "heading": "MVN",
        "templates": {
          "NO_S": [
            "MVN  <Wd>, <Wm>{, <shift> #<amount>}",
            "MVN  <Xd>, <Xm>{, <shift> #<amount>}"
          ]
        }
      },
      "NEGS_SUBS_addsub_shift": {
        "authored": "Negate, setting flags, negates an optionally-shifted register value, and writes\nthe result to the destination register. It updates the condition flags based on\nthe result.",
        "heading": "NEGS",
        "templates": {
          "S": [
            "NEGS  <Wd>, <Wm>{, <shift> #<amount>}",
            "NEGS  <Xd>, <Xm>{, <shift> #<amount>}"
          ]
        }
      },
      "NEG_SUB_addsub_shift": {
        "authored": "Negate (shifted register) negates an optionally-shifted register value, and\nwrites the result to the destination register.",
        "heading": "NEG (shifted register)",
        "templates": {
          "NO_S": [
            "NEG  <Wd>, <Wm>{, <shift> #<amount>}",
            "NEG  <Xd>, <Xm>{, <shift> #<amount>}"
          ]
        }
      },
      "NGCS_SBCS": {
        "authored": "Negate with Carry, setting flags, negates the sum of a register value and the\nvalue of NOT (Carry flag), and writes the result to the destination register. It\nupdates the condition flags based on the result.",
        "heading": "NGCS",
        "templates": {
          "S": [
            "NGCS  <Wd>, <Wm>",
            "NGCS  <Xd>, <Xm>"
          ]
        }
      },
      "NGC_SBC": {
        "authored": "Negate with Carry negates the sum of a register value and the value of NOT\n(Carry flag), and writes the result to the destination register.",
        "heading": "NGC",
        "templates": {
          "NO_S": [
            "NGC  <Wd>, <Wm>",
            "NGC  <Xd>, <Xm>"
          ]
        }
      },
      "NOP": {
        "authored": "No Operation does nothing, other than advance the value of the program counter\nby 4. This instruction can be used for instruction alignment purposes.\n\nThe timing effects of including a NOP instruction in a program are not\nguaranteed. It can increase execution time, leave it unchanged, or even reduce\nit. Therefore, NOP instructions are not suitable for timing loops.",
        "heading": "NOP",
        "templates": {
          "SYSTEM": [
            "NOP"
          ]
        }
      },
      "ORN_log_shift": {
        "authored": "Bitwise OR NOT (shifted register) performs a bitwise (inclusive) OR of a\nregister value and the complement of an optionally-shifted register value, and\nwrites the result to the destination register.",
        "heading": "ORN (shifted register)",
        "templates": {
          "NO_S": [
            "ORN  <Wd>, <Wn>, <Wm>{, <shift> #<amount>}",
            "ORN  <Xd>, <Xn>, <Xm>{, <shift> #<amount>}"
          ]
        }
      },
      "ORR_log_imm": {
        "authored": "Bitwise OR (immediate) performs a bitwise (inclusive) OR of a register value and\nan immediate register value, and writes the result to the destination register.",
        "heading": "ORR (immediate)",
        "templates": {
          "NO_S": [
            "ORR  <Wd|WSP>, <Wn>, #<imm>",
            "ORR  <Xd|SP>, <Xn>, #<imm>"
          ]
        }
      },
      "ORR_log_shift": {
        "authored": "Bitwise OR (shifted register) performs a bitwise (inclusive) OR of a register\nvalue and an optionally-shifted register value, and writes the result to the\ndestination register.",
        "heading": "ORR (shifted register)",
        "templates": {
          "NO_S": [
            "ORR  <Wd>, <Wn>, <Wm>{, <shift> #<amount>}",
            "ORR  <Xd>, <Xn>, <Xm>{, <shift> #<amount>}"
          ]
        }
      },
      "PACDA": {
        "authored": "Pointer Authentication Code for Data address, using key A. This instruction\ncomputes and inserts a pointer authentication code for a data address, using a\nmodifier and key A.\n\nThe address is in the general-purpose register that is specified by <Xd>.\n\nThe modifier is:\n  - In the general-purpose register or stack pointer that is specified by\n<Xn|SP> for PACDA.\n  - The value zero, for PACDZA.",
        "heading": "PACDA, PACDZA",
        "templates": {
          "GENERAL": [
            "PACDA  <Xd>, <Xn|SP>",
            "PACDZA  <Xd>"
          ]
        }
      },
      "PACDB": {
        "authored": "Pointer Authentication Code for Data address, using key B. This instruction\ncomputes and inserts a pointer authentication code for a data address, using a\nmodifier and key B.\n\nThe address is in the general-purpose register that is specified by <Xd>.\n\nThe modifier is:\n  - In the general-purpose register or stack pointer that is specified by\n<Xn|SP> for PACDB.\n  - The value zero, for PACDZB.",
        "heading": "PACDB, PACDZB",
        "templates": {
          "GENERAL": [
            "PACDB  <Xd>, <Xn|SP>",
            "PACDZB  <Xd>"
          ]
        }
      },
      "PACGA": {
        "authored": "Pointer Authentication Code, using Generic key. This instruction computes the\npointer authentication code for an address in the first source register, using a\nmodifier in the second source register, and the Generic key. The computed\npointer authentication code is returned in the upper 32 bits of the destination\nregister.",
        "heading": "PACGA",
        "templates": {
          "GENERAL": [
            "PACGA  <Xd>, <Xn>, <Xm|SP>"
          ]
        }
      },
      "PACIA": {
        "authored": "Pointer Authentication Code for Instruction address, using key A. This\ninstruction computes and inserts a pointer authentication code for an\ninstruction address, using a modifier and key A.\n\nThe address is:\n  - In the general-purpose register that is specified by <Xd> for PACIA and\nPACIZA.\n  - In X17, for PACIA1716.\n  - In X30, for PACIASP and PACIAZ.\n\nThe modifier is:\n  - In the general-purpose register or stack pointer that is specified by\n<Xn|SP> for PACIA.\n  - The value zero, for PACIZA and PACIAZ.\n  - In X16, for PACIA1716.\n  - In SP, for PACIASP.",
        "heading": "PACIA, PACIA1716, PACIASP, PACIAZ, PACIZA",
        "templates": {
          "GENERAL": [
            "PACIA  <Xd>, <Xn|SP>",
            "PACIZA  <Xd>"
          ],
          "SYSTEM": [
            "PACIA1716",
            "PACIASP",
            "PACIAZ"
          ]
        }
      },
      "PACIB": {
        "authored": "Pointer Authentication Code for Instruction address, using key B. This\ninstruction computes and inserts a pointer authentication code for an\ninstruction address, using a modifier and key B.\n\nThe address is:\n  - In the general-purpose register that is specified by <Xd> for PACIB and\nPACIZB.\n  - In X17, for PACIB1716.\n  - In X30, for PACIBSP and PACIBZ.\n\nThe modifier is:\n  - In the general-purpose register or stack pointer that is specified by\n<Xn|SP> for PACIB.\n  - The value zero, for PACIZB and PACIBZ.\n  - In X16, for PACIB1716.\n  - In SP, for PACIBSP.",
        "heading": "PACIB, PACIB1716, PACIBSP, PACIBZ, PACIZB",
        "templates": {
          "GENERAL": [
            "PACIB  <Xd>, <Xn|SP>",
            "PACIZB  <Xd>"
          ],
          "SYSTEM": [
            "PACIB1716",
            "PACIBSP",
            "PACIBZ"
          ]
        }
      },
      "PRFM_imm": {
        "authored": "Prefetch Memory (immediate) signals the memory system that data memory accesses\nfrom a specified address are likely to occur in the near future. The memory\nsystem can respond by taking actions that are expected to speed up the memory\naccesses when they do occur, such as preloading the cache line containing the\nspecified address into one or more caches.\n\nThe effect of an PRFM instruction is implementation defined. For more\ninformation, see Prefetch memory.\n\nFor information about memory accesses, see Load/Store addressing modes.",
        "heading": "PRFM (immediate)",
        "templates": {
          "UNSIGNED_SCALED_OFFSET": [
            "PRFM  (<prfop>|#<imm5>), [<Xn|SP>{, #<pimm>}]"
          ]
        }
      },
      "PRFM_lit": {
        "authored": "Prefetch Memory (literal) signals the memory system that data memory accesses\nfrom a specified address are likely to occur in the near future. The memory\nsystem can respond by taking actions that are expected to speed up the memory\naccesses when they do occur, such as preloading the cache line containing the\nspecified address into one or more caches.\n\nThe effect of an PRFM instruction is implementation defined. For more\ninformation, see Prefetch memory.\n\nFor information about memory accesses, see Load/Store addressing modes.",
        "heading": "PRFM (literal)",
        "templates": {
          "LITERAL": [
            "PRFM  (<prfop>|#<imm5>), <label>"
          ]
        }
      },
      "PRFM_reg": {
        "authored": "Prefetch Memory (register) signals the memory system that data memory accesses\nfrom a specified address are likely to occur in the near future. The memory\nsystem can respond by taking actions that are expected to speed up the memory\naccesses when they do occur, such as preloading the cache line containing the\nspecified address into one or more caches.\n\nThe effect of an PRFM instruction is implementation defined. For more\ninformation, see Prefetch memory.\n\nFor information about memory accesses, see Load/Store addressing modes.",
        "heading": "PRFM (register)",
        "templates": {
          "GENERAL": [
            "PRFM  (<prfop>|#<imm5>), [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]"
          ]
        }
      },
      "PRFUM": {
        "authored": "Prefetch Memory (unscaled offset) signals the memory system that data memory\naccesses from a specified address are likely to occur in the near future. The\nmemory system can respond by taking actions that are expected to speed up the\nmemory accesses when they do occur, such as preloading the cache line containing\nthe specified address into one or more caches.\n\nThe effect of an PRFUM instruction is implementation defined. For more\ninformation, see Prefetch memory.\n\nFor information about memory accesses, see Load/Store addressing modes.",
        "heading": "PRFUM",
        "templates": {
          "BASE_PLUS_OFFSET": [
            "PRFUM (<prfop>|#<imm5>), [<Xn|SP>{, #<simm>}]"
          ]
        }
      },
      "PSB": {
        "authored": "Profiling Synchronization Barrier. This instruction is a barrier that ensures\nthat all existing profiling data for the current PE has been formatted, and\nprofiling buffer addresses have been translated such that all writes to the\nprofiling buffer have been initiated.  A following DSB instruction completes\nwhen the writes to the profiling buffer have completed.\n\nIf the Statistical Profiling Extension is not implemented, this instruction\nexecutes as a NOP.",
        "heading": "PSB CSYNC",
        "templates": {
          "SYSTEM": [
            "PSB CSYNC"
          ]
        }
      },
      "PSSBB": {
        "authored": "Physical Speculative Store Bypass Barrier is a memory barrier which prevents\nspeculative loads from bypassing earlier stores to the same physical address.\n\nThe semantics of the Physical Speculative Store Bypass Barrier are:\n  - When a load to a location appears in program order after the PSSBB, then the\nload does not speculatively read an entry earlier in the coherence order for\nthat location than the entry generated by the latest store satisfying all of the\nfollowing conditions:\n    - The store is to the same location as the load.\n    - The store appears in program order before the PSSBB.\n  - When a load to a location appears in program order before the PSSBB, then\nthe load does not speculatively read data from any store satisfying all of the\nfollowing conditions:\n    - The store is to the same location as the load.\n    - The store appears in program order after the PSSBB.",
        "heading": "PSSBB",
        "templates": {
          "SYSTEM": [
            "PSSBB"
          ]
        }
      },
      "RBIT_int": {
        "authored": "Reverse Bits reverses the bit order in a register.",
        "heading": "RBIT",
        "templates": {
          "GENERAL": [
            "RBIT  <Wd>, <Wn>",
            "RBIT  <Xd>, <Xn>"
          ]
        }
      },
      "RET": {
        "authored": "Return from subroutine branches unconditionally to an address in a register,\nwith a hint that this is a subroutine return.",
        "heading": "RET",
        "templates": {
          "GENERAL": [
            "RET  {<Xn>}"
          ]
        }
      },
      "RETA": {
        "authored": "Return from subroutine, with pointer authentication. This instruction\nauthenticates the address that is held in LR, using SP as the modifier and the\nspecified key, branches to the authenticated address, with a hint that this\ninstruction is a subroutine return.\n\nKey A is used for RETAA, and key B is used for RETAB.\n\nIf the authentication passes, the PE continues execution at the target of the\nbranch. If the authentication fails, a Translation fault is generated.\n\nThe authenticated address is not written back to LR.",
        "heading": "RETAA, RETAB",
        "templates": {
          "GENERAL": [
            "RETAA",
            "RETAB"
          ]
        }
      },
      "REV": {
        "authored": "Reverse Bytes reverses the byte order in a register.",
        "heading": "REV",
        "templates": {
          "GENERAL": [
            "REV  <Wd>, <Wn>",
            "REV  <Xd>, <Xn>"
          ]
        }
      },
      "REV16_int": {
        "authored": "Reverse bytes in 16-bit halfwords reverses the byte order in each 16-bit\nhalfword of a register.",
        "heading": "REV16",
        "templates": {
          "GENERAL": [
            "REV16  <Wd>, <Wn>",
            "REV16  <Xd>, <Xn>"
          ]
        }
      },
      "REV32_int": {
        "authored": "Reverse bytes in 32-bit words reverses the byte order in each 32-bit word of a\nregister.",
        "heading": "REV32",
        "templates": {
          "64": [
            "REV32  <Xd>, <Xn>"
          ]
        }
      },
      "REV64_REV": {
        "authored": "Reverse Bytes reverses the byte order in a 64-bit general-purpose register.\n\nWhen assembling for Armv8.2, an assembler must support this pseudo-instruction.\nIt is optional whether an assembler supports this pseudo-instruction when\nassembling for an architecture earlier than Armv8.2.",
        "heading": "REV64",
        "templates": {
          "GENERAL": [
            "REV64  <Xd>, <Xn>"
          ]
        }
      },
      "RMIF": {
        "authored": "Performs a rotation right of a value held in a general purpose register by an\nimmediate value, and then inserts a selection of the bottom four bits of the\nresult of the rotation into the PSTATE flags, under the control of a second\nimmediate mask.",
        "heading": "RMIF",
        "templates": {
          "GENERAL": [
            "RMIF  <Xn>, #<shift>, #<mask>"
          ]
        }
      },
      "RORV": {
        "authored": "Rotate Right Variable provides the value of the contents of a register rotated\nby a variable number of bits. The bits that are rotated off the right end are\ninserted into the vacated bit positions on the left. The remainder obtained by\ndividing the second source register by the data size defines the number of bits\nby which the first source register is right-shifted.",
        "heading": "RORV",
        "templates": {
          "GENERAL": [
            "RORV  <Wd>, <Wn>, <Wm>",
            "RORV  <Xd>, <Xn>, <Xm>"
          ]
        }
      },
      "ROR_EXTR": {
        "authored": "Rotate right (immediate) provides the value of the contents of a register\nrotated by a variable number of bits. The bits that are rotated off the right\nend are inserted into the vacated bit positions on the left.",
        "heading": "ROR (immediate)",
        "templates": {
          "GENERAL": [
            "ROR  <Wd>, <Ws>, #<shift>",
            "ROR  <Xd>, <Xs>, #<shift>"
          ]
        }
      },
      "ROR_RORV": {
        "authored": "Rotate Right (register) provides the value of the contents of a register rotated\nby a variable number of bits. The bits that are rotated off the right end are\ninserted into the vacated bit positions on the left. The remainder obtained by\ndividing the second source register by the data size defines the number of bits\nby which the first source register is right-shifted.",
        "heading": "ROR (register)",
        "templates": {
          "GENERAL": [
            "ROR  <Wd>, <Wn>, <Wm>",
            "ROR  <Xd>, <Xn>, <Xm>"
          ]
        }
      },
      "SB": {
        "authored": "Speculation Barrier is a barrier that controls speculation.\n\nThe semantics of the Speculation Barrier are that the execution, until the\nbarrier completes, of any instruction that appears later in the program order\nthan the barrier:\n  - Cannot be performed speculatively to the extent that such speculation can be\nobserved through side-channels as a result of control flow speculation or data\nvalue speculation.\n  - Can be speculatively executed as a result of predicting that a potentially\nexception generating instruction has not generated an exception.\n\nIn particular, any instruction that appears later in the program order than the\nbarrier cannot cause a speculative allocation into any caching structure where\nthe allocation of that entry could be indicative of any data value present in\nmemory or in the registers.\n\nThe SB instruction:\n  - Cannot be speculatively executed as a result of control flow speculation or\ndata value speculation.\n  - Can be speculatively executed as a result of predicting that a potentially\nexception generating instruction has not generated an exception. The potentially\nexception generating instruction can complete once it is known not to be\nspeculative, and all data values generated by instructions appearing in program\norder before the SB instruction have their predicted values confirmed.\n\nWhen the prediction of the instruction stream is not informed by data taken from\nthe register outputs of the speculative execution of instructions appearing in\nprogram order after an uncompleted SB instruction, the SB instruction has no\neffect on the use of prediction resources to predict the instruction stream that\nis being fetched.",
        "heading": "SB",
        "templates": {
          "SYSTEM": [
            "SB"
          ]
        }
      },
      "SBC": {
        "authored": "Subtract with Carry subtracts a register value and the value of NOT (Carry flag)\nfrom a register value, and writes the result to the destination register.",
        "heading": "SBC",
        "templates": {
          "NO_S": [
            "SBC  <Wd>, <Wn>, <Wm>",
            "SBC  <Xd>, <Xn>, <Xm>"
          ]
        }
      },
      "SBCS": {
        "authored": "Subtract with Carry, setting flags, subtracts a register value and the value of\nNOT (Carry flag) from a register value, and writes the result to the destination\nregister. It updates the condition flags based on the result.",
        "heading": "SBCS",
        "templates": {
          "S": [
            "SBCS  <Wd>, <Wn>, <Wm>",
            "SBCS  <Xd>, <Xn>, <Xm>"
          ]
        }
      },
      "SBFIZ_SBFM": {
        "authored": "Signed Bitfield Insert in Zeros copies a bitfield of <width> bits from the least\nsignificant bits of the source register to bit position <lsb> of the destination\nregister, setting the destination bits below the bitfield to zero, and the bits\nabove the bitfield to a copy of the most significant bit of the bitfield.",
        "heading": "SBFIZ",
        "templates": {
          "SIGNED_FILL": [
            "SBFIZ  <Wd>, <Wn>, #<lsb>, #<width>",
            "SBFIZ  <Xd>, <Xn>, #<lsb>, #<width>"
          ]
        }
      },
      "SBFM": {
        "authored": "Signed Bitfield Move is usually accessed via one of its aliases, which are\nalways preferred for disassembly.\n\nIf <imms> is greater than or equal to <immr>, this copies a bitfield of\n(<imms>-<immr>+1) bits starting from bit position <immr> in the source register\nto the least significant bits of the destination register.\n\nIf <imms> is less than <immr>, this copies a bitfield of (<imms>+1) bits from\nthe least significant bits of the source register to bit position\n(regsize-<immr>) of the destination register, where regsize is the destination\nregister size of 32 or 64 bits.\n\nIn both cases the destination bits below the bitfield are set to zero, and the\nbits above the bitfield are set to a copy of the most significant bit of the\nbitfield.",
        "heading": "SBFM",
        "templates": {
          "SIGNED_FILL": [
            "SBFM  <Wd>, <Wn>, #<immr>, #<imms>",
            "SBFM  <Xd>, <Xn>, #<immr>, #<imms>"
          ]
        }
      },
      "SBFX_SBFM": {
        "authored": "Signed Bitfield Extract copies a bitfield of <width> bits starting from bit\nposition <lsb> in the source register to the least significant bits of the\ndestination register, and sets destination bits above the bitfield to a copy of\nthe most significant bit of the bitfield.",
        "heading": "SBFX",
        "templates": {
          "SIGNED_FILL": [
            "SBFX  <Wd>, <Wn>, #<lsb>, #<width>",
            "SBFX  <Xd>, <Xn>, #<lsb>, #<width>"
          ]
        }
      },
      "SDIV": {
        "authored": "Signed Divide divides a signed integer register value by another signed integer\nregister value, and writes the result to the destination register. The condition\nflags are not affected.",
        "heading": "SDIV",
        "templates": {
          "GENERAL": [
            "SDIV  <Wd>, <Wn>, <Wm>",
            "SDIV  <Xd>, <Xn>, <Xm>"
          ]
        }
      },
      "SETF": {
        "authored": "Set the PSTATE.NZV flags based on the value in the specified general-purpose\nregister. SETF8 treats the value as an 8 bit value, and SETF16 treats the value\nas an 16 bit value.\n\nThe PSTATE.C flag is not affected by these instructions.",
        "heading": "SETF8, SETF16",
        "templates": {
          "GENERAL": [
            "SETF8  <Wn>",
            "SETF16  <Wn>"
          ]
        }
      },
      "SEV": {
        "authored": "Send Event is a hint instruction. It causes an event to be signaled to all PEs\nin the multiprocessor system. For more information, see Wait for Event mechanism\nand Send event.",
        "heading": "SEV",
        "templates": {
          "SYSTEM": [
            "SEV"
          ]
        }
      },
      "SEVL": {
        "authored": "Send Event Local is a hint instruction that causes an event to be signaled\nlocally without requiring the event to be signaled to other PEs in the\nmultiprocessor system. It can prime a wait-loop which starts with a WFE\ninstruction.",
        "heading": "SEVL",
        "templates": {
          "SYSTEM": [
            "SEVL"
          ]
        }
      },
      "SMADDL": {
        "authored": "Signed Multiply-Add Long multiplies two 32-bit register values, adds a 64-bit\nregister value, and writes the result to the 64-bit destination register.",
        "heading": "SMADDL",
        "templates": {
          "64": [
            "SMADDL  <Xd>, <Wn>, <Wm>, <Xa>"
          ]
        }
      },
      "SMC": {
        "authored": "Secure Monitor Call causes an exception to EL3.\n\nSMC is available only for software executing at EL1 or higher. It is undefined\nin EL0.\n\nIf the values of HCR_EL2.TSC and SCR_EL3.SMD are both 0, execution of an SMC\ninstruction at EL1 or higher generates a Secure Monitor Call exception,\nrecording it in ESR_ELx, using the EC value 0x17, that is taken to EL3.\n\nIf the value of HCR_EL2.TSC is 1 and EL2 is enabled in the current Security\nstate, execution of an SMC instruction at EL1 generates an exception that is\ntaken to EL2, regardless of the value of SCR_EL3.SMD. For more information, see\nTraps to EL2 of Non-secure EL1 execution of SMC instructions.\n\nIf the value of HCR_EL2.TSC is 0 and the value of SCR_EL3.SMD is 1, the SMC\ninstruction is undefined.",
        "heading": "SMC",
        "templates": {
          "SYSTEM": [
            "SMC  #<imm>"
          ]
        }
      },
      "SMNEGL_SMSUBL": {
        "authored": "Signed Multiply-Negate Long multiplies two 32-bit register values, negates the\nproduct, and writes the result to the 64-bit destination register.",
        "heading": "SMNEGL",
        "templates": {
          "64": [
            "SMNEGL  <Xd>, <Wn>, <Wm>"
          ]
        }
      },
      "SMSUBL": {
        "authored": "Signed Multiply-Subtract Long multiplies two 32-bit register values, subtracts\nthe product from a 64-bit register value, and writes the result to the 64-bit\ndestination register.",
        "heading": "SMSUBL",
        "templates": {
          "64": [
            "SMSUBL  <Xd>, <Wn>, <Wm>, <Xa>"
          ]
        }
      },
      "SMULH": {
        "authored": "Signed Multiply High multiplies two 64-bit register values, and writes\nbits[127:64] of the 128-bit result to the 64-bit destination register.",
        "heading": "SMULH",
        "templates": {
          "64": [
            "SMULH  <Xd>, <Xn>, <Xm>"
          ]
        }
      },
      "SMULL_SMADDL": {
        "authored": "Signed Multiply Long multiplies two 32-bit register values, and writes the\nresult to the 64-bit destination register.",
        "heading": "SMULL",
        "templates": {
          "64": [
            "SMULL  <Xd>, <Wn>, <Wm>"
          ]
        }
      },
      "SSBB": {
        "authored": "Speculative Store Bypass Barrier is a memory barrier which prevents speculative\nloads from bypassing earlier stores to the same virtual address under certain\nconditions.\n\nThe semantics of the Speculative Store Bypass Barrier are:\n  - When a load to a location appears in program order after the SSBB, then the\nload does not speculatively read an entry earlier in the coherence order for\nthat location than the entry generated by the latest store satisfying all of the\nfollowing conditions:\n    - The store is to the same location as the load.\n    - The store uses the same virtual address as the load.\n    - The store appears in program order before the SSBB.\n  - When a load to a location appears in program order before the SSBB, then the\nload does not speculatively read data from any store satisfying all of the\nfollowing conditions:\n    - The store is to the same location as the load.\n    - The store uses the same virtual address as the load.\n    - The store appears in program order after the SSBB.",
        "heading": "SSBB",
        "templates": {
          "SYSTEM": [
            "SSBB"
          ]
        }
      },
      "ST2G": {
        "authored": "Store Allocation Tags stores an Allocation Tag to two Tag granules of memory.\nThe address used for the store is calculated from the base register and an\nimmediate signed offset scaled by the Tag granule. The Allocation Tag is\ncalculated from the Logical Address Tag in the source register.\n\nThis instruction generates an Unchecked access.",
        "heading": "ST2G",
        "templates": {
          "POST_INDEXED": [
            "ST2G  <Xt|SP>, [<Xn|SP>], #<simm>"
          ],
          "PRE_INDEXED": [
            "ST2G  <Xt|SP>, [<Xn|SP>, #<simm>]!"
          ],
          "SIGNED_SCALED_OFFSET": [
            "ST2G  <Xt|SP>, [<Xn|SP>{, #<simm>}]"
          ]
        }
      },
      "ST64B": {
        "authored": "Single-copy Atomic 64-byte Store without Return stores eight 64-bit doublewords\nfrom consecutive registers, Xt to X(t+7), to a memory location. The data that is\nstored is atomic and is required to be 64-byte-aligned.",
        "heading": "ST64B",
        "templates": {
          "GENERAL": [
            "ST64B  <Xt>, [<Xn|SP> {,#0}]"
          ]
        }
      },
      "ST64BV": {
        "authored": "Single-copy Atomic 64-byte Store with Return stores eight 64-bit doublewords\nfrom consecutive registers, Xt to X(t+7), to a memory location, and writes the\nstatus result of the store to a register. The data that is stored is atomic and\nis required to be 64-byte aligned.",
        "heading": "ST64BV",
        "templates": {
          "GENERAL": [
            "ST64BV  <Xs>, <Xt>, [<Xn|SP>]"
          ]
        }
      },
      "ST64BV0": {
        "authored": "Single-copy Atomic 64-byte EL0 Store with Return stores eight 64-bit doublewords\nfrom consecutive registers, Xt to X(t+7), to a memory location, with the bottom\n32 bits taken from ACCDATA_EL1, and writes the status result of the store to a\nregister. The data that is stored is atomic and is required to be 64-byte\naligned.",
        "heading": "ST64BV0",
        "templates": {
          "GENERAL": [
            "ST64BV0  <Xs>, <Xt>, [<Xn|SP>]"
          ]
        }
      },
      "STADDB_LDADDB": {
        "authored": "Atomic add on byte in memory, without return, atomically loads an 8-bit byte\nfrom memory, adds the value held in a register to it, and stores the result back\nto memory.\n  - STADDB does not have release semantics.\n  - STADDLB stores to memory with release semantics, as described in Load-\nAcquire, Store-Release.\n\nFor information about memory accesses see Load/Store addressing modes.",
        "heading": "STADDB, STADDLB",
        "templates": {
          "GENERAL": [
            "STADDB  <Ws>, [<Xn|SP>]",
            "STADDLB  <Ws>, [<Xn|SP>]"
          ]
        }
      },
      "STADDH_LDADDH": {
        "authored": "Atomic add on halfword in memory, without return, atomically loads a 16-bit\nhalfword from memory, adds the value held in a register to it, and stores the\nresult back to memory.\n  - STADDH does not have release semantics.\n  - STADDLH stores to memory with release semantics, as described in Load-\nAcquire, Store-Release.\n\nFor information about memory accesses see Load/Store addressing modes.",
        "heading": "STADDH, STADDLH",
        "templates": {
          "GENERAL": [
            "STADDH  <Ws>, [<Xn|SP>]",
            "STADDLH  <Ws>, [<Xn|SP>]"
          ]
        }
      },
      "STADD_LDADD": {
        "authored": "Atomic add on word or doubleword in memory, without return, atomically loads a\n32-bit word or 64-bit doubleword from memory, adds the value held in a register\nto it, and stores the result back to memory.\n  - STADD does not have release semantics.\n  - STADDL stores to memory with release semantics, as described in Load-\nAcquire, Store-Release.\n\nFor information about memory accesses see Load/Store addressing modes.",
        "heading": "STADD, STADDL",
        "templates": {
          "GENERAL": [
            "STADD  <Ws>, [<Xn|SP>]",
            "STADDL  <Ws>, [<Xn|SP>]",
            "STADD  <Xs>, [<Xn|SP>]",
            "STADDL  <Xs>, [<Xn|SP>]"
          ]
        }
      },
      "STCLRB_LDCLRB": {
        "authored": "Atomic bit clear on byte in memory, without return, atomically loads an 8-bit\nbyte from memory, performs a bitwise AND with the complement of the value held\nin a register on it, and stores the result back to memory.\n  - STCLRB does not have release semantics.\n  - STCLRLB stores to memory with release semantics, as described in Load-\nAcquire, Store-Release.\n\nFor information about memory accesses see Load/Store addressing modes.",
        "heading": "STCLRB, STCLRLB",
        "templates": {
          "GENERAL": [
            "STCLRB  <Ws>, [<Xn|SP>]",
            "STCLRLB  <Ws>, [<Xn|SP>]"
          ]
        }
      },
      "STCLRH_LDCLRH": {
        "authored": "Atomic bit clear on halfword in memory, without return, atomically loads a\n16-bit halfword from memory, performs a bitwise AND with the complement of the\nvalue held in a register on it, and stores the result back to memory.\n  - STCLRH does not have release semantics.\n  - STCLRLH stores to memory with release semantics, as described in Load-\nAcquire, Store-Release.\n\nFor information about memory accesses see Load/Store addressing modes.",
        "heading": "STCLRH, STCLRLH",
        "templates": {
          "GENERAL": [
            "STCLRH  <Ws>, [<Xn|SP>]",
            "STCLRLH  <Ws>, [<Xn|SP>]"
          ]
        }
      },
      "STCLR_LDCLR": {
        "authored": "Atomic bit clear on word or doubleword in memory, without return, atomically\nloads a 32-bit word or 64-bit doubleword from memory, performs a bitwise AND\nwith the complement of the value held in a register on it, and stores the result\nback to memory.\n  - STCLR does not have release semantics.\n  - STCLRL stores to memory with release semantics, as described in Load-\nAcquire, Store-Release.\n\nFor information about memory accesses see Load/Store addressing modes.",
        "heading": "STCLR, STCLRL",
        "templates": {
          "GENERAL": [
            "STCLR  <Ws>, [<Xn|SP>]",
            "STCLRL  <Ws>, [<Xn|SP>]",
            "STCLR  <Xs>, [<Xn|SP>]",
            "STCLRL  <Xs>, [<Xn|SP>]"
          ]
        }
      },
      "STEORB_LDEORB": {
        "authored": "Atomic exclusive OR on byte in memory, without return, atomically loads an 8-bit\nbyte from memory, performs an exclusive OR with the value held in a register on\nit, and stores the result back to memory.\n  - STEORB does not have release semantics.\n  - STEORLB stores to memory with release semantics, as described in Load-\nAcquire, Store-Release.\n\nFor information about memory accesses see Load/Store addressing modes.",
        "heading": "STEORB, STEORLB",
        "templates": {
          "GENERAL": [
            "STEORB  <Ws>, [<Xn|SP>]",
            "STEORLB  <Ws>, [<Xn|SP>]"
          ]
        }
      },
      "STEORH_LDEORH": {
        "authored": "Atomic exclusive OR on halfword in memory, without return, atomically loads a\n16-bit halfword from memory, performs an exclusive OR with the value held in a\nregister on it, and stores the result back to memory.\n  - STEORH does not have release semantics.\n  - STEORLH stores to memory with release semantics, as described in Load-\nAcquire, Store-Release.\n\nFor information about memory accesses see Load/Store addressing modes.",
        "heading": "STEORH, STEORLH",
        "templates": {
          "GENERAL": [
            "STEORH  <Ws>, [<Xn|SP>]",
            "STEORLH  <Ws>, [<Xn|SP>]"
          ]
        }
      },
      "STEOR_LDEOR": {
        "authored": "Atomic exclusive OR on word or doubleword in memory, without return, atomically\nloads a 32-bit word or 64-bit doubleword from memory, performs an exclusive OR\nwith the value held in a register on it, and stores the result back to memory.\n  - STEOR does not have release semantics.\n  - STEORL stores to memory with release semantics, as described in Load-\nAcquire, Store-Release.\n\nFor information about memory accesses see Load/Store addressing modes.",
        "heading": "STEOR, STEORL",
        "templates": {
          "GENERAL": [
            "STEOR  <Ws>, [<Xn|SP>]",
            "STEORL  <Ws>, [<Xn|SP>]",
            "STEOR  <Xs>, [<Xn|SP>]",
            "STEORL  <Xs>, [<Xn|SP>]"
          ]
        }
      },
      "STG": {
        "authored": "Store Allocation Tag stores an Allocation Tag to memory. The address used for\nthe store is calculated from the base register and an immediate signed offset\nscaled by the Tag granule. The Allocation Tag is calculated from the Logical\nAddress Tag in the source register.\n\nThis instruction generates an Unchecked access.",
        "heading": "STG",
        "templates": {
          "POST_INDEXED": [
            "STG  <Xt|SP>, [<Xn|SP>], #<simm>"
          ],
          "PRE_INDEXED": [
            "STG  <Xt|SP>, [<Xn|SP>, #<simm>]!"
          ],
          "SIGNED_SCALED_OFFSET": [
            "STG  <Xt|SP>, [<Xn|SP>{, #<simm>}]"
          ]
        }
      },
      "STGM": {
        "authored": "Store Tag Multiple writes a naturally aligned block of N Allocation Tags, where\nthe size of N is identified in GMID_EL1.BS, and the Allocation Tag written to\naddress A is taken from the source register at 4*A<7:4>+3:4*A<7:4>.\n\nThis instruction is undefined at EL0.\n\nThis instruction generates an Unchecked access.\n\nIf ID_AA64PFR1_EL1.MTE != 0b0010, this instruction is undefined.",
        "heading": "STGM",
        "templates": {
          "GENERAL": [
            "STGM  <Xt>, [<Xn|SP>]"
          ]
        }
      },
      "STGP": {
        "authored": "Store Allocation Tag and Pair of registers stores an Allocation Tag and two\n64-bit doublewords to memory, from two registers. The address used for the store\nis calculated from the base register and an immediate signed offset scaled by\nthe Tag granule. The Allocation Tag is calculated from the Logical Address Tag\nin the base register.\n\nThis instruction generates an Unchecked access.",
        "heading": "STGP",
        "templates": {
          "POST_INDEXED": [
            "STGP  <Xt1>, <Xt2>, [<Xn|SP>], #<imm>"
          ],
          "PRE_INDEXED": [
            "STGP  <Xt1>, <Xt2>, [<Xn|SP>, #<imm>]!"
          ],
          "SIGNED_SCALED_OFFSET": [
            "STGP  <Xt1>, <Xt2>, [<Xn|SP>{, #<imm>}]"
          ]
        }
      },
      "STLLR": {
        "authored": "Store LORelease Register stores a 32-bit word or a 64-bit doubleword to a memory\nlocation, from a register. The instruction also has memory ordering semantics as\ndescribed in Load LOAcquire, Store LORelease. For information about memory\naccesses, see Load/Store addressing modes.",
        "heading": "STLLR",
        "templates": {
          "BASE_REGISTER": [
            "STLLR  <Wt>, [<Xn|SP>{,#0}]",
            "STLLR  <Xt>, [<Xn|SP>{,#0}]"
          ]
        }
      },
      "STLLRB": {
        "authored": "Store LORelease Register Byte stores a byte from a 32-bit register to a memory\nlocation. The instruction also has memory ordering semantics as described in\nLoad LOAcquire, Store LORelease. For information about memory accesses, see\nLoad/Store addressing modes.",
        "heading": "STLLRB",
        "templates": {
          "BASE_REGISTER": [
            "STLLRB  <Wt>, [<Xn|SP>{,#0}]"
          ]
        }
      },
      "STLLRH": {
        "authored": "Store LORelease Register Halfword stores a halfword from a 32-bit register to a\nmemory location. The instruction also has memory ordering semantics as described\nin Load LOAcquire, Store LORelease. For information about memory accesses, see\nLoad/Store addressing modes.",
        "heading": "STLLRH",
        "templates": {
          "BASE_REGISTER": [
            "STLLRH  <Wt>, [<Xn|SP>{,#0}]"
          ]
        }
      },
      "STLR": {
        "authored": "Store-Release Register stores a 32-bit word or a 64-bit doubleword to a memory\nlocation, from a register. The instruction also has memory ordering semantics as\ndescribed in Load-Acquire, Store-Release. For information about memory accesses,\nsee Load/Store addressing modes.",
        "heading": "STLR",
        "templates": {
          "BASE_REGISTER": [
            "STLR  <Wt>, [<Xn|SP>{,#0}]",
            "STLR  <Xt>, [<Xn|SP>{,#0}]"
          ]
        }
      },
      "STLRB": {
        "authored": "Store-Release Register Byte stores a byte from a 32-bit register to a memory\nlocation. The instruction also has memory ordering semantics as described in\nLoad-Acquire, Store-Release. For information about memory accesses, see\nLoad/Store addressing modes.",
        "heading": "STLRB",
        "templates": {
          "BASE_REGISTER": [
            "STLRB  <Wt>, [<Xn|SP>{,#0}]"
          ]
        }
      },
      "STLRH": {
        "authored": "Store-Release Register Halfword stores a halfword from a 32-bit register to a\nmemory location. The instruction also has memory ordering semantics as described\nin Load-Acquire, Store-Release. For information about memory accesses, see\nLoad/Store addressing modes.",
        "heading": "STLRH",
        "templates": {
          "BASE_REGISTER": [
            "STLRH  <Wt>, [<Xn|SP>{,#0}]"
          ]
        }
      },
      "STLURB": {
        "authored": "Store-Release Register Byte (unscaled) calculates an address from a base\nregister value and an immediate offset, and stores a byte to the calculated\naddress, from a 32-bit register.\n\nThe instruction has memory ordering semantics as described in Load-Acquire,\nLoad-AcquirePC, and Store-Release\n\nFor information about memory accesses, see Load/Store addressing modes.",
        "heading": "STLURB",
        "templates": {
          "BASE_PLUS_OFFSET": [
            "STLURB  <Wt>, [<Xn|SP>{, #<simm>}]"
          ]
        }
      },
      "STLURH": {
        "authored": "Store-Release Register Halfword (unscaled) calculates an address from a base\nregister value and an immediate offset, and stores a halfword to the calculated\naddress, from a 32-bit register.\n\nThe instruction has memory ordering semantics as described in Load-Acquire,\nLoad-AcquirePC, and Store-Release\n\nFor information about memory accesses, see Load/Store addressing modes.",
        "heading": "STLURH",
        "templates": {
          "BASE_PLUS_OFFSET": [
            "STLURH  <Wt>, [<Xn|SP>{, #<simm>}]"
          ]
        }
      },
      "STLUR_gen": {
        "authored": "Store-Release Register (unscaled) calculates an address from a base register\nvalue and an immediate offset, and stores a 32-bit word or a 64-bit doubleword\nto the calculated address, from a register.\n\nThe instruction has memory ordering semantics as described in Load-Acquire,\nLoad-AcquirePC, and Store-Release\n\nFor information about memory accesses, see Load/Store addressing modes.",
        "heading": "STLUR",
        "templates": {
          "BASE_PLUS_OFFSET": [
            "STLUR  <Wt>, [<Xn|SP>{, #<simm>}]",
            "STLUR  <Xt>, [<Xn|SP>{, #<simm>}]"
          ]
        }
      },
      "STLXP": {
        "authored": "Store-Release Exclusive Pair of registers stores two 32-bit words or two 64-bit\ndoublewords to a memory location if the PE has exclusive access to the memory\naddress, from two registers, and returns a status value of 0 if the store was\nsuccessful, or of 1 if no store was performed. See Synchronization and\nsemaphores. A 32-bit pair requires the address to be doubleword aligned and is\nsingle-copy atomic at doubleword granularity. A 64-bit pair requires the address\nto be quadword aligned and, if the Store-Exclusive succeeds, it causes a single-\ncopy atomic update of the 128-bit memory location being updated. The instruction\nalso has memory ordering semantics as described in Load-Acquire, Store-Release.\nFor information about memory accesses see Load/Store addressing modes.",
        "heading": "STLXP",
        "templates": {
          "BASE_REGISTER": [
            "STLXP  <Ws>, <Wt1>, <Wt2>, [<Xn|SP>{,#0}]",
            "STLXP  <Ws>, <Xt1>, <Xt2>, [<Xn|SP>{,#0}]"
          ]
        }
      },
      "STLXR": {
        "authored": "Store-Release Exclusive Register stores a 32-bit word or a 64-bit doubleword to\nmemory if the PE has exclusive access to the memory address, from two registers,\nand returns a status value of 0 if the store was successful, or of 1 if no store\nwas performed. See Synchronization and semaphores. The memory access is atomic.\nThe instruction also has memory ordering semantics as described in Load-Acquire,\nStore-Release. For information about memory accesses see Load/Store addressing\nmodes.",
        "heading": "STLXR",
        "templates": {
          "BASE_REGISTER": [
            "STLXR  <Ws>, <Wt>, [<Xn|SP>{,#0}]",
            "STLXR  <Ws>, <Xt>, [<Xn|SP>{,#0}]"
          ]
        }
      },
      "STLXRB": {
        "authored": "Store-Release Exclusive Register Byte stores a byte from a 32-bit register to\nmemory if the PE has exclusive access to the memory address, and returns a\nstatus value of 0 if the store was successful, or of 1 if no store was\nperformed. See Synchronization and semaphores. The memory access is atomic. The\ninstruction also has memory ordering semantics as described in Load-Acquire,\nStore-Release. For information about memory accesses see Load/Store addressing\nmodes.",
        "heading": "STLXRB",
        "templates": {
          "BASE_REGISTER": [
            "STLXRB  <Ws>, <Wt>, [<Xn|SP>{,#0}]"
          ]
        }
      },
      "STLXRH": {
        "authored": "Store-Release Exclusive Register Halfword stores a halfword from a 32-bit\nregister to memory if the PE has exclusive access to the memory address, and\nreturns a status value of 0 if the store was successful, or of 1 if no store was\nperformed. See Synchronization and semaphores. The memory access is atomic. The\ninstruction also has memory ordering semantics as described in Load-Acquire,\nStore-Release. For information about memory accesses see Load/Store addressing\nmodes.",
        "heading": "STLXRH",
        "templates": {
          "BASE_REGISTER": [
            "STLXRH  <Ws>, <Wt>, [<Xn|SP>{,#0}]"
          ]
        }
      },
      "STNP_gen": {
        "authored": "Store Pair of Registers, with non-temporal hint, calculates an address from a\nbase register value and an immediate offset, and stores two 32-bit words or two\n64-bit doublewords to the calculated address, from two registers. For\ninformation about memory accesses, see Load/Store addressing modes. For\ninformation about Non-temporal pair instructions, see Load/Store Non-temporal\npair.",
        "heading": "STNP",
        "templates": {
          "SIGNED_SCALED_OFFSET": [
            "STNP  <Wt1>, <Wt2>, [<Xn|SP>{, #<imm>}]",
            "STNP  <Xt1>, <Xt2>, [<Xn|SP>{, #<imm>}]"
          ]
        }
      },
      "STP_gen": {
        "authored": "Store Pair of Registers calculates an address from a base register value and an\nimmediate offset, and stores two 32-bit words or two 64-bit doublewords to the\ncalculated address, from two registers. For information about memory accesses,\nsee Load/Store addressing modes.",
        "heading": "STP",
        "templates": {
          "POST_INDEXED": [
            "STP  <Wt1>, <Wt2>, [<Xn|SP>], #<imm>",
            "STP  <Xt1>, <Xt2>, [<Xn|SP>], #<imm>"
          ],
          "PRE_INDEXED": [
            "STP  <Wt1>, <Wt2>, [<Xn|SP>, #<imm>]!",
            "STP  <Xt1>, <Xt2>, [<Xn|SP>, #<imm>]!"
          ],
          "SIGNED_SCALED_OFFSET": [
            "STP  <Wt1>, <Wt2>, [<Xn|SP>{, #<imm>}]",
            "STP  <Xt1>, <Xt2>, [<Xn|SP>{, #<imm>}]"
          ]
        }
      },
      "STRB_imm": {
        "authored": "Store Register Byte (immediate) stores the least significant byte of a 32-bit\nregister to memory. The address that is used for the store is calculated from a\nbase register and an immediate offset. For information about memory accesses,\nsee Load/Store addressing modes.",
        "heading": "STRB (immediate)",
        "templates": {
          "POST_INDEXED": [
            "STRB  <Wt>, [<Xn|SP>], #<simm>"
          ],
          "PRE_INDEXED": [
            "STRB  <Wt>, [<Xn|SP>, #<simm>]!"
          ],
          "UNSIGNED_SCALED_OFFSET": [
            "STRB  <Wt>, [<Xn|SP>{, #<pimm>}]"
          ]
        }
      },
      "STRB_reg": {
        "authored": "Store Register Byte (register) calculates an address from a base register value\nand an offset register value, and stores a byte from a 32-bit register to the\ncalculated address. For information about memory accesses, see Load/Store\naddressing modes.\n\nThe instruction uses an offset addressing mode, that calculates the address used\nfor the memory access from a base register value and an offset register value.\nThe offset can be optionally shifted and extended.",
        "heading": "STRB (register)",
        "templates": {
          "32": [
            "STRB  <Wt>, [<Xn|SP>, (<Wm>|<Xm>), <extend> {<amount>}]",
            "STRB  <Wt>, [<Xn|SP>, <Xm>{, LSL <amount>}]"
          ]
        }
      },
      "STRH_imm": {
        "authored": "Store Register Halfword (immediate) stores the least significant halfword of a\n32-bit register to memory. The address that is used for the store is calculated\nfrom a base register and an immediate offset. For information about memory\naccesses, see Load/Store addressing modes.",
        "heading": "STRH (immediate)",
        "templates": {
          "POST_INDEXED": [
            "STRH  <Wt>, [<Xn|SP>], #<simm>"
          ],
          "PRE_INDEXED": [
            "STRH  <Wt>, [<Xn|SP>, #<simm>]!"
          ],
          "UNSIGNED_SCALED_OFFSET": [
            "STRH  <Wt>, [<Xn|SP>{, #<pimm>}]"
          ]
        }
      },
      "STRH_reg": {
        "authored": "Store Register Halfword (register) calculates an address from a base register\nvalue and an offset register value, and stores a halfword from a 32-bit register\nto the calculated address. For information about memory accesses, see Load/Store\naddressing modes.\n\nThe instruction uses an offset addressing mode, that calculates the address used\nfor the memory access from a base register value and an offset register value.\nThe offset can be optionally shifted and extended.",
        "heading": "STRH (register)",
        "templates": {
          "32": [
            "STRH  <Wt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]"
          ]
        }
      },
      "STR_imm_gen": {
        "authored": "Store Register (immediate) stores a word or a doubleword from a register to\nmemory. The address that is used for the store is calculated from a base\nregister and an immediate offset. For information about memory accesses, see\nLoad/Store addressing modes.",
        "heading": "STR (immediate)",
        "templates": {
          "POST_INDEXED": [
            "STR  <Wt>, [<Xn|SP>], #<simm>",
            "STR  <Xt>, [<Xn|SP>], #<simm>"
          ],
          "PRE_INDEXED": [
            "STR  <Wt>, [<Xn|SP>, #<simm>]!",
            "STR  <Xt>, [<Xn|SP>, #<simm>]!"
          ],
          "UNSIGNED_SCALED_OFFSET": [
            "STR  <Wt>, [<Xn|SP>{, #<pimm>}]",
            "STR  <Xt>, [<Xn|SP>{, #<pimm>}]"
          ]
        }
      },
      "STR_reg_gen": {
        "authored": "Store Register (register) calculates an address from a base register value and\nan offset register value, and stores a 32-bit word or a 64-bit doubleword to the\ncalculated address, from a register. For information about memory accesses, see\nLoad/Store addressing modes.\n\nThe instruction uses an offset addressing mode, that calculates the address used\nfor the memory access from a base register value and an offset register value.\nThe offset can be optionally shifted and extended.",
        "heading": "STR (register)",
        "templates": {
          "GENERAL": [
            "STR  <Wt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]",
            "STR  <Xt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]"
          ]
        }
      },
      "STSETB_LDSETB": {
        "authored": "Atomic bit set on byte in memory, without return, atomically loads an 8-bit byte\nfrom memory, performs a bitwise OR with the value held in a register on it, and\nstores the result back to memory.\n  - STSETB does not have release semantics.\n  - STSETLB stores to memory with release semantics, as described in Load-\nAcquire, Store-Release.\n\nFor information about memory accesses see Load/Store addressing modes.",
        "heading": "STSETB, STSETLB",
        "templates": {
          "GENERAL": [
            "STSETB  <Ws>, [<Xn|SP>]",
            "STSETLB  <Ws>, [<Xn|SP>]"
          ]
        }
      },
      "STSETH_LDSETH": {
        "authored": "Atomic bit set on halfword in memory, without return, atomically loads a 16-bit\nhalfword from memory, performs a bitwise OR with the value held in a register on\nit, and stores the result back to memory.\n  - STSETH does not have release semantics.\n  - STSETLH stores to memory with release semantics, as described in Load-\nAcquire, Store-Release.\n\nFor information about memory accesses see Load/Store addressing modes.",
        "heading": "STSETH, STSETLH",
        "templates": {
          "GENERAL": [
            "STSETH  <Ws>, [<Xn|SP>]",
            "STSETLH  <Ws>, [<Xn|SP>]"
          ]
        }
      },
      "STSET_LDSET": {
        "authored": "Atomic bit set on word or doubleword in memory, without return, atomically loads\na 32-bit word or 64-bit doubleword from memory, performs a bitwise OR with the\nvalue held in a register on it, and stores the result back to memory.\n  - STSET does not have release semantics.\n  - STSETL stores to memory with release semantics, as described in Load-\nAcquire, Store-Release.\n\nFor information about memory accesses see Load/Store addressing modes.",
        "heading": "STSET, STSETL",
        "templates": {
          "GENERAL": [
            "STSET  <Ws>, [<Xn|SP>]",
            "STSETL  <Ws>, [<Xn|SP>]",
            "STSET  <Xs>, [<Xn|SP>]",
            "STSETL  <Xs>, [<Xn|SP>]"
          ]
        }
      },
      "STSMAXB_LDSMAXB": {
        "authored": "Atomic signed maximum on byte in memory, without return, atomically loads an\n8-bit byte from memory, compares it against the value held in a register, and\nstores the larger value back to memory, treating the values as signed numbers.\n  - STSMAXB does not have release semantics.\n  - STSMAXLB stores to memory with release semantics, as described in Load-\nAcquire, Store-Release.\n\nFor information about memory accesses see Load/Store addressing modes.",
        "heading": "STSMAXB, STSMAXLB",
        "templates": {
          "GENERAL": [
            "STSMAXB  <Ws>, [<Xn|SP>]",
            "STSMAXLB  <Ws>, [<Xn|SP>]"
          ]
        }
      },
      "STSMAXH_LDSMAXH": {
        "authored": "Atomic signed maximum on halfword in memory, without return, atomically loads a\n16-bit halfword from memory, compares it against the value held in a register,\nand stores the larger value back to memory, treating the values as signed\nnumbers.\n  - STSMAXH does not have release semantics.\n  - STSMAXLH stores to memory with release semantics, as described in Load-\nAcquire, Store-Release.\n\nFor information about memory accesses see Load/Store addressing modes.",
        "heading": "STSMAXH, STSMAXLH",
        "templates": {
          "GENERAL": [
            "STSMAXH  <Ws>, [<Xn|SP>]",
            "STSMAXLH  <Ws>, [<Xn|SP>]"
          ]
        }
      },
      "STSMAX_LDSMAX": {
        "authored": "Atomic signed maximum on word or doubleword in memory, without return,\natomically loads a 32-bit word or 64-bit doubleword from memory, compares it\nagainst the value held in a register, and stores the larger value back to\nmemory, treating the values as signed numbers.\n  - STSMAX does not have release semantics.\n  - STSMAXL stores to memory with release semantics, as described in Load-\nAcquire, Store-Release.\n\nFor information about memory accesses see Load/Store addressing modes.",
        "heading": "STSMAX, STSMAXL",
        "templates": {
          "GENERAL": [
            "STSMAX  <Ws>, [<Xn|SP>]",
            "STSMAXL  <Ws>, [<Xn|SP>]",
            "STSMAX  <Xs>, [<Xn|SP>]",
            "STSMAXL  <Xs>, [<Xn|SP>]"
          ]
        }
      },
      "STSMINB_LDSMINB": {
        "authored": "Atomic signed minimum on byte in memory, without return, atomically loads an\n8-bit byte from memory, compares it against the value held in a register, and\nstores the smaller value back to memory, treating the values as signed numbers.\n  - STSMINB does not have release semantics.\n  - STSMINLB stores to memory with release semantics, as described in Load-\nAcquire, Store-Release.\n\nFor information about memory accesses see Load/Store addressing modes.",
        "heading": "STSMINB, STSMINLB",
        "templates": {
          "GENERAL": [
            "STSMINB  <Ws>, [<Xn|SP>]",
            "STSMINLB  <Ws>, [<Xn|SP>]"
          ]
        }
      },
      "STSMINH_LDSMINH": {
        "authored": "Atomic signed minimum on halfword in memory, without return, atomically loads a\n16-bit halfword from memory, compares it against the value held in a register,\nand stores the smaller value back to memory, treating the values as signed\nnumbers.\n  - STSMINH does not have release semantics.\n  - STSMINLH stores to memory with release semantics, as described in Load-\nAcquire, Store-Release.\n\nFor information about memory accesses see Load/Store addressing modes.",
        "heading": "STSMINH, STSMINLH",
        "templates": {
          "GENERAL": [
            "STSMINH  <Ws>, [<Xn|SP>]",
            "STSMINLH  <Ws>, [<Xn|SP>]"
          ]
        }
      },
      "STSMIN_LDSMIN": {
        "authored": "Atomic signed minimum on word or doubleword in memory, without return,\natomically loads a 32-bit word or 64-bit doubleword from memory, compares it\nagainst the value held in a register, and stores the smaller value back to\nmemory, treating the values as signed numbers.\n  - STSMIN does not have release semantics.\n  - STSMINL stores to memory with release semantics, as described in Load-\nAcquire, Store-Release.\n\nFor information about memory accesses see Load/Store addressing modes.",
        "heading": "STSMIN, STSMINL",
        "templates": {
          "GENERAL": [
            "STSMIN  <Ws>, [<Xn|SP>]",
            "STSMINL  <Ws>, [<Xn|SP>]",
            "STSMIN  <Xs>, [<Xn|SP>]",
            "STSMINL  <Xs>, [<Xn|SP>]"
          ]
        }
      },
      "STTR": {
        "authored": "Store Register (unprivileged) stores a word or doubleword from a register to\nmemory. The address that is used for the store is calculated from a base\nregister and an immediate offset.\n\nMemory accesses made by the instruction behave as if the instruction was\nexecuted at EL0 if the Effective value of PSTATE.UAO is 0 and either:\n  - The instruction is executed at EL1.\n  - The instruction is executed at EL2 when the Effective value of HCR_EL2.{E2H,\nTGE} is {1, 1}.\n\nOtherwise, the memory access operates with the restrictions determined by the\nException level at which the instruction is executed. For information about\nmemory accesses, see Load/Store addressing modes.",
        "heading": "STTR",
        "templates": {
          "BASE_PLUS_OFFSET": [
            "STTR  <Wt>, [<Xn|SP>{, #<simm>}]",
            "STTR  <Xt>, [<Xn|SP>{, #<simm>}]"
          ]
        }
      },
      "STTRB": {
        "authored": "Store Register Byte (unprivileged) stores a byte from a 32-bit register to\nmemory. The address that is used for the store is calculated from a base\nregister and an immediate offset.\n\nMemory accesses made by the instruction behave as if the instruction was\nexecuted at EL0 if the Effective value of PSTATE.UAO is 0 and either:\n  - The instruction is executed at EL1.\n  - The instruction is executed at EL2 when the Effective value of HCR_EL2.{E2H,\nTGE} is {1, 1}.\n\nOtherwise, the memory access operates with the restrictions determined by the\nException level at which the instruction is executed. For information about\nmemory accesses, see Load/Store addressing modes.",
        "heading": "STTRB",
        "templates": {
          "BASE_PLUS_OFFSET": [
            "STTRB  <Wt>, [<Xn|SP>{, #<simm>}]"
          ]
        }
      },
      "STTRH": {
        "authored": "Store Register Halfword (unprivileged) stores a halfword from a 32-bit register\nto memory. The address that is used for the store is calculated from a base\nregister and an immediate offset.\n\nMemory accesses made by the instruction behave as if the instruction was\nexecuted at EL0 if the Effective value of PSTATE.UAO is 0 and either:\n  - The instruction is executed at EL1.\n  - The instruction is executed at EL2 when the Effective value of HCR_EL2.{E2H,\nTGE} is {1, 1}.\n\nOtherwise, the memory access operates with the restrictions determined by the\nException level at which the instruction is executed. For information about\nmemory accesses, see Load/Store addressing modes.",
        "heading": "STTRH",
        "templates": {
          "BASE_PLUS_OFFSET": [
            "STTRH  <Wt>, [<Xn|SP>{, #<simm>}]"
          ]
        }
      },
      "STUMAXB_LDUMAXB": {
        "authored": "Atomic unsigned maximum on byte in memory, without return, atomically loads an\n8-bit byte from memory, compares it against the value held in a register, and\nstores the larger value back to memory, treating the values as unsigned numbers.\n  - STUMAXB does not have release semantics.\n  - STUMAXLB stores to memory with release semantics, as described in Load-\nAcquire, Store-Release.\n\nFor information about memory accesses see Load/Store addressing modes.",
        "heading": "STUMAXB, STUMAXLB",
        "templates": {
          "GENERAL": [
            "STUMAXB  <Ws>, [<Xn|SP>]",
            "STUMAXLB  <Ws>, [<Xn|SP>]"
          ]
        }
      },
      "STUMAXH_LDUMAXH": {
        "authored": "Atomic unsigned maximum on halfword in memory, without return, atomically loads\na 16-bit halfword from memory, compares it against the value held in a register,\nand stores the larger value back to memory, treating the values as unsigned\nnumbers.\n  - STUMAXH does not have release semantics.\n  - STUMAXLH stores to memory with release semantics, as described in Load-\nAcquire, Store-Release.\n\nFor information about memory accesses see Load/Store addressing modes.",
        "heading": "STUMAXH, STUMAXLH",
        "templates": {
          "GENERAL": [
            "STUMAXH  <Ws>, [<Xn|SP>]",
            "STUMAXLH  <Ws>, [<Xn|SP>]"
          ]
        }
      },
      "STUMAX_LDUMAX": {
        "authored": "Atomic unsigned maximum on word or doubleword in memory, without return,\natomically loads a 32-bit word or 64-bit doubleword from memory, compares it\nagainst the value held in a register, and stores the larger value back to\nmemory, treating the values as unsigned numbers.\n  - STUMAX does not have release semantics.\n  - STUMAXL stores to memory with release semantics, as described in Load-\nAcquire, Store-Release.\n\nFor information about memory accesses see Load/Store addressing modes.",
        "heading": "STUMAX, STUMAXL",
        "templates": {
          "GENERAL": [
            "STUMAX  <Ws>, [<Xn|SP>]",
            "STUMAXL  <Ws>, [<Xn|SP>]",
            "STUMAX  <Xs>, [<Xn|SP>]",
            "STUMAXL  <Xs>, [<Xn|SP>]"
          ]
        }
      },
      "STUMINB_LDUMINB": {
        "authored": "Atomic unsigned minimum on byte in memory, without return, atomically loads an\n8-bit byte from memory, compares it against the value held in a register, and\nstores the smaller value back to memory, treating the values as unsigned\nnumbers.\n  - STUMINB does not have release semantics.\n  - STUMINLB stores to memory with release semantics, as described in Load-\nAcquire, Store-Release.\n\nFor information about memory accesses see Load/Store addressing modes.",
        "heading": "STUMINB, STUMINLB",
        "templates": {
          "GENERAL": [
            "STUMINB  <Ws>, [<Xn|SP>]",
            "STUMINLB  <Ws>, [<Xn|SP>]"
          ]
        }
      },
      "STUMINH_LDUMINH": {
        "authored": "Atomic unsigned minimum on halfword in memory, without return, atomically loads\na 16-bit halfword from memory, compares it against the value held in a register,\nand stores the smaller value back to memory, treating the values as unsigned\nnumbers.\n  - STUMINH does not have release semantics.\n  - STUMINLH stores to memory with release semantics, as described in Load-\nAcquire, Store-Release.\n\nFor information about memory accesses see Load/Store addressing modes.",
        "heading": "STUMINH, STUMINLH",
        "templates": {
          "GENERAL": [
            "STUMINH  <Ws>, [<Xn|SP>]",
            "STUMINLH  <Ws>, [<Xn|SP>]"
          ]
        }
      },
      "STUMIN_LDUMIN": {
        "authored": "Atomic unsigned minimum on word or doubleword in memory, without return,\natomically loads a 32-bit word or 64-bit doubleword from memory, compares it\nagainst the value held in a register, and stores the smaller value back to\nmemory, treating the values as unsigned numbers.\n  - STUMIN does not have release semantics.\n  - STUMINL stores to memory with release semantics, as described in Load-\nAcquire, Store-Release.\n\nFor information about memory accesses see Load/Store addressing modes.",
        "heading": "STUMIN, STUMINL",
        "templates": {
          "GENERAL": [
            "STUMIN  <Ws>, [<Xn|SP>]",
            "STUMINL  <Ws>, [<Xn|SP>]",
            "STUMIN  <Xs>, [<Xn|SP>]",
            "STUMINL  <Xs>, [<Xn|SP>]"
          ]
        }
      },
      "STURB": {
        "authored": "Store Register Byte (unscaled) calculates an address from a base register value\nand an immediate offset, and stores a byte to the calculated address, from a\n32-bit register. For information about memory accesses, see Load/Store\naddressing modes.",
        "heading": "STURB",
        "templates": {
          "BASE_PLUS_OFFSET": [
            "STURB  <Wt>, [<Xn|SP>{, #<simm>}]"
          ]
        }
      },
      "STURH": {
        "authored": "Store Register Halfword (unscaled) calculates an address from a base register\nvalue and an immediate offset, and stores a halfword to the calculated address,\nfrom a 32-bit register. For information about memory accesses, see Load/Store\naddressing modes.",
        "heading": "STURH",
        "templates": {
          "BASE_PLUS_OFFSET": [
            "STURH  <Wt>, [<Xn|SP>{, #<simm>}]"
          ]
        }
      },
      "STUR_gen": {
        "authored": "Store Register (unscaled) calculates an address from a base register value and\nan immediate offset, and stores a 32-bit word or a 64-bit doubleword to the\ncalculated address, from a register. For information about memory accesses, see\nLoad/Store addressing modes.",
        "heading": "STUR",
        "templates": {
          "BASE_PLUS_OFFSET": [
            "STUR  <Wt>, [<Xn|SP>{, #<simm>}]",
            "STUR  <Xt>, [<Xn|SP>{, #<simm>}]"
          ]
        }
      },
      "STXP": {
        "authored": "Store Exclusive Pair of registers stores two 32-bit words or two 64-bit\ndoublewords from two registers to a memory location if the PE has exclusive\naccess to the memory address, and returns a status value of 0 if the store was\nsuccessful, or of 1 if no store was performed. See Synchronization and\nsemaphores. A 32-bit pair requires the address to be doubleword aligned and is\nsingle-copy atomic at doubleword granularity. A 64-bit pair requires the address\nto be quadword aligned and, if the Store-Exclusive succeeds, it causes a single-\ncopy atomic update of the 128-bit memory location being updated. For information\nabout memory accesses see Load/Store addressing modes.",
        "heading": "STXP",
        "templates": {
          "BASE_REGISTER": [
            "STXP  <Ws>, <Wt1>, <Wt2>, [<Xn|SP>{,#0}]",
            "STXP  <Ws>, <Xt1>, <Xt2>, [<Xn|SP>{,#0}]"
          ]
        }
      },
      "STXR": {
        "authored": "Store Exclusive Register stores a 32-bit word or a 64-bit doubleword from a\nregister to memory if the PE has exclusive access to the memory address, and\nreturns a status value of 0 if the store was successful, or of 1 if no store was\nperformed. See Synchronization and semaphores. For information about memory\naccesses see Load/Store addressing modes.",
        "heading": "STXR",
        "templates": {
          "BASE_REGISTER": [
            "STXR  <Ws>, <Wt>, [<Xn|SP>{,#0}]",
            "STXR  <Ws>, <Xt>, [<Xn|SP>{,#0}]"
          ]
        }
      },
      "STXRB": {
        "authored": "Store Exclusive Register Byte stores a byte from a register to memory if the PE\nhas exclusive access to the memory address, and returns a status value of 0 if\nthe store was successful, or of 1 if no store was performed. See Synchronization\nand semaphores. The memory access is atomic.\n\nFor information about memory accesses see Load/Store addressing modes.",
        "heading": "STXRB",
        "templates": {
          "BASE_REGISTER": [
            "STXRB  <Ws>, <Wt>, [<Xn|SP>{,#0}]"
          ]
        }
      },
      "STXRH": {
        "authored": "Store Exclusive Register Halfword stores a halfword from a register to memory if\nthe PE has exclusive access to the memory address, and returns a status value of\n0 if the store was successful, or of 1 if no store was performed. See\nSynchronization and semaphores. The memory access is atomic.\n\nFor information about memory accesses see Load/Store addressing modes.",
        "heading": "STXRH",
        "templates": {
          "BASE_REGISTER": [
            "STXRH  <Ws>, <Wt>, [<Xn|SP>{,#0}]"
          ]
        }
      },
      "STZ2G": {
        "authored": "Store Allocation Tags, Zeroing stores an Allocation Tag to two Tag granules of\nmemory, zeroing the associated data locations. The address used for the store is\ncalculated from the base register and an immediate signed offset scaled by the\nTag granule. The Allocation Tag is calculated from the Logical Address Tag in\nthe source register.\n\nThis instruction generates an Unchecked access.",
        "heading": "STZ2G",
        "templates": {
          "POST_INDEXED": [
            "STZ2G  <Xt|SP>, [<Xn|SP>], #<simm>"
          ],
          "PRE_INDEXED": [
            "STZ2G  <Xt|SP>, [<Xn|SP>, #<simm>]!"
          ],
          "SIGNED_SCALED_OFFSET": [
            "STZ2G  <Xt|SP>, [<Xn|SP>{, #<simm>}]"
          ]
        }
      },
      "STZG": {
        "authored": "Store Allocation Tag, Zeroing stores an Allocation Tag to memory, zeroing the\nassociated data location. The address used for the store is calculated from the\nbase register and an immediate signed offset scaled by the Tag granule. The\nAllocation Tag is calculated from the Logical Address Tag in the source\nregister.\n\nThis instruction generates an Unchecked access.",
        "heading": "STZG",
        "templates": {
          "POST_INDEXED": [
            "STZG  <Xt|SP>, [<Xn|SP>], #<simm>"
          ],
          "PRE_INDEXED": [
            "STZG  <Xt|SP>, [<Xn|SP>, #<simm>]!"
          ],
          "SIGNED_SCALED_OFFSET": [
            "STZG  <Xt|SP>, [<Xn|SP>{, #<simm>}]"
          ]
        }
      },
      "STZGM": {
        "authored": "Store Tag and Zero Multiple writes a naturally aligned block of N Allocation\nTags and stores zero to the associated data locations, where the size of N is\nidentified in DCZID_EL0.BS, and the Allocation Tag written to address A is taken\nfrom the source register bits<3:0>.\n\nThis instruction is undefined at EL0.\n\nThis instruction generates an Unchecked access.\n\nIf ID_AA64PFR1_EL1.MTE != 0b0010, this instruction is undefined.",
        "heading": "STZGM",
        "templates": {
          "GENERAL": [
            "STZGM  <Xt>, [<Xn|SP>]"
          ]
        }
      },
      "SUBG": {
        "authored": "Subtract with Tag subtracts an immediate value scaled by the Tag granule from\nthe address in the source register, modifies the Logical Address Tag of the\naddress using an immediate value, and writes the result to the destination\nregister. Tags specified in GCR_EL1.Exclude are excluded from the possible\noutputs when modifying the Logical Address Tag.",
        "heading": "SUBG",
        "templates": {
          "GENERAL": [
            "SUBG  <Xd|SP>, <Xn|SP>, #<uimm6>, #<uimm4>"
          ]
        }
      },
      "SUBP": {
        "authored": "Subtract Pointer subtracts the 56-bit address held in the second source register\nfrom the 56-bit address held in the first source register, sign-extends the\nresult to 64-bits, and writes the result to the destination register.",
        "heading": "SUBP",
        "templates": {
          "GENERAL": [
            "SUBP  <Xd>, <Xn|SP>, <Xm|SP>"
          ]
        }
      },
      "SUBPS": {
        "authored": "Subtract Pointer, setting Flags subtracts the 56-bit address held in the second\nsource register from the 56-bit address held in the first source register, sign-\nextends the result to 64-bits, and writes the result to the destination\nregister. It updates the condition flags based on the result of the subtraction.",
        "heading": "SUBPS",
        "templates": {
          "GENERAL": [
            "SUBPS  <Xd>, <Xn|SP>, <Xm|SP>"
          ]
        }
      },
      "SUBS_addsub_ext": {
        "authored": "Subtract (extended register), setting flags, subtracts a sign or zero-extended\nregister value, followed by an optional left shift amount, from a register\nvalue, and writes the result to the destination register. The argument that is\nextended from the <Rm> register can be a byte, halfword, word, or doubleword. It\nupdates the condition flags based on the result.",
        "heading": "SUBS (extended register)",
        "templates": {
          "S": [
            "SUBS  <Wd>, <Wn|WSP>, <Wm>{, <extend> {#<amount>}}",
            "SUBS  <Xd>, <Xn|SP>, <R><m>{, <extend> {#<amount>}}"
          ]
        }
      },
      "SUBS_addsub_imm": {
        "authored": "Subtract (immediate), setting flags, subtracts an optionally-shifted immediate\nvalue from a register value, and writes the result to the destination register.\nIt updates the condition flags based on the result.",
        "heading": "SUBS (immediate)",
        "templates": {
          "S": [
            "SUBS  <Wd>, <Wn|WSP>, #<imm>{, <shift>}",
            "SUBS  <Xd>, <Xn|SP>, #<imm>{, <shift>}"
          ]
        }
      },
      "SUBS_addsub_shift": {
        "authored": "Subtract (shifted register), setting flags, subtracts an optionally-shifted\nregister value from a register value, and writes the result to the destination\nregister. It updates the condition flags based on the result.",
        "heading": "SUBS (shifted register)",
        "templates": {
          "S": [
            "SUBS  <Wd>, <Wn>, <Wm>{, <shift> #<amount>}",
            "SUBS  <Xd>, <Xn>, <Xm>{, <shift> #<amount>}"
          ]
        }
      },
      "SUB_addsub_ext": {
        "authored": "Subtract (extended register) subtracts a sign or zero-extended register value,\nfollowed by an optional left shift amount, from a register value, and writes the\nresult to the destination register. The argument that is extended from the <Rm>\nregister can be a byte, halfword, word, or doubleword.",
        "heading": "SUB (extended register)",
        "templates": {
          "NO_S": [
            "SUB  <Wd|WSP>, <Wn|WSP>, <Wm>{, <extend> {#<amount>}}",
            "SUB  <Xd|SP>, <Xn|SP>, <R><m>{, <extend> {#<amount>}}"
          ]
        }
      },
      "SUB_addsub_imm": {
        "authored": "Subtract (immediate) subtracts an optionally-shifted immediate value from a\nregister value, and writes the result to the destination register.",
        "heading": "SUB (immediate)",
        "templates": {
          "NO_S": [
            "SUB  <Wd|WSP>, <Wn|WSP>, #<imm>{, <shift>}",
            "SUB  <Xd|SP>, <Xn|SP>, #<imm>{, <shift>}"
          ]
        }
      },
      "SUB_addsub_shift": {
        "authored": "Subtract (shifted register) subtracts an optionally-shifted register value from\na register value, and writes the result to the destination register.",
        "heading": "SUB (shifted register)",
        "templates": {
          "NO_S": [
            "SUB  <Wd>, <Wn>, <Wm>{, <shift> #<amount>}",
            "SUB  <Xd>, <Xn>, <Xm>{, <shift> #<amount>}"
          ]
        }
      },
      "SVC": {
        "authored": "Supervisor Call causes an exception to be taken to EL1.\n\nOn executing an SVC instruction, the PE records the exception as a Supervisor\nCall exception in ESR_ELx, using the EC value 0x15, and the value of the\nimmediate argument.",
        "heading": "SVC",
        "templates": {
          "SYSTEM": [
            "SVC  #<imm>"
          ]
        }
      },
      "SWP": {
        "authored": "Swap word or doubleword in memory atomically loads a 32-bit word or 64-bit\ndoubleword from a memory location, and stores the value held in a register back\nto the same memory location. The value initially loaded from memory is returned\nin the destination register.\n  - If the destination register is not one of WZR or XZR, SWPA and SWPAL load\nfrom memory with acquire semantics.\n  - SWPL and SWPAL store to memory with release semantics.\n  - SWP has neither acquire nor release semantics.\n\nFor more information about memory ordering semantics see Load-Acquire, Store-\nRelease.\n\nFor information about memory accesses see Load/Store addressing modes.",
        "heading": "SWP, SWPA, SWPAL, SWPL",
        "templates": {
          "GENERAL": [
            "SWP  <Ws>, <Wt>, [<Xn|SP>]",
            "SWPA  <Ws>, <Wt>, [<Xn|SP>]",
            "SWPAL  <Ws>, <Wt>, [<Xn|SP>]",
            "SWPL  <Ws>, <Wt>, [<Xn|SP>]",
            "SWP  <Xs>, <Xt>, [<Xn|SP>]",
            "SWPA  <Xs>, <Xt>, [<Xn|SP>]",
            "SWPAL  <Xs>, <Xt>, [<Xn|SP>]",
            "SWPL  <Xs>, <Xt>, [<Xn|SP>]"
          ]
        }
      },
      "SWPB": {
        "authored": "Swap byte in memory atomically loads an 8-bit byte from a memory location, and\nstores the value held in a register back to the same memory location. The value\ninitially loaded from memory is returned in the destination register.\n  - If the destination register is not WZR, SWPAB and SWPALB load from memory\nwith acquire semantics.\n  - SWPLB and SWPALB store to memory with release semantics.\n  - SWPB has neither acquire nor release semantics.\n\nFor more information about memory ordering semantics see Load-Acquire, Store-\nRelease.\n\nFor information about memory accesses see Load/Store addressing modes.",
        "heading": "SWPB, SWPAB, SWPALB, SWPLB",
        "templates": {
          "GENERAL": [
            "SWPAB  <Ws>, <Wt>, [<Xn|SP>]",
            "SWPALB  <Ws>, <Wt>, [<Xn|SP>]",
            "SWPB  <Ws>, <Wt>, [<Xn|SP>]",
            "SWPLB  <Ws>, <Wt>, [<Xn|SP>]"
          ]
        }
      },
      "SWPH": {
        "authored": "Swap halfword in memory atomically loads a 16-bit halfword from a memory\nlocation, and stores the value held in a register back to the same memory\nlocation. The value initially loaded from memory is returned in the destination\nregister.\n  - If the destination register is not WZR, SWPAH and SWPALH load from memory\nwith acquire semantics.\n  - SWPLH and SWPALH store to memory with release semantics.\n  - SWPH has neither acquire nor release semantics.\n\nFor more information about memory ordering semantics see Load-Acquire, Store-\nRelease.\n\nFor information about memory accesses see Load/Store addressing modes.",
        "heading": "SWPH, SWPAH, SWPALH, SWPLH",
        "templates": {
          "GENERAL": [
            "SWPAH  <Ws>, <Wt>, [<Xn|SP>]",
            "SWPALH  <Ws>, <Wt>, [<Xn|SP>]",
            "SWPH  <Ws>, <Wt>, [<Xn|SP>]",
            "SWPLH  <Ws>, <Wt>, [<Xn|SP>]"
          ]
        }
      },
      "SXTB_SBFM": {
        "authored": "Signed Extend Byte extracts an 8-bit value from a register, sign-extends it to\nthe size of the register, and writes the result to the destination register.",
        "heading": "SXTB",
        "templates": {
          "SIGNED_FILL": [
            "SXTB  <Wd>, <Wn>",
            "SXTB  <Xd>, <Wn>"
          ]
        }
      },
      "SXTH_SBFM": {
        "authored": "Sign Extend Halfword extracts a 16-bit value, sign-extends it to the size of the\nregister, and writes the result to the destination register.",
        "heading": "SXTH",
        "templates": {
          "SIGNED_FILL": [
            "SXTH  <Wd>, <Wn>",
            "SXTH  <Xd>, <Wn>"
          ]
        }
      },
      "SXTW_SBFM": {
        "authored": "Sign Extend Word sign-extends a word to the size of the register, and writes the\nresult to the destination register.",
        "heading": "SXTW",
        "templates": {
          "SIGNED_FILL": [
            "SXTW  <Xd>, <Wn>"
          ]
        }
      },
      "SYS": {
        "authored": "System instruction. For more information, see Op0 equals 0b01, cache\nmaintenance, TLB maintenance, and address translation instructions for the\nencodings of System instructions.",
        "heading": "SYS",
        "templates": {
          "SYSTEM": [
            "SYS  #<op1>, <Cn>, <Cm>, #<op2>{, <Xt>}"
          ]
        }
      },
      "SYSL": {
        "authored": "System instruction with result. For more information, see Op0 equals 0b01, cache\nmaintenance, TLB maintenance, and address translation instructions for the\nencodings of System instructions.",
        "heading": "SYSL",
        "templates": {
          "SYSTEM": [
            "SYSL  <Xt>, #<op1>, <Cn>, <Cm>, #<op2>"
          ]
        }
      },
      "TBNZ": {
        "authored": "Test bit and Branch if Nonzero compares the value of a bit in a general-purpose\nregister with zero, and conditionally branches to a label at a PC-relative\noffset if the comparison is not equal. It provides a hint that this is not a\nsubroutine call or return. This instruction does not affect condition flags.",
        "heading": "TBNZ",
        "templates": {
          "BR14": [
            "TBNZ  <R><t>, #<imm>, <label>"
          ]
        }
      },
      "TBZ": {
        "authored": "Test bit and Branch if Zero compares the value of a test bit with zero, and\nconditionally branches to a label at a PC-relative offset if the comparison is\nequal. It provides a hint that this is not a subroutine call or return. This\ninstruction does not affect condition flags.",
        "heading": "TBZ",
        "templates": {
          "BR14": [
            "TBZ  <R><t>, #<imm>, <label>"
          ]
        }
      },
      "TLBI_SYS": {
        "authored": "TLB Invalidate operation. For more information, see op0==0b01, cache\nmaintenance, TLB maintenance, and address translation instructions.",
        "heading": "TLBI",
        "templates": {
          "SYSTEM": [
            "TLBI  <tlbi_op>{, <Xt>}"
          ]
        }
      },
      "TSB": {
        "authored": "Trace Synchronization Barrier. This instruction is a barrier that synchronizes\nthe trace operations of instructions.\n\nIf FEAT_TRF is not implemented, this instruction executes as a NOP.",
        "heading": "TSB CSYNC",
        "templates": {
          "SYSTEM": [
            "TSB CSYNC"
          ]
        }
      },
      "TST_ANDS_log_imm": {
        "authored": ", setting the condition flags and discarding the result",
        "heading": "TST (immediate)",
        "templates": {
          "S": [
            "TST  <Wn>, #<imm>",
            "TST  <Xn>, #<imm>"
          ]
        }
      },
      "TST_ANDS_log_shift": {
        "authored": "Test (shifted register) performs a bitwise AND operation on a register value and\nan optionally-shifted register value. It updates the condition flags based on\nthe result, and discards the result.",
        "heading": "TST (shifted register)",
        "templates": {
          "S": [
            "TST  <Wn>, <Wm>{, <shift> #<amount>}",
            "TST  <Xn>, <Xm>{, <shift> #<amount>}"
          ]
        }
      },
      "UBFIZ_UBFM": {
        "authored": "Unsigned Bitfield Insert in Zeros copies a bitfield of <width> bits from the\nleast significant bits of the source register to bit position <lsb> of the\ndestination register, setting the destination bits above and below the bitfield\nto zero.",
        "heading": "UBFIZ",
        "templates": {
          "ZERO_FILL": [
            "UBFIZ  <Wd>, <Wn>, #<lsb>, #<width>",
            "UBFIZ  <Xd>, <Xn>, #<lsb>, #<width>"
          ]
        }
      },
      "UBFM": {
        "authored": "Unsigned Bitfield Move is usually accessed via one of its aliases, which are\nalways preferred for disassembly.\n\nIf <imms> is greater than or equal to <immr>, this copies a bitfield of\n(<imms>-<immr>+1) bits starting from bit position <immr> in the source register\nto the least significant bits of the destination register.\n\nIf <imms> is less than <immr>, this copies a bitfield of (<imms>+1) bits from\nthe least significant bits of the source register to bit position\n(regsize-<immr>) of the destination register, where regsize is the destination\nregister size of 32 or 64 bits.\n\nIn both cases the destination bits below and above the bitfield are set to zero.",
        "heading": "UBFM",
        "templates": {
          "ZERO_FILL": [
            "UBFM  <Wd>, <Wn>, #<immr>, #<imms>",
            "UBFM  <Xd>, <Xn>, #<immr>, #<imms>"
          ]
        }
      },
      "UBFX_UBFM": {
        "authored": "Unsigned Bitfield Extract copies a bitfield of <width> bits starting from bit\nposition <lsb> in the source register to the least significant bits of the\ndestination register, and sets destination bits above the bitfield to zero.",
        "heading": "UBFX",
        "templates": {
          "ZERO_FILL": [
            "UBFX  <Wd>, <Wn>, #<lsb>, #<width>",
            "UBFX  <Xd>, <Xn>, #<lsb>, #<width>"
          ]
        }
      },
      "UDF_perm_undef": {
        "authored": "Permanently Undefined generates an Undefined Instruction exception (ESR_ELx.EC =\n0b000000). The encodings for UDF used in this section are defined as permanently\nundefined in the Armv8-A architecture.",
        "heading": "UDF",
        "templates": {
          "GENERAL": [
            "UDF  #<imm>"
          ]
        }
      },
      "UDIV": {
        "authored": "Unsigned Divide divides an unsigned integer register value by another unsigned\ninteger register value, and writes the result to the destination register. The\ncondition flags are not affected.",
        "heading": "UDIV",
        "templates": {
          "GENERAL": [
            "UDIV  <Wd>, <Wn>, <Wm>",
            "UDIV  <Xd>, <Xn>, <Xm>"
          ]
        }
      },
      "UMADDL": {
        "authored": "Unsigned Multiply-Add Long multiplies two 32-bit register values, adds a 64-bit\nregister value, and writes the result to the 64-bit destination register.",
        "heading": "UMADDL",
        "templates": {
          "64": [
            "UMADDL  <Xd>, <Wn>, <Wm>, <Xa>"
          ]
        }
      },
      "UMNEGL_UMSUBL": {
        "authored": "Unsigned Multiply-Negate Long multiplies two 32-bit register values, negates the\nproduct, and writes the result to the 64-bit destination register.",
        "heading": "UMNEGL",
        "templates": {
          "64": [
            "UMNEGL  <Xd>, <Wn>, <Wm>"
          ]
        }
      },
      "UMSUBL": {
        "authored": "Unsigned Multiply-Subtract Long multiplies two 32-bit register values, subtracts\nthe product from a 64-bit register value, and writes the result to the 64-bit\ndestination register.",
        "heading": "UMSUBL",
        "templates": {
          "64": [
            "UMSUBL  <Xd>, <Wn>, <Wm>, <Xa>"
          ]
        }
      },
      "UMULH": {
        "authored": "Unsigned Multiply High multiplies two 64-bit register values, and writes\nbits[127:64] of the 128-bit result to the 64-bit destination register.",
        "heading": "UMULH",
        "templates": {
          "64": [
            "UMULH  <Xd>, <Xn>, <Xm>"
          ]
        }
      },
      "UMULL_UMADDL": {
        "authored": "Unsigned Multiply Long multiplies two 32-bit register values, and writes the\nresult to the 64-bit destination register.",
        "heading": "UMULL",
        "templates": {
          "64": [
            "UMULL  <Xd>, <Wn>, <Wm>"
          ]
        }
      },
      "UXTB_UBFM": {
        "authored": "Unsigned Extend Byte extracts an 8-bit value from a register, zero-extends it to\nthe size of the register, and writes the result to the destination register.",
        "heading": "UXTB",
        "templates": {
          "ZERO_FILL": [
            "UXTB  <Wd>, <Wn>"
          ]
        }
      },
      "UXTH_UBFM": {
        "authored": "Unsigned Extend Halfword extracts a 16-bit value from a register, zero-extends\nit to the size of the register, and writes the result to the destination\nregister.",
        "heading": "UXTH",
        "templates": {
          "ZERO_FILL": [
            "UXTH  <Wd>, <Wn>"
          ]
        }
      },
      "WFE": {
        "authored": "Wait For Event is a hint instruction that indicates that the PE can enter a low-\npower state and remain there until a wakeup event occurs. Wakeup events include\nthe event signaled as a result of executing the SEV instruction on any PE in the\nmultiprocessor system. For more information, see Wait For Event mechanism and\nSend event.\n\nAs described in Wait For Event mechanism and Send event, the execution of a WFE\ninstruction that would otherwise cause entry to a low-power state can be trapped\nto a higher Exception level. See:\n  - Traps to EL1 of EL0 execution of WFE and WFI instructions.\n  - Traps to EL2 of Non-secure EL0 and EL1 execution of WFE and WFI\ninstructions.\n  - Traps to EL3 of EL2, EL1, and EL0 execution of WFE and WFI instructions.",
        "heading": "WFE",
        "templates": {
          "SYSTEM": [
            "WFE"
          ]
        }
      },
      "WFET": {
        "authored": "Wait For Event with Timeout is a hint instruction that indicates that the PE can\nenter a low-power state and remain there until either a local timeout event or a\nwakeup event occurs. Wakeup events include the event signaled as a result of\nexecuting the SEV instruction on any PE in the multiprocessor system. For more\ninformation, see Wait For Event mechanism and Send event.\n\nAs described in Wait For Event mechanism and Send event, the execution of a WFET\ninstruction that would otherwise cause entry to a low-power state can be trapped\nto a higher Exception level. See:\n  - Traps to EL1 of EL0 execution of WFE and WFI instructions.\n  - Traps to EL2 of Non-secure EL0 and EL1 execution of WFE and WFI\ninstructions.\n  - Traps to EL3 of EL2, EL1, and EL0 execution of WFE and WFI instructions.",
        "heading": "WFET",
        "templates": {
          "SYSTEM": [
            "WFET  <Xt>"
          ]
        }
      },
      "WFI": {
        "authored": "Wait For Interrupt is a hint instruction that indicates that the PE can enter a\nlow-power state and remain there until a wakeup event occurs. For more\ninformation, see Wait For Interrupt.\n\nAs described in Wait For Interrupt, the execution of a WFI instruction that\nwould otherwise cause entry to a low-power state can be trapped to a higher\nException level. See:\n  - Traps to EL1 of EL0 execution of WFE and WFI instructions.\n  - Traps to EL2 of Non-secure EL0 and EL1 execution of WFE and WFI\ninstructions.\n  - Traps to EL3 of EL2, EL1, and EL0 execution of WFE and WFI instructions.",
        "heading": "WFI",
        "templates": {
          "SYSTEM": [
            "WFI"
          ]
        }
      },
      "WFIT": {
        "authored": "Wait For Interrupt with Timeout is a hint instruction that indicates that the PE\ncan enter a low-power state and remain there until either a local timeout event\nor a wakeup event occurs. For more information, see Wait For Interrupt.\n\nAs described in Wait For Interrupt, the execution of a WFIT instruction that\nwould otherwise cause entry to a low-power state can be trapped to a higher\nException level. See:\n  - Traps to EL1 of EL0 execution of WFE and WFI instructions.\n  - Traps to EL2 of Non-secure EL0 and EL1 execution of WFE and WFI\ninstructions.\n  - Traps to EL3 of EL2, EL1, and EL0 execution of WFE and WFI instructions.",
        "heading": "WFIT",
        "templates": {
          "SYSTEM": [
            "WFIT  <Xt>"
          ]
        }
      },
      "XAFLAG": {
        "authored": "Convert floating-point condition flags from external format to Arm format. This\ninstruction converts the state of the PSTATE.{N,Z,C,V} flags from an alternative\nrepresentation required by some software to a form representing the result of an\nArm floating-point scalar compare instruction.",
        "heading": "XAFLAG",
        "templates": {
          "SYSTEM": [
            "XAFLAG"
          ]
        }
      },
      "XPAC": {
        "authored": "Strip Pointer Authentication Code. This instruction removes the pointer\nauthentication code from an address. The address is in the specified general-\npurpose register for XPACI and XPACD, and is in LR for XPACLRI.\n\nThe XPACD instruction is used for data addresses, and XPACI and XPACLRI are used\nfor instruction addresses.",
        "heading": "XPACD, XPACI, XPACLRI",
        "templates": {
          "GENERAL": [
            "XPACD  <Xd>",
            "XPACI  <Xd>"
          ],
          "SYSTEM": [
            "XPACLRI"
          ]
        }
      },
      "YIELD": {
        "authored": "YIELD is a hint instruction. Software with a multithreading capability can use a\nYIELD instruction to indicate to the PE that it is performing a task, for\nexample a spin-lock, that could be swapped out to improve overall system\nperformance. The PE can use this hint to suspend and resume multiple software\nthreads if it supports the capability.\n\nFor more information about the recommended use of this instruction, see The\nYIELD instruction.",
        "heading": "YIELD",
        "templates": {
          "SYSTEM": [
            "YIELD"
          ]
        }
      }
    },
    "encodings": {
      "A64": {
        "ABS_advsimd": {
          "SIMD": ["0x001110xx100000101110xxxxxxxxxx"],
          "SISD": ["01011110xx100000101110xxxxxxxxxx"]
        },
        "ADC": {
          "NO_S": ["x0011010000xxxxx000000xxxxxxxxxx"]
        },
        "ADCS": {
          "S": ["x0111010000xxxxx000000xxxxxxxxxx"]
        },
        "ADDG": {
          "GENERAL": ["1001000110xxxxxx00xxxxxxxxxxxxxx"]
        },
        "ADDHN_advsimd": {
          "3REG_DIFF": ["0x001110xx1xxxxx010000xxxxxxxxxx"]
        },
        "ADDP_advsimd_pair": {
          "ADVSIMD": ["01011110xx110001101110xxxxxxxxxx"]
        },
        "ADDP_advsimd_vec": {
          "3REG_SAME": ["0x001110xx1xxxxx101111xxxxxxxxxx"]
        },
        "ADDS_addsub_ext": {
          "S": ["x0101011001xxxxxxxxxxxxxxxxxxxxx"]
        },
        "ADDS_addsub_imm": {
          "S": ["x01100010xxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "ADDS_addsub_shift": {
          "S": ["x0101011xx0xxxxxxxxxxxxxxxxxxxxx"]
        },
        "ADDV_advsimd": {
          "ADVSIMD": ["0x001110xx110001101110xxxxxxxxxx"]
        },
        "ADD_addsub_ext": {
          "NO_S": ["x0001011001xxxxxxxxxxxxxxxxxxxxx"]
        },
        "ADD_addsub_imm": {
          "NO_S": ["x00100010xxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "ADD_addsub_shift": {
          "NO_S": ["x0001011xx0xxxxxxxxxxxxxxxxxxxxx"]
        },
        "ADD_advsimd": {
          "SIMD": ["0x001110xx1xxxxx100001xxxxxxxxxx"],
          "SISD": ["01011110xx1xxxxx100001xxxxxxxxxx"]
        },
        "ADR": {
          "LITERAL": ["0xx10000xxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "ADRP": {
          "LITERAL": ["1xx10000xxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "AESD_advsimd": {
          "ADVSIMD": ["0100111000101000010110xxxxxxxxxx"]
        },
        "AESE_advsimd": {
          "ADVSIMD": ["0100111000101000010010xxxxxxxxxx"]
        },
        "AESIMC_advsimd": {
          "ADVSIMD": ["0100111000101000011110xxxxxxxxxx"]
        },
        "AESMC_advsimd": {
          "ADVSIMD": ["0100111000101000011010xxxxxxxxxx"]
        },
        "ANDS_log_imm": {
          "S": ["x11100100xxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "ANDS_log_shift": {
          "S": ["x1101010xx0xxxxxxxxxxxxxxxxxxxxx"]
        },
        "AND_advsimd": {
          "3REG_SAME": ["0x001110001xxxxx000111xxxxxxxxxx"]
        },
        "AND_log_imm": {
          "NO_S": ["x00100100xxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "AND_log_shift": {
          "NO_S": ["x0001010xx0xxxxxxxxxxxxxxxxxxxxx"]
        },
        "ASRV": {
          "GENERAL": ["x0011010110xxxxx001010xxxxxxxxxx"]
        },
        "ASR_ASRV": {
          "GENERAL": ["x0011010110xxxxx001010xxxxxxxxxx"]
        },
        "ASR_SBFM": {
          "SIGNED_FILL": ["x00100110xxxxxxxx11111xxxxxxxxxx"]
        },
        "AT_SYS": {
          "SYSTEM": ["1101010100001xxx0111100xxxxxxxxx"]
        },
        "AUTDA": {
          "GENERAL": ["110110101100000100x110xxxxxxxxxx"]
        },
        "AUTDB": {
          "GENERAL": ["110110101100000100x111xxxxxxxxxx"]
        },
        "AUTIA": {
          "GENERAL": ["110110101100000100x100xxxxxxxxxx"],
          "SYSTEM": ["1101010100000011001000x110x11111"]
        },
        "AUTIB": {
          "GENERAL": ["110110101100000100x101xxxxxxxxxx"],
          "SYSTEM": ["1101010100000011001000x111x11111"]
        },
        "AXFLAG": {
          "SYSTEM": ["11010101000000000100000001011111"]
        },
        "BCAX_advsimd": {
          "ADVSIMD": ["11001110001xxxxx0xxxxxxxxxxxxxxx"]
        },
        "BFCVTN_advsimd": {
          "SIMD_SINGLE_AND_BF16": ["0x00111010100001011010xxxxxxxxxx"]
        },
        "BFCVT_float": {
          "SINGLE_TO_BF16": ["0001111001100011010000xxxxxxxxxx"]
        },
        "BFC_BFM": {
          "NOFILL": ["x01100110xxxxxxxxxxxxx11111xxxxx"]
        },
        "BFDOT_advsimd_elt": {
          "2REG_ELEMENT": ["0x00111101xxxxxx1111x0xxxxxxxxxx"]
        },
        "BFDOT_advsimd_vec": {
          "SIMD": ["0x101110010xxxxx111111xxxxxxxxxx"]
        },
        "BFI_BFM": {
          "NOFILL": ["x01100110xxxxxxxxxxxxxxxxxxxxxxx", "xxxxxxxxxxxxxxxxxxxxxx11111xxxxx"]
        },
        "BFM": {
          "NOFILL": ["x01100110xxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "BFMLAL_advsimd_elt": {
          "2REG_ELEMENT": ["0x00111111xxxxxx1111x0xxxxxxxxxx"]
        },
        "BFMLAL_advsimd_vec": {
          "SIMD": ["0x101110110xxxxx111111xxxxxxxxxx"]
        },
        "BFMMLA_advsimd": {
          "SIMD": ["01101110010xxxxx111011xxxxxxxxxx"]
        },
        "BFXIL_BFM": {
          "NOFILL": ["x01100110xxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "BICS": {
          "S": ["x1101010xx1xxxxxxxxxxxxxxxxxxxxx"]
        },
        "BIC_advsimd_imm": {
          "SHIFTED_IMMEDIATE": ["0x10111100000xxxxxx101xxxxxxxxxx"]
        },
        "BIC_advsimd_reg": {
          "3REG_SAME": ["0x001110011xxxxx000111xxxxxxxxxx"]
        },
        "BIC_log_shift": {
          "NO_S": ["x0001010xx1xxxxxxxxxxxxxxxxxxxxx"]
        },
        "BIF_advsimd": {
          "3REG_SAME": ["0x101110111xxxxx000111xxxxxxxxxx"]
        },
        "BIT_advsimd": {
          "3REG_SAME": ["0x101110101xxxxx000111xxxxxxxxxx"]
        },
        "BL": {
          "BR26": ["100101xxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "BLR": {
          "GENERAL": ["1101011000111111000000xxxxx00000"]
        },
        "BLRA": {
          "GENERAL": ["1101011x0011111100001xxxxxxxxxxx"]
        },
        "BR": {
          "GENERAL": ["1101011000011111000000xxxxx00000"]
        },
        "BRA": {
          "GENERAL": ["1101011x0001111100001xxxxxxxxxxx"]
        },
        "BRK": {
          "SYSTEM": ["11010100001xxxxxxxxxxxxxxxx00000"]
        },
        "BSL_advsimd": {
          "3REG_SAME": ["0x101110011xxxxx000111xxxxxxxxxx"]
        },
        "BTI": {
          "SYSTEM": ["110101010000001100100100xx011111"]
        },
        "B_cond": {
          "BR19": ["01010100xxxxxxxxxxxxxxxxxxx0xxxx"]
        },
        "B_uncond": {
          "BR26": ["000101xxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "CAS": {
          "BASE_REGISTER": ["1x0010001x1xxxxxx11111xxxxxxxxxx"]
        },
        "CASB": {
          "BASE_REGISTER": ["000010001x1xxxxxx11111xxxxxxxxxx"]
        },
        "CASH": {
          "BASE_REGISTER": ["010010001x1xxxxxx11111xxxxxxxxxx"]
        },
        "CASP": {
          "BASE_REGISTER": ["0x0010000x1xxxxxx11111xxxxxxxxxx"]
        },
        "CBNZ": {
          "BR19": ["x0110101xxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "CBZ": {
          "BR19": ["x0110100xxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "CCMN_imm": {
          "IMM5U": ["x0111010010xxxxxxxxx10xxxxx0xxxx"]
        },
        "CCMN_reg": {
          "GENERAL": ["x0111010010xxxxxxxxx00xxxxx0xxxx"]
        },
        "CCMP_imm": {
          "IMM5U": ["x1111010010xxxxxxxxx10xxxxx0xxxx"]
        },
        "CCMP_reg": {
          "GENERAL": ["x1111010010xxxxxxxxx00xxxxx0xxxx"]
        },
        "CFINV": {
          "SYSTEM": ["11010101000000000100000000011111"]
        },
        "CFP_SYS": {
          "SYSTEM": ["110101010000101101110011100xxxxx"]
        },
        "CINC_CSINC": {
          "GENERAL": ["x0011010100xxxxxxxxx01xxxxxxxxxx", "xxxxxxxxxxx11111xxxxxxxxxxxxxxxx", "xxxxxxxxxxxxxxxx111xxxxxxxxxxxxx", "xxxxxxxxxxxxxxxxxxxxxx11111xxxxx"]
        },
        "CINV_CSINV": {
          "GENERAL": ["x1011010100xxxxxxxxx00xxxxxxxxxx", "xxxxxxxxxxx11111xxxxxxxxxxxxxxxx", "xxxxxxxxxxxxxxxx111xxxxxxxxxxxxx", "xxxxxxxxxxxxxxxxxxxxxx11111xxxxx"]
        },
        "CLREX": {
          "SYSTEM": ["11010101000000110011xxxx01011111"]
        },
        "CLS_advsimd": {
          "SIMD": ["0x001110xx100000010010xxxxxxxxxx"]
        },
        "CLS_int": {
          "GENERAL": ["x101101011000000000101xxxxxxxxxx"]
        },
        "CLZ_advsimd": {
          "SIMD": ["0x101110xx100000010010xxxxxxxxxx"]
        },
        "CLZ_int": {
          "GENERAL": ["x101101011000000000100xxxxxxxxxx"]
        },
        "CMEQ_advsimd_reg": {
          "SIMD": ["0x101110xx1xxxxx100011xxxxxxxxxx"],
          "SISD": ["01111110xx1xxxxx100011xxxxxxxxxx"]
        },
        "CMEQ_advsimd_zero": {
          "SIMD": ["0x001110xx100000100110xxxxxxxxxx"],
          "SISD": ["01011110xx100000100110xxxxxxxxxx"]
        },
        "CMGE_advsimd_reg": {
          "SIMD": ["0x001110xx1xxxxx001111xxxxxxxxxx"],
          "SISD": ["01011110xx1xxxxx001111xxxxxxxxxx"]
        },
        "CMGE_advsimd_zero": {
          "SIMD": ["0x101110xx100000100010xxxxxxxxxx"],
          "SISD": ["01111110xx100000100010xxxxxxxxxx"]
        },
        "CMGT_advsimd_reg": {
          "SIMD": ["0x001110xx1xxxxx001101xxxxxxxxxx"],
          "SISD": ["01011110xx1xxxxx001101xxxxxxxxxx"]
        },
        "CMGT_advsimd_zero": {
          "SIMD": ["0x001110xx100000100010xxxxxxxxxx"],
          "SISD": ["01011110xx100000100010xxxxxxxxxx"]
        },
        "CMHI_advsimd": {
          "SIMD": ["0x101110xx1xxxxx001101xxxxxxxxxx"],
          "SISD": ["01111110xx1xxxxx001101xxxxxxxxxx"]
        },
        "CMHS_advsimd": {
          "SIMD": ["0x101110xx1xxxxx001111xxxxxxxxxx"],
          "SISD": ["01111110xx1xxxxx001111xxxxxxxxxx"]
        },
        "CMLE_advsimd": {
          "SIMD": ["0x101110xx100000100110xxxxxxxxxx"],
          "SISD": ["01111110xx100000100110xxxxxxxxxx"]
        },
        "CMLT_advsimd": {
          "SIMD": ["0x001110xx100000101010xxxxxxxxxx"],
          "SISD": ["01011110xx100000101010xxxxxxxxxx"]
        },
        "CMN_ADDS_addsub_ext": {
          "S": ["x0101011001xxxxxxxxxxxxxxxx11111"]
        },
        "CMN_ADDS_addsub_imm": {
          "S": ["x01100010xxxxxxxxxxxxxxxxxx11111"]
        },
        "CMN_ADDS_addsub_shift": {
          "S": ["x0101011xx0xxxxxxxxxxxxxxxx11111"]
        },
        "CMPP_SUBPS": {
          "GENERAL": ["10111010110xxxxx000000xxxxx11111"]
        },
        "CMP_SUBS_addsub_ext": {
          "S": ["x1101011001xxxxxxxxxxxxxxxx11111"]
        },
        "CMP_SUBS_addsub_imm": {
          "S": ["x11100010xxxxxxxxxxxxxxxxxx11111"]
        },
        "CMP_SUBS_addsub_shift": {
          "S": ["x1101011xx0xxxxxxxxxxxxxxxx11111"]
        },
        "CMTST_advsimd": {
          "SIMD": ["0x001110xx1xxxxx100011xxxxxxxxxx"],
          "SISD": ["01011110xx1xxxxx100011xxxxxxxxxx"]
        },
        "CNEG_CSNEG": {
          "GENERAL": ["x1011010100xxxxxxxxx01xxxxxxxxxx", "xxxxxxxxxxxxxxxx111xxxxxxxxxxxxx"]
        },
        "CNT_advsimd": {
          "SIMD": ["0x001110xx100000010110xxxxxxxxxx"]
        },
        "CPP_SYS": {
          "SYSTEM": ["110101010000101101110011111xxxxx"]
        },
        "CRC32": {
          "CRC": ["x0011010110xxxxx0100xxxxxxxxxxxx"]
        },
        "CRC32C": {
          "CRC": ["x0011010110xxxxx0101xxxxxxxxxxxx"]
        },
        "CSDB": {
          "SYSTEM": ["11010101000000110010001010011111"]
        },
        "CSEL": {
          "GENERAL": ["x0011010100xxxxxxxxx00xxxxxxxxxx"]
        },
        "CSETM_CSINV": {
          "GENERAL": ["x101101010011111xxxx0011111xxxxx", "xxxxxxxxxxxxxxxx111xxxxxxxxxxxxx"]
        },
        "CSET_CSINC": {
          "GENERAL": ["x001101010011111xxxx0111111xxxxx", "xxxxxxxxxxxxxxxx111xxxxxxxxxxxxx"]
        },
        "CSINC": {
          "GENERAL": ["x0011010100xxxxxxxxx01xxxxxxxxxx"]
        },
        "CSINV": {
          "GENERAL": ["x1011010100xxxxxxxxx00xxxxxxxxxx"]
        },
        "CSNEG": {
          "GENERAL": ["x1011010100xxxxxxxxx01xxxxxxxxxx"]
        },
        "DCPS1": {
          "SYSTEM": ["11010100101xxxxxxxxxxxxxxxx00001"]
        },
        "DCPS2": {
          "SYSTEM": ["11010100101xxxxxxxxxxxxxxxx00010"]
        },
        "DCPS3": {
          "SYSTEM": ["11010100101xxxxxxxxxxxxxxxx00011"]
        },
        "DC_SYS": {
          "SYSTEM": ["1101010100001xxx0111xxxxxxxxxxxx"]
        },
        "DGH": {
          "SYSTEM": ["11010101000000110010000011011111"]
        },
        "DMB": {
          "SYSTEM": ["11010101000000110011xxxx10111111"]
        },
        "DRPS": {
          "SYSTEM": ["11010110101111110000001111100000"]
        },
        "DSB": {
          "DSB_MEMORY": ["11010101000000110011xxxx10011111", "xxxxxxxxxxxxxxxxxxxx0x00xxxxxxxx"],
          "DSB_NXS": ["11010101000000110011xx1000111111"]
        },
        "DUP_advsimd_elt": {
          "SCALAR_FROM_ELEMENT": ["01011110000xxxxx000001xxxxxxxxxx"],
          "VECTOR_FROM_ELEMENT": ["0x001110000xxxxx000001xxxxxxxxxx"]
        },
        "DUP_advsimd_gen": {
          "ADVSIMD": ["0x001110000xxxxx000011xxxxxxxxxx"]
        },
        "DVP_SYS": {
          "SYSTEM": ["110101010000101101110011101xxxxx"]
        },
        "EON": {
          "NO_S": ["x1001010xx1xxxxxxxxxxxxxxxxxxxxx"]
        },
        "EOR3_advsimd": {
          "ADVSIMD": ["11001110000xxxxx0xxxxxxxxxxxxxxx"]
        },
        "EOR_advsimd": {
          "3REG_SAME": ["0x101110001xxxxx000111xxxxxxxxxx"]
        },
        "EOR_log_imm": {
          "NO_S": ["x10100100xxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "EOR_log_shift": {
          "GENERAL": ["x1001010xx0xxxxxxxxxxxxxxxxxxxxx"]
        },
        "ERET": {
          "SYSTEM": ["11010110100111110000001111100000"]
        },
        "ERETA": {
          "GENERAL": ["110101101001111100001x1111111111"]
        },
        "ESB": {
          "SYSTEM": ["11010101000000110010001000011111"]
        },
        "EXTR": {
          "GENERAL": ["x00100111x0xxxxxxxxxxxxxxxxxxxxx"]
        },
        "EXT_advsimd": {
          "ADVSIMD": ["0x101110000xxxxx0xxxx0xxxxxxxxxx"]
        },
        "FABD_advsimd": {
          "SIMD_HALF": ["0x101110110xxxxx000101xxxxxxxxxx"],
          "SIMD_SINGLE_AND_DOUBLE": ["0x1011101x1xxxxx110101xxxxxxxxxx"],
          "SISD_HALF": ["01111110110xxxxx000101xxxxxxxxxx"],
          "SISD_SINGLE_AND_DOUBLE": ["011111101x1xxxxx110101xxxxxxxxxx"]
        },
        "FABS_advsimd": {
          "HALF": ["0x00111011111000111110xxxxxxxxxx"],
          "SINGLE_AND_DOUBLE": ["0x0011101x100000111110xxxxxxxxxx"]
        },
        "FABS_float": {
          "FLOAT": ["00011110xx100000110000xxxxxxxxxx"]
        },
        "FACGE_advsimd": {
          "SIMD_HALF": ["0x101110010xxxxx001011xxxxxxxxxx"],
          "SIMD_SINGLE_AND_DOUBLE": ["0x1011100x1xxxxx111011xxxxxxxxxx"],
          "SISD_HALF": ["01111110010xxxxx001011xxxxxxxxxx"],
          "SISD_SINGLE_AND_DOUBLE": ["011111100x1xxxxx111011xxxxxxxxxx"]
        },
        "FACGT_advsimd": {
          "SIMD_HALF": ["0x101110110xxxxx001011xxxxxxxxxx"],
          "SIMD_SINGLE_AND_DOUBLE": ["0x1011101x1xxxxx111011xxxxxxxxxx"],
          "SISD_HALF": ["01111110110xxxxx001011xxxxxxxxxx"],
          "SISD_SINGLE_AND_DOUBLE": ["011111101x1xxxxx111011xxxxxxxxxx"]
        },
        "FADDP_advsimd_pair": {
          "HALF": ["010111100x110000110110xxxxxxxxxx"],
          "SINGLE_AND_DOUBLE": ["011111100x110000110110xxxxxxxxxx"]
        },
        "FADDP_advsimd_vec": {
          "HALF": ["0x101110010xxxxx000101xxxxxxxxxx"],
          "SINGLE_AND_DOUBLE": ["0x1011100x1xxxxx110101xxxxxxxxxx"]
        },
        "FADD_advsimd": {
          "HALF": ["0x001110010xxxxx000101xxxxxxxxxx"],
          "SINGLE_AND_DOUBLE": ["0x0011100x1xxxxx110101xxxxxxxxxx"]
        },
        "FADD_float": {
          "FLOAT": ["00011110xx1xxxxx001010xxxxxxxxxx"]
        },
        "FCADD_advsimd_vec": {
          "SIMD": ["0x101110xx0xxxxx111x01xxxxxxxxxx"]
        },
        "FCCMPE_float": {
          "FLOAT": ["00011110xx1xxxxxxxxx01xxxxx1xxxx"]
        },
        "FCCMP_float": {
          "FLOAT": ["00011110xx1xxxxxxxxx01xxxxx0xxxx"]
        },
        "FCMEQ_advsimd_reg": {
          "SIMD_HALF": ["0x001110010xxxxx001001xxxxxxxxxx"],
          "SIMD_SINGLE_AND_DOUBLE": ["0x0011100x1xxxxx111001xxxxxxxxxx"],
          "SISD_HALF": ["01011110010xxxxx001001xxxxxxxxxx"],
          "SISD_SINGLE_AND_DOUBLE": ["010111100x1xxxxx111001xxxxxxxxxx"]
        },
        "FCMEQ_advsimd_zero": {
          "SIMD_HALF": ["0x00111011111000110110xxxxxxxxxx"],
          "SIMD_SINGLE_AND_DOUBLE": ["0x0011101x100000110110xxxxxxxxxx"],
          "SISD_HALF": ["0101111011111000110110xxxxxxxxxx"],
          "SISD_SINGLE_AND_DOUBLE": ["010111101x100000110110xxxxxxxxxx"]
        },
        "FCMGE_advsimd_reg": {
          "SIMD_HALF": ["0x101110010xxxxx001001xxxxxxxxxx"],
          "SIMD_SINGLE_AND_DOUBLE": ["0x1011100x1xxxxx111001xxxxxxxxxx"],
          "SISD_HALF": ["01111110010xxxxx001001xxxxxxxxxx"],
          "SISD_SINGLE_AND_DOUBLE": ["011111100x1xxxxx111001xxxxxxxxxx"]
        },
        "FCMGE_advsimd_zero": {
          "SIMD_HALF": ["0x10111011111000110010xxxxxxxxxx"],
          "SIMD_SINGLE_AND_DOUBLE": ["0x1011101x100000110010xxxxxxxxxx"],
          "SISD_HALF": ["0111111011111000110010xxxxxxxxxx"],
          "SISD_SINGLE_AND_DOUBLE": ["011111101x100000110010xxxxxxxxxx"]
        },
        "FCMGT_advsimd_reg": {
          "SIMD_HALF": ["0x101110110xxxxx001001xxxxxxxxxx"],
          "SIMD_SINGLE_AND_DOUBLE": ["0x1011101x1xxxxx111001xxxxxxxxxx"],
          "SISD_HALF": ["01111110110xxxxx001001xxxxxxxxxx"],
          "SISD_SINGLE_AND_DOUBLE": ["011111101x1xxxxx111001xxxxxxxxxx"]
        },
        "FCMGT_advsimd_zero": {
          "SIMD_HALF": ["0x00111011111000110010xxxxxxxxxx"],
          "SIMD_SINGLE_AND_DOUBLE": ["0x0011101x100000110010xxxxxxxxxx"],
          "SISD_HALF": ["0101111011111000110010xxxxxxxxxx"],
          "SISD_SINGLE_AND_DOUBLE": ["010111101x100000110010xxxxxxxxxx"]
        },
        "FCMLA_advsimd_elt": {
          "2REG_ELEMENT": ["0x101111xxxxxxxx0xx1x0xxxxxxxxxx"]
        },
        "FCMLA_advsimd_vec": {
          "SIMD": ["0x101110xx0xxxxx110xx1xxxxxxxxxx"]
        },
        "FCMLE_advsimd": {
          "SIMD_HALF": ["0x10111011111000110110xxxxxxxxxx"],
          "SIMD_SINGLE_AND_DOUBLE": ["0x1011101x100000110110xxxxxxxxxx"],
          "SISD_HALF": ["0111111011111000110110xxxxxxxxxx"],
          "SISD_SINGLE_AND_DOUBLE": ["011111101x100000110110xxxxxxxxxx"]
        },
        "FCMLT_advsimd": {
          "SIMD_HALF": ["0x00111011111000111010xxxxxxxxxx"],
          "SIMD_SINGLE_AND_DOUBLE": ["0x0011101x100000111010xxxxxxxxxx"],
          "SISD_HALF": ["0101111011111000111010xxxxxxxxxx"],
          "SISD_SINGLE_AND_DOUBLE": ["010111101x100000111010xxxxxxxxxx"]
        },
        "FCMPE_float": {
          "FLOAT": ["00011110xx1xxxxx001000xxxxx1x000"]
        },
        "FCMP_float": {
          "FLOAT": ["00011110xx1xxxxx001000xxxxx0x000"]
        },
        "FCSEL_float": {
          "FLOAT": ["00011110xx1xxxxxxxxx11xxxxxxxxxx"]
        },
        "FCVTAS_advsimd": {
          "SIMD_HALF": ["0x00111001111001110010xxxxxxxxxx"],
          "SIMD_SINGLE_AND_DOUBLE": ["0x0011100x100001110010xxxxxxxxxx"],
          "SISD_HALF": ["0101111001111001110010xxxxxxxxxx"],
          "SISD_SINGLE_AND_DOUBLE": ["010111100x100001110010xxxxxxxxxx"]
        },
        "FCVTAS_float": {
          "FLOAT": ["x0011110xx100100000000xxxxxxxxxx"]
        },
        "FCVTAU_advsimd": {
          "SIMD_HALF": ["0x10111001111001110010xxxxxxxxxx"],
          "SIMD_SINGLE_AND_DOUBLE": ["0x1011100x100001110010xxxxxxxxxx"],
          "SISD_HALF": ["0111111001111001110010xxxxxxxxxx"],
          "SISD_SINGLE_AND_DOUBLE": ["011111100x100001110010xxxxxxxxxx"]
        },
        "FCVTAU_float": {
          "FLOAT": ["x0011110xx100101000000xxxxxxxxxx"]
        },
        "FCVTL_advsimd": {
          "SIMD_SINGLE_AND_DOUBLE": ["0x0011100x100001011110xxxxxxxxxx"]
        },
        "FCVTMS_advsimd": {
          "SIMD_HALF": ["0x00111001111001101110xxxxxxxxxx"],
          "SIMD_SINGLE_AND_DOUBLE": ["0x0011100x100001101110xxxxxxxxxx"],
          "SISD_HALF": ["0101111001111001101110xxxxxxxxxx"],
          "SISD_SINGLE_AND_DOUBLE": ["010111100x100001101110xxxxxxxxxx"]
        },
        "FCVTMS_float": {
          "FLOAT": ["x0011110xx110000000000xxxxxxxxxx"]
        },
        "FCVTMU_advsimd": {
          "SIMD_HALF": ["0x10111001111001101110xxxxxxxxxx"],
          "SIMD_SINGLE_AND_DOUBLE": ["0x1011100x100001101110xxxxxxxxxx"],
          "SISD_HALF": ["0111111001111001101110xxxxxxxxxx"],
          "SISD_SINGLE_AND_DOUBLE": ["011111100x100001101110xxxxxxxxxx"]
        },
        "FCVTMU_float": {
          "FLOAT": ["x0011110xx110001000000xxxxxxxxxx"]
        },
        "FCVTNS_advsimd": {
          "SIMD_HALF": ["0x00111001111001101010xxxxxxxxxx"],
          "SIMD_SINGLE_AND_DOUBLE": ["0x0011100x100001101010xxxxxxxxxx"],
          "SISD_HALF": ["0101111001111001101010xxxxxxxxxx"],
          "SISD_SINGLE_AND_DOUBLE": ["010111100x100001101010xxxxxxxxxx"]
        },
        "FCVTNS_float": {
          "FLOAT": ["x0011110xx100000000000xxxxxxxxxx"]
        },
        "FCVTNU_advsimd": {
          "SIMD_HALF": ["0x10111001111001101010xxxxxxxxxx"],
          "SIMD_SINGLE_AND_DOUBLE": ["0x1011100x100001101010xxxxxxxxxx"],
          "SISD_HALF": ["0111111001111001101010xxxxxxxxxx"],
          "SISD_SINGLE_AND_DOUBLE": ["011111100x100001101010xxxxxxxxxx"]
        },
        "FCVTNU_float": {
          "FLOAT": ["x0011110xx100001000000xxxxxxxxxx"]
        },
        "FCVTN_advsimd": {
          "SIMD_SINGLE_AND_DOUBLE": ["0x0011100x100001011010xxxxxxxxxx"]
        },
        "FCVTPS_advsimd": {
          "SIMD_HALF": ["0x00111011111001101010xxxxxxxxxx"],
          "SIMD_SINGLE_AND_DOUBLE": ["0x0011101x100001101010xxxxxxxxxx"],
          "SISD_HALF": ["0101111011111001101010xxxxxxxxxx"],
          "SISD_SINGLE_AND_DOUBLE": ["010111101x100001101010xxxxxxxxxx"]
        },
        "FCVTPS_float": {
          "FLOAT": ["x0011110xx101000000000xxxxxxxxxx"]
        },
        "FCVTPU_advsimd": {
          "SIMD_HALF": ["0x10111011111001101010xxxxxxxxxx"],
          "SIMD_SINGLE_AND_DOUBLE": ["0x1011101x100001101010xxxxxxxxxx"],
          "SISD_HALF": ["0111111011111001101010xxxxxxxxxx"],
          "SISD_SINGLE_AND_DOUBLE": ["011111101x100001101010xxxxxxxxxx"]
        },
        "FCVTPU_float": {
          "FLOAT": ["x0011110xx101001000000xxxxxxxxxx"]
        },
        "FCVTXN_advsimd": {
          "SIMD": ["0x1011100x100001011010xxxxxxxxxx"],
          "SISD": ["011111100x100001011010xxxxxxxxxx"]
        },
        "FCVTZS_advsimd_fix": {
          "SIMD": ["0x0011110xxxxxxx111111xxxxxxxxxx", "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"],
          "SISD": ["010111110xxxxxxx111111xxxxxxxxxx", "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"]
        },
        "FCVTZS_advsimd_int": {
          "SIMD_HALF": ["0x00111011111001101110xxxxxxxxxx"],
          "SIMD_SINGLE_AND_DOUBLE": ["0x0011101x100001101110xxxxxxxxxx"],
          "SISD_HALF": ["0101111011111001101110xxxxxxxxxx"],
          "SISD_SINGLE_AND_DOUBLE": ["010111101x100001101110xxxxxxxxxx"]
        },
        "FCVTZS_float_fix": {
          "FLOAT": ["x0011110xx011000xxxxxxxxxxxxxxxx"]
        },
        "FCVTZS_float_int": {
          "FLOAT": ["x0011110xx111000000000xxxxxxxxxx"]
        },
        "FCVTZU_advsimd_fix": {
          "SIMD": ["0x1011110xxxxxxx111111xxxxxxxxxx", "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"],
          "SISD": ["011111110xxxxxxx111111xxxxxxxxxx", "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"]
        },
        "FCVTZU_advsimd_int": {
          "SIMD_HALF": ["0x10111011111001101110xxxxxxxxxx"],
          "SIMD_SINGLE_AND_DOUBLE": ["0x1011101x100001101110xxxxxxxxxx"],
          "SISD_HALF": ["0111111011111001101110xxxxxxxxxx"],
          "SISD_SINGLE_AND_DOUBLE": ["011111101x100001101110xxxxxxxxxx"]
        },
        "FCVTZU_float_fix": {
          "FLOAT": ["x0011110xx011001xxxxxxxxxxxxxxxx"]
        },
        "FCVTZU_float_int": {
          "FLOAT": ["x0011110xx111001000000xxxxxxxxxx"]
        },
        "FCVT_float": {
          "FLOAT": ["00011110xx10001xx10000xxxxxxxxxx"]
        },
        "FDIV_advsimd": {
          "HALF": ["0x101110010xxxxx001111xxxxxxxxxx"],
          "SINGLE_AND_DOUBLE": ["0x1011100x1xxxxx111111xxxxxxxxxx"]
        },
        "FDIV_float": {
          "FLOAT": ["00011110xx1xxxxx000110xxxxxxxxxx"]
        },
        "FJCVTZS": {
          "DOUBLE_TO_32": ["0001111001111110000000xxxxxxxxxx"]
        },
        "FMADD_float": {
          "FLOAT": ["00011111xx0xxxxx0xxxxxxxxxxxxxxx"]
        },
        "FMAXNMP_advsimd_pair": {
          "HALF": ["010111100x110000110010xxxxxxxxxx"],
          "SINGLE_AND_DOUBLE": ["011111100x110000110010xxxxxxxxxx"]
        },
        "FMAXNMP_advsimd_vec": {
          "HALF": ["0x101110010xxxxx000001xxxxxxxxxx"],
          "SINGLE_AND_DOUBLE": ["0x1011100x1xxxxx110001xxxxxxxxxx"]
        },
        "FMAXNMV_advsimd": {
          "HALF": ["0x00111000110000110010xxxxxxxxxx"],
          "SINGLE_AND_DOUBLE": ["0x1011100x110000110010xxxxxxxxxx"]
        },
        "FMAXNM_advsimd": {
          "HALF": ["0x001110010xxxxx000001xxxxxxxxxx"],
          "SINGLE_AND_DOUBLE": ["0x0011100x1xxxxx110001xxxxxxxxxx"]
        },
        "FMAXNM_float": {
          "FLOAT": ["00011110xx1xxxxx011010xxxxxxxxxx"]
        },
        "FMAXP_advsimd_pair": {
          "HALF": ["010111100x110000111110xxxxxxxxxx"],
          "SINGLE_AND_DOUBLE": ["011111100x110000111110xxxxxxxxxx"]
        },
        "FMAXP_advsimd_vec": {
          "HALF": ["0x101110010xxxxx001101xxxxxxxxxx"],
          "SINGLE_AND_DOUBLE": ["0x1011100x1xxxxx111101xxxxxxxxxx"]
        },
        "FMAXV_advsimd": {
          "HALF": ["0x00111000110000111110xxxxxxxxxx"],
          "SINGLE_AND_DOUBLE": ["0x1011100x110000111110xxxxxxxxxx"]
        },
        "FMAX_advsimd": {
          "HALF": ["0x001110010xxxxx001101xxxxxxxxxx"],
          "SINGLE_AND_DOUBLE": ["0x0011100x1xxxxx111101xxxxxxxxxx"]
        },
        "FMAX_float": {
          "FLOAT": ["00011110xx1xxxxx010010xxxxxxxxxx"]
        },
        "FMINNMP_advsimd_pair": {
          "HALF": ["010111101x110000110010xxxxxxxxxx"],
          "SINGLE_AND_DOUBLE": ["011111101x110000110010xxxxxxxxxx"]
        },
        "FMINNMP_advsimd_vec": {
          "HALF": ["0x101110110xxxxx000001xxxxxxxxxx"],
          "SINGLE_AND_DOUBLE": ["0x1011101x1xxxxx110001xxxxxxxxxx"]
        },
        "FMINNMV_advsimd": {
          "HALF": ["0x00111010110000110010xxxxxxxxxx"],
          "SINGLE_AND_DOUBLE": ["0x1011101x110000110010xxxxxxxxxx"]
        },
        "FMINNM_advsimd": {
          "HALF": ["0x001110110xxxxx000001xxxxxxxxxx"],
          "SINGLE_AND_DOUBLE": ["0x0011101x1xxxxx110001xxxxxxxxxx"]
        },
        "FMINNM_float": {
          "FLOAT": ["00011110xx1xxxxx011110xxxxxxxxxx"]
        },
        "FMINP_advsimd_pair": {
          "HALF": ["010111101x110000111110xxxxxxxxxx"],
          "SINGLE_AND_DOUBLE": ["011111101x110000111110xxxxxxxxxx"]
        },
        "FMINP_advsimd_vec": {
          "HALF": ["0x101110110xxxxx001101xxxxxxxxxx"],
          "SINGLE_AND_DOUBLE": ["0x1011101x1xxxxx111101xxxxxxxxxx"]
        },
        "FMINV_advsimd": {
          "HALF": ["0x00111010110000111110xxxxxxxxxx"],
          "SINGLE_AND_DOUBLE": ["0x1011101x110000111110xxxxxxxxxx"]
        },
        "FMIN_advsimd": {
          "HALF": ["0x001110110xxxxx001101xxxxxxxxxx"],
          "SINGLE_AND_DOUBLE": ["0x0011101x1xxxxx111101xxxxxxxxxx"]
        },
        "FMIN_float": {
          "FLOAT": ["00011110xx1xxxxx010110xxxxxxxxxx"]
        },
        "FMLAL_advsimd_elt": {
          "FMLAL": ["0x00111110xxxxxx0000x0xxxxxxxxxx"],
          "FMLAL2": ["0x10111110xxxxxx1000x0xxxxxxxxxx"]
        },
        "FMLAL_advsimd_vec": {
          "FMLAL": ["0x001110001xxxxx111011xxxxxxxxxx"],
          "FMLAL2": ["0x101110001xxxxx110011xxxxxxxxxx"]
        },
        "FMLA_advsimd_elt": {
          "2REG_ELEMENT_HALF": ["0x00111100xxxxxx0001x0xxxxxxxxxx"],
          "2REG_ELEMENT_SINGLE_AND_DOUBLE": ["0x0011111xxxxxxx0001x0xxxxxxxxxx"],
          "2REG_SCALAR_HALF": ["0101111100xxxxxx0001x0xxxxxxxxxx"],
          "2REG_SCALAR_SINGLE_AND_DOUBLE": ["010111111xxxxxxx0001x0xxxxxxxxxx"]
        },
        "FMLA_advsimd_vec": {
          "HALF": ["0x001110010xxxxx000011xxxxxxxxxx"],
          "SINGLE_AND_DOUBLE": ["0x0011100x1xxxxx110011xxxxxxxxxx"]
        },
        "FMLSL_advsimd_elt": {
          "FMLSL": ["0x00111110xxxxxx0100x0xxxxxxxxxx"],
          "FMLSL2": ["0x10111110xxxxxx1100x0xxxxxxxxxx"]
        },
        "FMLSL_advsimd_vec": {
          "FMLSL": ["0x001110101xxxxx111011xxxxxxxxxx"],
          "FMLSL2": ["0x101110101xxxxx110011xxxxxxxxxx"]
        },
        "FMLS_advsimd_elt": {
          "2REG_ELEMENT_HALF": ["0x00111100xxxxxx0101x0xxxxxxxxxx"],
          "2REG_ELEMENT_SINGLE_AND_DOUBLE": ["0x0011111xxxxxxx0101x0xxxxxxxxxx"],
          "2REG_SCALAR_HALF": ["0101111100xxxxxx0101x0xxxxxxxxxx"],
          "2REG_SCALAR_SINGLE_AND_DOUBLE": ["010111111xxxxxxx0101x0xxxxxxxxxx"]
        },
        "FMLS_advsimd_vec": {
          "HALF": ["0x001110110xxxxx000011xxxxxxxxxx"],
          "SINGLE_AND_DOUBLE": ["0x0011101x1xxxxx110011xxxxxxxxxx"]
        },
        "FMOV_advsimd": {
          "PER_HALF": ["0x00111100000xxx111111xxxxxxxxxx"],
          "SINGLE_AND_DOUBLE": ["0xx0111100000xxx111101xxxxxxxxxx"]
        },
        "FMOV_float": {
          "FLOAT": ["00011110xx100000010000xxxxxxxxxx"]
        },
        "FMOV_float_gen": {
          "FLOAT": ["x0011110xx10x11x000000xxxxxxxxxx"]
        },
        "FMOV_float_imm": {
          "IMM8F": ["00011110xx1xxxxxxxx10000000xxxxx"]
        },
        "FMSUB_float": {
          "FLOAT": ["00011111xx0xxxxx1xxxxxxxxxxxxxxx"]
        },
        "FMULX_advsimd_elt": {
          "2REG_ELEMENT_HALF": ["0x10111100xxxxxx1001x0xxxxxxxxxx"],
          "2REG_ELEMENT_SINGLE_AND_DOUBLE": ["0x1011111xxxxxxx1001x0xxxxxxxxxx"],
          "2REG_SCALAR_HALF": ["0111111100xxxxxx1001x0xxxxxxxxxx"],
          "2REG_SCALAR_SINGLE_AND_DOUBLE": ["011111111xxxxxxx1001x0xxxxxxxxxx"]
        },
        "FMULX_advsimd_vec": {
          "SIMD_HALF": ["0x001110010xxxxx000111xxxxxxxxxx"],
          "SIMD_SINGLE_AND_DOUBLE": ["0x0011100x1xxxxx110111xxxxxxxxxx"],
          "SISD_HALF": ["01011110010xxxxx000111xxxxxxxxxx"],
          "SISD_SINGLE_AND_DOUBLE": ["010111100x1xxxxx110111xxxxxxxxxx"]
        },
        "FMUL_advsimd_elt": {
          "2REG_ELEMENT_HALF": ["0x00111100xxxxxx1001x0xxxxxxxxxx"],
          "2REG_ELEMENT_SINGLE_AND_DOUBLE": ["0x0011111xxxxxxx1001x0xxxxxxxxxx"],
          "2REG_SCALAR_HALF": ["0101111100xxxxxx1001x0xxxxxxxxxx"],
          "2REG_SCALAR_SINGLE_AND_DOUBLE": ["010111111xxxxxxx1001x0xxxxxxxxxx"]
        },
        "FMUL_advsimd_vec": {
          "HALF": ["0x101110010xxxxx000111xxxxxxxxxx"],
          "SINGLE_AND_DOUBLE": ["0x1011100x1xxxxx110111xxxxxxxxxx"]
        },
        "FMUL_float": {
          "FLOAT": ["00011110xx1xxxxx000010xxxxxxxxxx"]
        },
        "FNEG_advsimd": {
          "HALF": ["0x10111011111000111110xxxxxxxxxx"],
          "SINGLE_AND_DOUBLE": ["0x1011101x100000111110xxxxxxxxxx"]
        },
        "FNEG_float": {
          "FLOAT": ["00011110xx100001010000xxxxxxxxxx"]
        },
        "FNMADD_float": {
          "FLOAT": ["00011111xx1xxxxx0xxxxxxxxxxxxxxx"]
        },
        "FNMSUB_float": {
          "FLOAT": ["00011111xx1xxxxx1xxxxxxxxxxxxxxx"]
        },
        "FNMUL_float": {
          "FLOAT": ["00011110xx1xxxxx100010xxxxxxxxxx"]
        },
        "FRECPE_advsimd": {
          "SIMD_HALF": ["0x00111011111001110110xxxxxxxxxx"],
          "SIMD_SINGLE_AND_DOUBLE": ["0x0011101x100001110110xxxxxxxxxx"],
          "SISD_HALF": ["0101111011111001110110xxxxxxxxxx"],
          "SISD_SINGLE_AND_DOUBLE": ["010111101x100001110110xxxxxxxxxx"]
        },
        "FRECPS_advsimd": {
          "SIMD_HALF": ["0x001110010xxxxx001111xxxxxxxxxx"],
          "SIMD_SINGLE_AND_DOUBLE": ["0x0011100x1xxxxx111111xxxxxxxxxx"],
          "SISD_HALF": ["01011110010xxxxx001111xxxxxxxxxx"],
          "SISD_SINGLE_AND_DOUBLE": ["010111100x1xxxxx111111xxxxxxxxxx"]
        },
        "FRECPX_advsimd": {
          "HALF": ["0101111011111001111110xxxxxxxxxx"],
          "SINGLE_AND_DOUBLE": ["010111101x100001111110xxxxxxxxxx"]
        },
        "FRINT32X_advsimd": {
          "SIMD_SINGLE_AND_DOUBLE": ["0x1011100x100001111010xxxxxxxxxx"]
        },
        "FRINT32X_float": {
          "FLOAT": ["000111100x101000110000xxxxxxxxxx"]
        },
        "FRINT32Z_advsimd": {
          "SIMD_SINGLE_AND_DOUBLE": ["0x0011100x100001111010xxxxxxxxxx"]
        },
        "FRINT32Z_float": {
          "FLOAT": ["000111100x101000010000xxxxxxxxxx"]
        },
        "FRINT64X_advsimd": {
          "SIMD_SINGLE_AND_DOUBLE": ["0x1011100x100001111110xxxxxxxxxx"]
        },
        "FRINT64X_float": {
          "FLOAT": ["000111100x101001110000xxxxxxxxxx"]
        },
        "FRINT64Z_advsimd": {
          "SIMD_SINGLE_AND_DOUBLE": ["0x0011100x100001111110xxxxxxxxxx"]
        },
        "FRINT64Z_float": {
          "FLOAT": ["000111100x101001010000xxxxxxxxxx"]
        },
        "FRINTA_advsimd": {
          "HALF": ["0x10111001111001100010xxxxxxxxxx"],
          "SINGLE_AND_DOUBLE": ["0x1011100x100001100010xxxxxxxxxx"]
        },
        "FRINTA_float": {
          "FLOAT": ["00011110xx100110010000xxxxxxxxxx"]
        },
        "FRINTI_advsimd": {
          "HALF": ["0x10111011111001100110xxxxxxxxxx"],
          "SINGLE_AND_DOUBLE": ["0x1011101x100001100110xxxxxxxxxx"]
        },
        "FRINTI_float": {
          "FLOAT": ["00011110xx100111110000xxxxxxxxxx"]
        },
        "FRINTM_advsimd": {
          "HALF": ["0x00111001111001100110xxxxxxxxxx"],
          "SINGLE_AND_DOUBLE": ["0x0011100x100001100110xxxxxxxxxx"]
        },
        "FRINTM_float": {
          "FLOAT": ["00011110xx100101010000xxxxxxxxxx"]
        },
        "FRINTN_advsimd": {
          "HALF": ["0x00111001111001100010xxxxxxxxxx"],
          "SINGLE_AND_DOUBLE": ["0x0011100x100001100010xxxxxxxxxx"]
        },
        "FRINTN_float": {
          "FLOAT": ["00011110xx100100010000xxxxxxxxxx"]
        },
        "FRINTP_advsimd": {
          "HALF": ["0x00111011111001100010xxxxxxxxxx"],
          "SINGLE_AND_DOUBLE": ["0x0011101x100001100010xxxxxxxxxx"]
        },
        "FRINTP_float": {
          "FLOAT": ["00011110xx100100110000xxxxxxxxxx"]
        },
        "FRINTX_advsimd": {
          "HALF": ["0x10111001111001100110xxxxxxxxxx"],
          "SINGLE_AND_DOUBLE": ["0x1011100x100001100110xxxxxxxxxx"]
        },
        "FRINTX_float": {
          "FLOAT": ["00011110xx100111010000xxxxxxxxxx"]
        },
        "FRINTZ_advsimd": {
          "HALF": ["0x00111011111001100110xxxxxxxxxx"],
          "SINGLE_AND_DOUBLE": ["0x0011101x100001100110xxxxxxxxxx"]
        },
        "FRINTZ_float": {
          "FLOAT": ["00011110xx100101110000xxxxxxxxxx"]
        },
        "FRSQRTE_advsimd": {
          "SIMD_HALF": ["0x10111011111001110110xxxxxxxxxx"],
          "SIMD_SINGLE_AND_DOUBLE": ["0x1011101x100001110110xxxxxxxxxx"],
          "SISD_HALF": ["0111111011111001110110xxxxxxxxxx"],
          "SISD_SINGLE_AND_DOUBLE": ["011111101x100001110110xxxxxxxxxx"]
        },
        "FRSQRTS_advsimd": {
          "SIMD_HALF": ["0x001110110xxxxx001111xxxxxxxxxx"],
          "SIMD_SINGLE_AND_DOUBLE": ["0x0011101x1xxxxx111111xxxxxxxxxx"],
          "SISD_HALF": ["01011110110xxxxx001111xxxxxxxxxx"],
          "SISD_SINGLE_AND_DOUBLE": ["010111101x1xxxxx111111xxxxxxxxxx"]
        },
        "FSQRT_advsimd": {
          "HALF": ["0x10111011111001111110xxxxxxxxxx"],
          "SINGLE_AND_DOUBLE": ["0x1011101x100001111110xxxxxxxxxx"]
        },
        "FSQRT_float": {
          "FLOAT": ["00011110xx100001110000xxxxxxxxxx"]
        },
        "FSUB_advsimd": {
          "HALF": ["0x001110110xxxxx000101xxxxxxxxxx"],
          "SINGLE_AND_DOUBLE": ["0x0011101x1xxxxx110101xxxxxxxxxx"]
        },
        "FSUB_float": {
          "FLOAT": ["00011110xx1xxxxx001110xxxxxxxxxx"]
        },
        "GMI": {
          "GENERAL": ["10011010110xxxxx000101xxxxxxxxxx"]
        },
        "HINT": {
          "SYSTEM": ["11010101000000110010xxxxxxx11111"]
        },
        "HLT": {
          "SYSTEM": ["11010100010xxxxxxxxxxxxxxxx00000"]
        },
        "HVC": {
          "SYSTEM": ["11010100000xxxxxxxxxxxxxxxx00010"]
        },
        "IC_SYS": {
          "SYSTEM": ["1101010100001xxx0111xxxxxxxxxxxx"]
        },
        "INS_advsimd_elt": {
          "ADVSIMD": ["01101110000xxxxx0xxxx1xxxxxxxxxx"]
        },
        "INS_advsimd_gen": {
          "ADVSIMD": ["01001110000xxxxx000111xxxxxxxxxx"]
        },
        "IRG": {
          "GENERAL": ["10011010110xxxxx000100xxxxxxxxxx"]
        },
        "ISB": {
          "SYSTEM": ["11010101000000110011xxxx11011111"]
        },
        "LD1R_advsimd": {
          "AS_NO_POST_INDEX": ["0x001101010000001100xxxxxxxxxxxx"],
          "AS_POST_INDEX": ["0x001101110xxxxx1100xxxxxxxxxxxx"]
        },
        "LD1_advsimd_mult": {
          "AS_NO_POST_INDEX": ["0x00110001000000xx1xxxxxxxxxxxxx"],
          "AS_POST_INDEX": ["0x001100110xxxxxxx1xxxxxxxxxxxxx"]
        },
        "LD1_advsimd_sngl": {
          "AS_NO_POST_INDEX": ["0x00110101000000xx0xxxxxxxxxxxxx"],
          "AS_POST_INDEX": ["0x001101110xxxxxxx0xxxxxxxxxxxxx"]
        },
        "LD2R_advsimd": {
          "AS_NO_POST_INDEX": ["0x001101011000001100xxxxxxxxxxxx"],
          "AS_POST_INDEX": ["0x001101111xxxxx1100xxxxxxxxxxxx"]
        },
        "LD2_advsimd_mult": {
          "AS_NO_POST_INDEX": ["0x001100010000001000xxxxxxxxxxxx"],
          "AS_POST_INDEX": ["0x001100110xxxxx1000xxxxxxxxxxxx"]
        },
        "LD2_advsimd_sngl": {
          "AS_NO_POST_INDEX": ["0x00110101100000xx0xxxxxxxxxxxxx"],
          "AS_POST_INDEX": ["0x001101111xxxxxxx0xxxxxxxxxxxxx"]
        },
        "LD3R_advsimd": {
          "AS_NO_POST_INDEX": ["0x001101010000001110xxxxxxxxxxxx"],
          "AS_POST_INDEX": ["0x001101110xxxxx1110xxxxxxxxxxxx"]
        },
        "LD3_advsimd_mult": {
          "AS_NO_POST_INDEX": ["0x001100010000000100xxxxxxxxxxxx"],
          "AS_POST_INDEX": ["0x001100110xxxxx0100xxxxxxxxxxxx"]
        },
        "LD3_advsimd_sngl": {
          "AS_NO_POST_INDEX": ["0x00110101000000xx1xxxxxxxxxxxxx"],
          "AS_POST_INDEX": ["0x001101110xxxxxxx1xxxxxxxxxxxxx"]
        },
        "LD4R_advsimd": {
          "AS_NO_POST_INDEX": ["0x001101011000001110xxxxxxxxxxxx"],
          "AS_POST_INDEX": ["0x001101111xxxxx1110xxxxxxxxxxxx"]
        },
        "LD4_advsimd_mult": {
          "AS_NO_POST_INDEX": ["0x001100010000000000xxxxxxxxxxxx"],
          "AS_POST_INDEX": ["0x001100110xxxxx0000xxxxxxxxxxxx"]
        },
        "LD4_advsimd_sngl": {
          "AS_NO_POST_INDEX": ["0x00110101100000xx1xxxxxxxxxxxxx"],
          "AS_POST_INDEX": ["0x001101111xxxxxxx1xxxxxxxxxxxxx"]
        },
        "LD64B": {
          "GENERAL": ["1111100000111111110100xxxxxxxxxx"]
        },
        "LDADD": {
          "GENERAL": ["1x111000xx1xxxxx000000xxxxxxxxxx"]
        },
        "LDADDB": {
          "GENERAL": ["00111000xx1xxxxx000000xxxxxxxxxx"]
        },
        "LDADDH": {
          "GENERAL": ["01111000xx1xxxxx000000xxxxxxxxxx"]
        },
        "LDAPR": {
          "GENERAL": ["1x11100010111111110000xxxxxxxxxx"]
        },
        "LDAPRB": {
          "GENERAL": ["0011100010111111110000xxxxxxxxxx"]
        },
        "LDAPRH": {
          "GENERAL": ["0111100010111111110000xxxxxxxxxx"]
        },
        "LDAPURB": {
          "BASE_PLUS_OFFSET": ["00011001010xxxxxxxxx00xxxxxxxxxx"]
        },
        "LDAPURH": {
          "BASE_PLUS_OFFSET": ["01011001010xxxxxxxxx00xxxxxxxxxx"]
        },
        "LDAPURSB": {
          "BASE_PLUS_OFFSET": ["000110011x0xxxxxxxxx00xxxxxxxxxx"]
        },
        "LDAPURSH": {
          "BASE_PLUS_OFFSET": ["010110011x0xxxxxxxxx00xxxxxxxxxx"]
        },
        "LDAPURSW": {
          "BASE_PLUS_OFFSET": ["10011001100xxxxxxxxx00xxxxxxxxxx"]
        },
        "LDAPUR_gen": {
          "BASE_PLUS_OFFSET": ["1x011001010xxxxxxxxx00xxxxxxxxxx"]
        },
        "LDAR": {
          "BASE_REGISTER": ["1x00100011011111111111xxxxxxxxxx"]
        },
        "LDARB": {
          "BASE_REGISTER": ["0000100011011111111111xxxxxxxxxx"]
        },
        "LDARH": {
          "BASE_REGISTER": ["0100100011011111111111xxxxxxxxxx"]
        },
        "LDAXP": {
          "BASE_REGISTER": ["1x001000011111111xxxxxxxxxxxxxxx"]
        },
        "LDAXR": {
          "BASE_REGISTER": ["1x00100001011111111111xxxxxxxxxx"]
        },
        "LDAXRB": {
          "BASE_REGISTER": ["0000100001011111111111xxxxxxxxxx"]
        },
        "LDAXRH": {
          "BASE_REGISTER": ["0100100001011111111111xxxxxxxxxx"]
        },
        "LDCLR": {
          "GENERAL": ["1x111000xx1xxxxx000100xxxxxxxxxx"]
        },
        "LDCLRB": {
          "GENERAL": ["00111000xx1xxxxx000100xxxxxxxxxx"]
        },
        "LDCLRH": {
          "GENERAL": ["01111000xx1xxxxx000100xxxxxxxxxx"]
        },
        "LDEOR": {
          "GENERAL": ["1x111000xx1xxxxx001000xxxxxxxxxx"]
        },
        "LDEORB": {
          "GENERAL": ["00111000xx1xxxxx001000xxxxxxxxxx"]
        },
        "LDEORH": {
          "GENERAL": ["01111000xx1xxxxx001000xxxxxxxxxx"]
        },
        "LDG": {
          "GENERAL": ["11011001011xxxxxxxxx00xxxxxxxxxx"]
        },
        "LDGM": {
          "GENERAL": ["1101100111100000000000xxxxxxxxxx"]
        },
        "LDLAR": {
          "BASE_REGISTER": ["1x00100011011111011111xxxxxxxxxx"]
        },
        "LDLARB": {
          "BASE_REGISTER": ["0000100011011111011111xxxxxxxxxx"]
        },
        "LDLARH": {
          "BASE_REGISTER": ["0100100011011111011111xxxxxxxxxx"]
        },
        "LDNP_fpsimd": {
          "SIGNED_SCALED_OFFSET": ["xx10110001xxxxxxxxxxxxxxxxxxxxxx"]
        },
        "LDNP_gen": {
          "SIGNED_SCALED_OFFSET": ["x010100001xxxxxxxxxxxxxxxxxxxxxx"]
        },
        "LDPSW": {
          "POST_INDEXED": ["0110100011xxxxxxxxxxxxxxxxxxxxxx"],
          "PRE_INDEXED": ["0110100111xxxxxxxxxxxxxxxxxxxxxx"],
          "SIGNED_SCALED_OFFSET": ["0110100101xxxxxxxxxxxxxxxxxxxxxx"]
        },
        "LDP_fpsimd": {
          "POST_INDEXED": ["xx10110011xxxxxxxxxxxxxxxxxxxxxx"],
          "PRE_INDEXED": ["xx10110111xxxxxxxxxxxxxxxxxxxxxx"],
          "SIGNED_SCALED_OFFSET": ["xx10110101xxxxxxxxxxxxxxxxxxxxxx"]
        },
        "LDP_gen": {
          "POST_INDEXED": ["x010100011xxxxxxxxxxxxxxxxxxxxxx"],
          "PRE_INDEXED": ["x010100111xxxxxxxxxxxxxxxxxxxxxx"],
          "SIGNED_SCALED_OFFSET": ["x010100101xxxxxxxxxxxxxxxxxxxxxx"]
        },
        "LDRA": {
          "BASE_PLUS_OFFSET": ["11111000xx1xxxxxxxxxx1xxxxxxxxxx"]
        },
        "LDRB_imm": {
          "POST_INDEXED": ["00111000010xxxxxxxxx01xxxxxxxxxx"],
          "PRE_INDEXED": ["00111000010xxxxxxxxx11xxxxxxxxxx"],
          "UNSIGNED_SCALED_OFFSET": ["0011100101xxxxxxxxxxxxxxxxxxxxxx"]
        },
        "LDRB_reg": {
          "32": ["00111000011xxxxxxxxx10xxxxxxxxxx"]
        },
        "LDRH_imm": {
          "POST_INDEXED": ["01111000010xxxxxxxxx01xxxxxxxxxx"],
          "PRE_INDEXED": ["01111000010xxxxxxxxx11xxxxxxxxxx"],
          "UNSIGNED_SCALED_OFFSET": ["0111100101xxxxxxxxxxxxxxxxxxxxxx"]
        },
        "LDRH_reg": {
          "32": ["01111000011xxxxxxxxx10xxxxxxxxxx"]
        },
        "LDRSB_imm": {
          "POST_INDEXED": ["001110001x0xxxxxxxxx01xxxxxxxxxx"],
          "PRE_INDEXED": ["001110001x0xxxxxxxxx11xxxxxxxxxx"],
          "UNSIGNED_SCALED_OFFSET": ["001110011xxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "LDRSB_reg": {
          "GENERAL": ["001110001x1xxxxxxxxx10xxxxxxxxxx"]
        },
        "LDRSH_imm": {
          "POST_INDEXED": ["011110001x0xxxxxxxxx01xxxxxxxxxx"],
          "PRE_INDEXED": ["011110001x0xxxxxxxxx11xxxxxxxxxx"],
          "UNSIGNED_SCALED_OFFSET": ["011110011xxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "LDRSH_reg": {
          "GENERAL": ["011110001x1xxxxxxxxx10xxxxxxxxxx"]
        },
        "LDRSW_imm": {
          "POST_INDEXED": ["10111000100xxxxxxxxx01xxxxxxxxxx"],
          "PRE_INDEXED": ["10111000100xxxxxxxxx11xxxxxxxxxx"],
          "UNSIGNED_SCALED_OFFSET": ["1011100110xxxxxxxxxxxxxxxxxxxxxx"]
        },
        "LDRSW_lit": {
          "LITERAL": ["10011000xxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "LDRSW_reg": {
          "64": ["10111000101xxxxxxxxx10xxxxxxxxxx"]
        },
        "LDR_imm_fpsimd": {
          "POST_INDEXED": ["xx111100x10xxxxxxxxx01xxxxxxxxxx"],
          "PRE_INDEXED": ["xx111100x10xxxxxxxxx11xxxxxxxxxx"],
          "UNSIGNED_SCALED_OFFSET": ["xx111101x1xxxxxxxxxxxxxxxxxxxxxx"]
        },
        "LDR_imm_gen": {
          "POST_INDEXED": ["1x111000010xxxxxxxxx01xxxxxxxxxx"],
          "PRE_INDEXED": ["1x111000010xxxxxxxxx11xxxxxxxxxx"],
          "UNSIGNED_SCALED_OFFSET": ["1x11100101xxxxxxxxxxxxxxxxxxxxxx"]
        },
        "LDR_lit_fpsimd": {
          "LITERAL": ["xx011100xxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "LDR_lit_gen": {
          "LITERAL": ["0x011000xxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "LDR_reg_fpsimd": {
          "FPSIMD": ["xx111100x11xxxxxxxxx10xxxxxxxxxx"]
        },
        "LDR_reg_gen": {
          "GENERAL": ["1x111000011xxxxxxxxx10xxxxxxxxxx"]
        },
        "LDSET": {
          "GENERAL": ["1x111000xx1xxxxx001100xxxxxxxxxx"]
        },
        "LDSETB": {
          "GENERAL": ["00111000xx1xxxxx001100xxxxxxxxxx"]
        },
        "LDSETH": {
          "GENERAL": ["01111000xx1xxxxx001100xxxxxxxxxx"]
        },
        "LDSMAX": {
          "GENERAL": ["1x111000xx1xxxxx010000xxxxxxxxxx"]
        },
        "LDSMAXB": {
          "GENERAL": ["00111000xx1xxxxx010000xxxxxxxxxx"]
        },
        "LDSMAXH": {
          "GENERAL": ["01111000xx1xxxxx010000xxxxxxxxxx"]
        },
        "LDSMIN": {
          "GENERAL": ["1x111000xx1xxxxx010100xxxxxxxxxx"]
        },
        "LDSMINB": {
          "GENERAL": ["00111000xx1xxxxx010100xxxxxxxxxx"]
        },
        "LDSMINH": {
          "GENERAL": ["01111000xx1xxxxx010100xxxxxxxxxx"]
        },
        "LDTR": {
          "BASE_PLUS_OFFSET": ["1x111000010xxxxxxxxx10xxxxxxxxxx"]
        },
        "LDTRB": {
          "BASE_PLUS_OFFSET": ["00111000010xxxxxxxxx10xxxxxxxxxx"]
        },
        "LDTRH": {
          "BASE_PLUS_OFFSET": ["01111000010xxxxxxxxx10xxxxxxxxxx"]
        },
        "LDTRSB": {
          "BASE_PLUS_OFFSET": ["001110001x0xxxxxxxxx10xxxxxxxxxx"]
        },
        "LDTRSH": {
          "BASE_PLUS_OFFSET": ["011110001x0xxxxxxxxx10xxxxxxxxxx"]
        },
        "LDTRSW": {
          "BASE_PLUS_OFFSET": ["10111000100xxxxxxxxx10xxxxxxxxxx"]
        },
        "LDUMAX": {
          "GENERAL": ["1x111000xx1xxxxx011000xxxxxxxxxx"]
        },
        "LDUMAXB": {
          "GENERAL": ["00111000xx1xxxxx011000xxxxxxxxxx"]
        },
        "LDUMAXH": {
          "GENERAL": ["01111000xx1xxxxx011000xxxxxxxxxx"]
        },
        "LDUMIN": {
          "GENERAL": ["1x111000xx1xxxxx011100xxxxxxxxxx"]
        },
        "LDUMINB": {
          "GENERAL": ["00111000xx1xxxxx011100xxxxxxxxxx"]
        },
        "LDUMINH": {
          "GENERAL": ["01111000xx1xxxxx011100xxxxxxxxxx"]
        },
        "LDURB": {
          "BASE_PLUS_OFFSET": ["00111000010xxxxxxxxx00xxxxxxxxxx"]
        },
        "LDURH": {
          "BASE_PLUS_OFFSET": ["01111000010xxxxxxxxx00xxxxxxxxxx"]
        },
        "LDURSB": {
          "BASE_PLUS_OFFSET": ["001110001x0xxxxxxxxx00xxxxxxxxxx"]
        },
        "LDURSH": {
          "BASE_PLUS_OFFSET": ["011110001x0xxxxxxxxx00xxxxxxxxxx"]
        },
        "LDURSW": {
          "BASE_PLUS_OFFSET": ["10111000100xxxxxxxxx00xxxxxxxxxx"]
        },
        "LDUR_fpsimd": {
          "BASE_PLUS_OFFSET": ["xx111100x10xxxxxxxxx00xxxxxxxxxx"]
        },
        "LDUR_gen": {
          "BASE_PLUS_OFFSET": ["1x111000010xxxxxxxxx00xxxxxxxxxx"]
        },
        "LDXP": {
          "BASE_REGISTER": ["1x001000011111110xxxxxxxxxxxxxxx"]
        },
        "LDXR": {
          "BASE_REGISTER": ["1x00100001011111011111xxxxxxxxxx"]
        },
        "LDXRB": {
          "BASE_REGISTER": ["0000100001011111011111xxxxxxxxxx"]
        },
        "LDXRH": {
          "BASE_REGISTER": ["0100100001011111011111xxxxxxxxxx"]
        },
        "LSLV": {
          "GENERAL": ["x0011010110xxxxx001000xxxxxxxxxx"]
        },
        "LSL_LSLV": {
          "GENERAL": ["x0011010110xxxxx001000xxxxxxxxxx"]
        },
        "LSL_UBFM": {
          "ZERO_FILL": ["x10100110xxxxxxxxxxxxxxxxxxxxxxx", "xxxxxxxxxxxxxxxxx11111xxxxxxxxxx"]
        },
        "LSRV": {
          "GENERAL": ["x0011010110xxxxx001001xxxxxxxxxx"]
        },
        "LSR_LSRV": {
          "GENERAL": ["x0011010110xxxxx001001xxxxxxxxxx"]
        },
        "LSR_UBFM": {
          "ZERO_FILL": ["x10100110xxxxxxxx11111xxxxxxxxxx"]
        },
        "MADD": {
          "GENERAL": ["x0011011000xxxxx0xxxxxxxxxxxxxxx"]
        },
        "MLA_advsimd_elt": {
          "2REG_ELEMENT": ["0x101111xxxxxxxx0000x0xxxxxxxxxx"]
        },
        "MLA_advsimd_vec": {
          "3REG_SAME": ["0x001110xx1xxxxx100101xxxxxxxxxx"]
        },
        "MLS_advsimd_elt": {
          "2REG_ELEMENT": ["0x101111xxxxxxxx0100x0xxxxxxxxxx"]
        },
        "MLS_advsimd_vec": {
          "3REG_SAME": ["0x101110xx1xxxxx100101xxxxxxxxxx"]
        },
        "MNEG_MSUB": {
          "GENERAL": ["x0011011000xxxxx111111xxxxxxxxxx"]
        },
        "MOVI_advsimd": {
          "ADVSIMD": ["0xx0111100000xxxxxxx01xxxxxxxxxx"]
        },
        "MOVK": {
          "IMM18_PACKED": ["x11100101xxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "MOVN": {
          "IMM18_PACKED": ["x00100101xxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "MOVZ": {
          "IMM18_PACKED": ["x10100101xxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "MOV_ADD_addsub_imm": {
          "NO_S": ["x001000100000000000000xxxxxxxxxx"]
        },
        "MOV_DUP_advsimd_elt": {
          "SCALAR_FROM_ELEMENT": ["01011110000xxxxx000001xxxxxxxxxx"]
        },
        "MOV_INS_advsimd_elt": {
          "ADVSIMD": ["01101110000xxxxx0xxxx1xxxxxxxxxx"]
        },
        "MOV_INS_advsimd_gen": {
          "ADVSIMD": ["01001110000xxxxx000111xxxxxxxxxx"]
        },
        "MOV_MOVN": {
          "IMM18_PACKED": ["x00100101xxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "MOV_MOVZ": {
          "IMM18_PACKED": ["x10100101xxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "MOV_ORR_advsimd_reg": {
          "3REG_SAME": ["0x001110101xxxxx000111xxxxxxxxxx"]
        },
        "MOV_ORR_log_imm": {
          "NO_S": ["x01100100xxxxxxxxxxxxx11111xxxxx"]
        },
        "MOV_ORR_log_shift": {
          "NO_S": ["x0101010000xxxxx00000011111xxxxx"]
        },
        "MOV_UMOV_advsimd": {
          "ADVSIMD": ["0x001110000xxx00001111xxxxxxxxxx"]
        },
        "MRS": {
          "SYSTEM": ["110101010011xxxxxxxxxxxxxxxxxxxx"]
        },
        "MSR_imm": {
          "SYSTEM": ["1101010100000xxx0100xxxxxxx11111"]
        },
        "MSR_reg": {
          "SYSTEM": ["110101010001xxxxxxxxxxxxxxxxxxxx"]
        },
        "MSUB": {
          "GENERAL": ["x0011011000xxxxx1xxxxxxxxxxxxxxx"]
        },
        "MUL_MADD": {
          "GENERAL": ["x0011011000xxxxx011111xxxxxxxxxx"]
        },
        "MUL_advsimd_elt": {
          "2REG_ELEMENT": ["0x001111xxxxxxxx1000x0xxxxxxxxxx"]
        },
        "MUL_advsimd_vec": {
          "3REG_SAME": ["0x001110xx1xxxxx100111xxxxxxxxxx"]
        },
        "MVNI_advsimd": {
          "ADVSIMD": ["0x10111100000xxxxxxx01xxxxxxxxxx"]
        },
        "MVN_NOT_advsimd": {
          "SIMD": ["0x10111000100000010110xxxxxxxxxx"]
        },
        "MVN_ORN_log_shift": {
          "NO_S": ["x0101010xx1xxxxxxxxxxx11111xxxxx"]
        },
        "NEGS_SUBS_addsub_shift": {
          "S": ["x1101011xx0xxxxxxxxxxx11111xxxxx", "xxxxxxxxxxxxxxxxxxxxxxxxxxx11111"]
        },
        "NEG_SUB_addsub_shift": {
          "NO_S": ["x1001011xx0xxxxxxxxxxx11111xxxxx"]
        },
        "NEG_advsimd": {
          "SIMD": ["0x101110xx100000101110xxxxxxxxxx"],
          "SISD": ["01111110xx100000101110xxxxxxxxxx"]
        },
        "NGCS_SBCS": {
          "S": ["x1111010000xxxxx00000011111xxxxx"]
        },
        "NGC_SBC": {
          "NO_S": ["x1011010000xxxxx00000011111xxxxx"]
        },
        "NOP": {
          "SYSTEM": ["11010101000000110010000000011111"]
        },
        "NOT_advsimd": {
          "SIMD": ["0x10111000100000010110xxxxxxxxxx"]
        },
        "ORN_advsimd": {
          "3REG_SAME": ["0x001110111xxxxx000111xxxxxxxxxx"]
        },
        "ORN_log_shift": {
          "NO_S": ["x0101010xx1xxxxxxxxxxxxxxxxxxxxx"]
        },
        "ORR_advsimd_imm": {
          "SHIFTED_IMMEDIATE": ["0x00111100000xxxxxx101xxxxxxxxxx"]
        },
        "ORR_advsimd_reg": {
          "3REG_SAME": ["0x001110101xxxxx000111xxxxxxxxxx"]
        },
        "ORR_log_imm": {
          "NO_S": ["x01100100xxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "ORR_log_shift": {
          "NO_S": ["x0101010xx0xxxxxxxxxxxxxxxxxxxxx"]
        },
        "PACDA": {
          "GENERAL": ["110110101100000100x010xxxxxxxxxx"]
        },
        "PACDB": {
          "GENERAL": ["110110101100000100x011xxxxxxxxxx"]
        },
        "PACGA": {
          "GENERAL": ["10011010110xxxxx001100xxxxxxxxxx"]
        },
        "PACIA": {
          "GENERAL": ["110110101100000100x000xxxxxxxxxx"],
          "SYSTEM": ["1101010100000011001000x100x11111"]
        },
        "PACIB": {
          "GENERAL": ["110110101100000100x001xxxxxxxxxx"],
          "SYSTEM": ["1101010100000011001000x101x11111"]
        },
        "PMULL_advsimd": {
          "3REG_DIFF": ["0x001110xx1xxxxx111000xxxxxxxxxx"]
        },
        "PMUL_advsimd": {
          "3REG_SAME": ["0x101110xx1xxxxx100111xxxxxxxxxx"]
        },
        "PRFM_imm": {
          "UNSIGNED_SCALED_OFFSET": ["1111100110xxxxxxxxxxxxxxxxxxxxxx"]
        },
        "PRFM_lit": {
          "LITERAL": ["11011000xxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "PRFM_reg": {
          "GENERAL": ["11111000101xxxxxxxxx10xxxxxxxxxx"]
        },
        "PRFUM": {
          "BASE_PLUS_OFFSET": ["11111000100xxxxxxxxx00xxxxxxxxxx"]
        },
        "PSB": {
          "SYSTEM": ["11010101000000110010001000111111"]
        },
        "PSSBB": {
          "SYSTEM": ["11010101000000110011010010011111"]
        },
        "RADDHN_advsimd": {
          "3REG_DIFF": ["0x101110xx1xxxxx010000xxxxxxxxxx"]
        },
        "RAX1_advsimd": {
          "ADVSIMD": ["11001110011xxxxx100011xxxxxxxxxx"]
        },
        "RBIT_advsimd": {
          "SIMD": ["0x10111001100000010110xxxxxxxxxx"]
        },
        "RBIT_int": {
          "GENERAL": ["x101101011000000000000xxxxxxxxxx"]
        },
        "RET": {
          "GENERAL": ["1101011001011111000000xxxxx00000"]
        },
        "RETA": {
          "GENERAL": ["110101100101111100001x1111111111"]
        },
        "REV": {
          "GENERAL": ["x10110101100000000001xxxxxxxxxxx"]
        },
        "REV16_advsimd": {
          "SIMD": ["0x001110xx100000000110xxxxxxxxxx"]
        },
        "REV16_int": {
          "GENERAL": ["x101101011000000000001xxxxxxxxxx"]
        },
        "REV32_advsimd": {
          "SIMD": ["0x101110xx100000000010xxxxxxxxxx"]
        },
        "REV32_int": {
          "64": ["1101101011000000000010xxxxxxxxxx"]
        },
        "REV64_REV": {
          "GENERAL": ["1101101011000000000011xxxxxxxxxx"]
        },
        "REV64_advsimd": {
          "SIMD": ["0x001110xx100000000010xxxxxxxxxx"]
        },
        "RMIF": {
          "GENERAL": ["10111010000xxxxxx00001xxxxx0xxxx"]
        },
        "RORV": {
          "GENERAL": ["x0011010110xxxxx001011xxxxxxxxxx"]
        },
        "ROR_EXTR": {
          "GENERAL": ["x00100111x0xxxxxxxxxxxxxxxxxxxxx"]
        },
        "ROR_RORV": {
          "GENERAL": ["x0011010110xxxxx001011xxxxxxxxxx"]
        },
        "RSHRN_advsimd": {
          "SIMD": ["0x0011110xxxxxxx100011xxxxxxxxxx", "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"]
        },
        "RSUBHN_advsimd": {
          "3REG_DIFF": ["0x101110xx1xxxxx011000xxxxxxxxxx"]
        },
        "SABAL_advsimd": {
          "3REG_DIFF": ["0x001110xx1xxxxx010100xxxxxxxxxx"]
        },
        "SABA_advsimd": {
          "3REG_SAME": ["0x001110xx1xxxxx011111xxxxxxxxxx"]
        },
        "SABDL_advsimd": {
          "3REG_DIFF": ["0x001110xx1xxxxx011100xxxxxxxxxx"]
        },
        "SABD_advsimd": {
          "3REG_SAME": ["0x001110xx1xxxxx011101xxxxxxxxxx"]
        },
        "SADALP_advsimd": {
          "SIMD": ["0x001110xx100000011010xxxxxxxxxx"]
        },
        "SADDLP_advsimd": {
          "SIMD": ["0x001110xx100000001010xxxxxxxxxx"]
        },
        "SADDLV_advsimd": {
          "ADVSIMD": ["0x001110xx110000001110xxxxxxxxxx"]
        },
        "SADDL_advsimd": {
          "3REG_DIFF": ["0x001110xx1xxxxx000000xxxxxxxxxx"]
        },
        "SADDW_advsimd": {
          "3REG_DIFF": ["0x001110xx1xxxxx000100xxxxxxxxxx"]
        },
        "SB": {
          "SYSTEM": ["11010101000000110011000011111111"]
        },
        "SBC": {
          "NO_S": ["x1011010000xxxxx000000xxxxxxxxxx"]
        },
        "SBCS": {
          "S": ["x1111010000xxxxx000000xxxxxxxxxx"]
        },
        "SBFIZ_SBFM": {
          "SIGNED_FILL": ["x00100110xxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "SBFM": {
          "SIGNED_FILL": ["x00100110xxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "SBFX_SBFM": {
          "SIGNED_FILL": ["x00100110xxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "SCVTF_advsimd_fix": {
          "SIMD": ["0x0011110xxxxxxx111001xxxxxxxxxx", "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"],
          "SISD": ["010111110xxxxxxx111001xxxxxxxxxx", "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"]
        },
        "SCVTF_advsimd_int": {
          "SIMD_HALF": ["0x00111001111001110110xxxxxxxxxx"],
          "SIMD_SINGLE_AND_DOUBLE": ["0x0011100x100001110110xxxxxxxxxx"],
          "SISD_HALF": ["0101111001111001110110xxxxxxxxxx"],
          "SISD_SINGLE_AND_DOUBLE": ["010111100x100001110110xxxxxxxxxx"]
        },
        "SCVTF_float_fix": {
          "FLOAT": ["x0011110xx000010xxxxxxxxxxxxxxxx"]
        },
        "SCVTF_float_int": {
          "FLOAT": ["x0011110xx100010000000xxxxxxxxxx"]
        },
        "SDIV": {
          "GENERAL": ["x0011010110xxxxx000011xxxxxxxxxx"]
        },
        "SDOT_advsimd_elt": {
          "2REG_ELEMENT": ["0x001111xxxxxxxx1110x0xxxxxxxxxx"]
        },
        "SDOT_advsimd_vec": {
          "SIMD": ["0x001110xx0xxxxx100101xxxxxxxxxx"]
        },
        "SETF": {
          "GENERAL": ["00111010000000000x0010xxxxx01101"]
        },
        "SEV": {
          "SYSTEM": ["11010101000000110010000010011111"]
        },
        "SEVL": {
          "SYSTEM": ["11010101000000110010000010111111"]
        },
        "SHA1C_advsimd": {
          "ADVSIMD": ["01011110000xxxxx000000xxxxxxxxxx"]
        },
        "SHA1H_advsimd": {
          "ADVSIMD": ["0101111000101000000010xxxxxxxxxx"]
        },
        "SHA1M_advsimd": {
          "ADVSIMD": ["01011110000xxxxx001000xxxxxxxxxx"]
        },
        "SHA1P_advsimd": {
          "ADVSIMD": ["01011110000xxxxx000100xxxxxxxxxx"]
        },
        "SHA1SU0_advsimd": {
          "ADVSIMD": ["01011110000xxxxx001100xxxxxxxxxx"]
        },
        "SHA1SU1_advsimd": {
          "ADVSIMD": ["0101111000101000000110xxxxxxxxxx"]
        },
        "SHA256H2_advsimd": {
          "ADVSIMD": ["01011110000xxxxx010100xxxxxxxxxx"]
        },
        "SHA256H_advsimd": {
          "ADVSIMD": ["01011110000xxxxx010000xxxxxxxxxx"]
        },
        "SHA256SU0_advsimd": {
          "ADVSIMD": ["0101111000101000001010xxxxxxxxxx"]
        },
        "SHA256SU1_advsimd": {
          "ADVSIMD": ["01011110000xxxxx011000xxxxxxxxxx"]
        },
        "SHA512H2_advsimd": {
          "ADVSIMD": ["11001110011xxxxx100001xxxxxxxxxx"]
        },
        "SHA512H_advsimd": {
          "ADVSIMD": ["11001110011xxxxx100000xxxxxxxxxx"]
        },
        "SHA512SU0_advsimd": {
          "ADVSIMD": ["1100111011000000100000xxxxxxxxxx"]
        },
        "SHA512SU1_advsimd": {
          "ADVSIMD": ["11001110011xxxxx100010xxxxxxxxxx"]
        },
        "SHADD_advsimd": {
          "3REG_SAME": ["0x001110xx1xxxxx000001xxxxxxxxxx"]
        },
        "SHLL_advsimd": {
          "SIMD": ["0x101110xx100001001110xxxxxxxxxx"]
        },
        "SHL_advsimd": {
          "SIMD": ["0x0011110xxxxxxx010101xxxxxxxxxx", "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"],
          "SISD": ["010111110xxxxxxx010101xxxxxxxxxx", "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"]
        },
        "SHRN_advsimd": {
          "SIMD": ["0x0011110xxxxxxx100001xxxxxxxxxx", "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"]
        },
        "SHSUB_advsimd": {
          "3REG_SAME": ["0x001110xx1xxxxx001001xxxxxxxxxx"]
        },
        "SLI_advsimd": {
          "SIMD": ["0x1011110xxxxxxx010101xxxxxxxxxx", "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"],
          "SISD": ["011111110xxxxxxx010101xxxxxxxxxx", "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"]
        },
        "SM3PARTW1_advsimd": {
          "ADVSIMD": ["11001110011xxxxx110000xxxxxxxxxx"]
        },
        "SM3PARTW2_advsimd": {
          "ADVSIMD": ["11001110011xxxxx110001xxxxxxxxxx"]
        },
        "SM3SS1_advsimd": {
          "ADVSIMD": ["11001110010xxxxx0xxxxxxxxxxxxxxx"]
        },
        "SM3TT1A_advsimd": {
          "ADVSIMD": ["11001110010xxxxx10xx00xxxxxxxxxx"]
        },
        "SM3TT1B_advsimd": {
          "ADVSIMD": ["11001110010xxxxx10xx01xxxxxxxxxx"]
        },
        "SM3TT2A_advsimd": {
          "ADVSIMD": ["11001110010xxxxx10xx10xxxxxxxxxx"]
        },
        "SM3TT2B_advsimd": {
          "ADVSIMD": ["11001110010xxxxx10xx11xxxxxxxxxx"]
        },
        "SM4EKEY_advsimd": {
          "ADVSIMD": ["11001110011xxxxx110010xxxxxxxxxx"]
        },
        "SM4E_advsimd": {
          "ADVSIMD": ["1100111011000000100001xxxxxxxxxx"]
        },
        "SMADDL": {
          "64": ["10011011001xxxxx0xxxxxxxxxxxxxxx"]
        },
        "SMAXP_advsimd": {
          "3REG_SAME": ["0x001110xx1xxxxx101001xxxxxxxxxx"]
        },
        "SMAXV_advsimd": {
          "ADVSIMD": ["0x001110xx110000101010xxxxxxxxxx"]
        },
        "SMAX_advsimd": {
          "3REG_SAME": ["0x001110xx1xxxxx011001xxxxxxxxxx"]
        },
        "SMC": {
          "SYSTEM": ["11010100000xxxxxxxxxxxxxxxx00011"]
        },
        "SMINP_advsimd": {
          "3REG_SAME": ["0x001110xx1xxxxx101011xxxxxxxxxx"]
        },
        "SMINV_advsimd": {
          "ADVSIMD": ["0x001110xx110001101010xxxxxxxxxx"]
        },
        "SMIN_advsimd": {
          "3REG_SAME": ["0x001110xx1xxxxx011011xxxxxxxxxx"]
        },
        "SMLAL_advsimd_elt": {
          "2REG_ELEMENT": ["0x001111xxxxxxxx0010x0xxxxxxxxxx"]
        },
        "SMLAL_advsimd_vec": {
          "3REG_DIFF": ["0x001110xx1xxxxx100000xxxxxxxxxx"]
        },
        "SMLSL_advsimd_elt": {
          "2REG_ELEMENT": ["0x001111xxxxxxxx0110x0xxxxxxxxxx"]
        },
        "SMLSL_advsimd_vec": {
          "3REG_DIFF": ["0x001110xx1xxxxx101000xxxxxxxxxx"]
        },
        "SMMLA_advsimd_vec": {
          "SIMD": ["01001110100xxxxx101001xxxxxxxxxx"]
        },
        "SMNEGL_SMSUBL": {
          "64": ["10011011001xxxxx111111xxxxxxxxxx"]
        },
        "SMOV_advsimd": {
          "ADVSIMD": ["0x001110000xxxxx001011xxxxxxxxxx"]
        },
        "SMSUBL": {
          "64": ["10011011001xxxxx1xxxxxxxxxxxxxxx"]
        },
        "SMULH": {
          "64": ["10011011010xxxxx011111xxxxxxxxxx"]
        },
        "SMULL_SMADDL": {
          "64": ["10011011001xxxxx011111xxxxxxxxxx"]
        },
        "SMULL_advsimd_elt": {
          "2REG_ELEMENT": ["0x001111xxxxxxxx1010x0xxxxxxxxxx"]
        },
        "SMULL_advsimd_vec": {
          "3REG_DIFF": ["0x001110xx1xxxxx110000xxxxxxxxxx"]
        },
        "SQABS_advsimd": {
          "SIMD": ["0x001110xx100000011110xxxxxxxxxx"],
          "SISD": ["01011110xx100000011110xxxxxxxxxx"]
        },
        "SQADD_advsimd": {
          "SIMD": ["0x001110xx1xxxxx000011xxxxxxxxxx"],
          "SISD": ["01011110xx1xxxxx000011xxxxxxxxxx"]
        },
        "SQDMLAL_advsimd_elt": {
          "2REG_ELEMENT": ["0x001111xxxxxxxx0011x0xxxxxxxxxx"],
          "2REG_SCALAR": ["01011111xxxxxxxx0011x0xxxxxxxxxx"]
        },
        "SQDMLAL_advsimd_vec": {
          "SIMD": ["0x001110xx1xxxxx100100xxxxxxxxxx"],
          "SISD": ["01011110xx1xxxxx100100xxxxxxxxxx"]
        },
        "SQDMLSL_advsimd_elt": {
          "2REG_ELEMENT": ["0x001111xxxxxxxx0111x0xxxxxxxxxx"],
          "2REG_SCALAR": ["01011111xxxxxxxx0111x0xxxxxxxxxx"]
        },
        "SQDMLSL_advsimd_vec": {
          "SIMD": ["0x001110xx1xxxxx101100xxxxxxxxxx"],
          "SISD": ["01011110xx1xxxxx101100xxxxxxxxxx"]
        },
        "SQDMULH_advsimd_elt": {
          "2REG_ELEMENT": ["0x001111xxxxxxxx1100x0xxxxxxxxxx"],
          "2REG_SCALAR": ["01011111xxxxxxxx1100x0xxxxxxxxxx"]
        },
        "SQDMULH_advsimd_vec": {
          "SIMD": ["0x001110xx1xxxxx101101xxxxxxxxxx"],
          "SISD": ["01011110xx1xxxxx101101xxxxxxxxxx"]
        },
        "SQDMULL_advsimd_elt": {
          "2REG_ELEMENT": ["0x001111xxxxxxxx1011x0xxxxxxxxxx"],
          "2REG_SCALAR": ["01011111xxxxxxxx1011x0xxxxxxxxxx"]
        },
        "SQDMULL_advsimd_vec": {
          "SIMD": ["0x001110xx1xxxxx110100xxxxxxxxxx"],
          "SISD": ["01011110xx1xxxxx110100xxxxxxxxxx"]
        },
        "SQNEG_advsimd": {
          "SIMD": ["0x101110xx100000011110xxxxxxxxxx"],
          "SISD": ["01111110xx100000011110xxxxxxxxxx"]
        },
        "SQRDMLAH_advsimd_elt": {
          "2REG_ELEMENT": ["0x101111xxxxxxxx1101x0xxxxxxxxxx"],
          "2REG_SCALAR": ["01111111xxxxxxxx1101x0xxxxxxxxxx"]
        },
        "SQRDMLAH_advsimd_vec": {
          "SIMD": ["0x101110xx0xxxxx100001xxxxxxxxxx"],
          "SISD": ["01111110xx0xxxxx100001xxxxxxxxxx"]
        },
        "SQRDMLSH_advsimd_elt": {
          "2REG_ELEMENT": ["0x101111xxxxxxxx1111x0xxxxxxxxxx"],
          "2REG_SCALAR": ["01111111xxxxxxxx1111x0xxxxxxxxxx"]
        },
        "SQRDMLSH_advsimd_vec": {
          "SIMD": ["0x101110xx0xxxxx100011xxxxxxxxxx"],
          "SISD": ["01111110xx0xxxxx100011xxxxxxxxxx"]
        },
        "SQRDMULH_advsimd_elt": {
          "2REG_ELEMENT": ["0x001111xxxxxxxx1101x0xxxxxxxxxx"],
          "2REG_SCALAR": ["01011111xxxxxxxx1101x0xxxxxxxxxx"]
        },
        "SQRDMULH_advsimd_vec": {
          "SIMD": ["0x101110xx1xxxxx101101xxxxxxxxxx"],
          "SISD": ["01111110xx1xxxxx101101xxxxxxxxxx"]
        },
        "SQRSHL_advsimd": {
          "SIMD": ["0x001110xx1xxxxx010111xxxxxxxxxx"],
          "SISD": ["01011110xx1xxxxx010111xxxxxxxxxx"]
        },
        "SQRSHRN_advsimd": {
          "SIMD": ["0x0011110xxxxxxx100111xxxxxxxxxx", "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"],
          "SISD": ["010111110xxxxxxx100111xxxxxxxxxx", "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"]
        },
        "SQRSHRUN_advsimd": {
          "SIMD": ["0x1011110xxxxxxx100011xxxxxxxxxx", "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"],
          "SISD": ["011111110xxxxxxx100011xxxxxxxxxx", "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"]
        },
        "SQSHLU_advsimd": {
          "SIMD": ["0x1011110xxxxxxx011001xxxxxxxxxx", "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"],
          "SISD": ["011111110xxxxxxx011001xxxxxxxxxx", "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"]
        },
        "SQSHL_advsimd_imm": {
          "SIMD": ["0x0011110xxxxxxx011101xxxxxxxxxx", "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"],
          "SISD": ["010111110xxxxxxx011101xxxxxxxxxx", "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"]
        },
        "SQSHL_advsimd_reg": {
          "SIMD": ["0x001110xx1xxxxx010011xxxxxxxxxx"],
          "SISD": ["01011110xx1xxxxx010011xxxxxxxxxx"]
        },
        "SQSHRN_advsimd": {
          "SIMD": ["0x0011110xxxxxxx100101xxxxxxxxxx", "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"],
          "SISD": ["010111110xxxxxxx100101xxxxxxxxxx", "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"]
        },
        "SQSHRUN_advsimd": {
          "SIMD": ["0x1011110xxxxxxx100001xxxxxxxxxx", "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"],
          "SISD": ["011111110xxxxxxx100001xxxxxxxxxx", "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"]
        },
        "SQSUB_advsimd": {
          "SIMD": ["0x001110xx1xxxxx001011xxxxxxxxxx"],
          "SISD": ["01011110xx1xxxxx001011xxxxxxxxxx"]
        },
        "SQXTN_advsimd": {
          "SIMD": ["0x001110xx100001010010xxxxxxxxxx"],
          "SISD": ["01011110xx100001010010xxxxxxxxxx"]
        },
        "SQXTUN_advsimd": {
          "SIMD": ["0x101110xx100001001010xxxxxxxxxx"],
          "SISD": ["01111110xx100001001010xxxxxxxxxx"]
        },
        "SRHADD_advsimd": {
          "3REG_SAME": ["0x001110xx1xxxxx000101xxxxxxxxxx"]
        },
        "SRI_advsimd": {
          "SIMD": ["0x1011110xxxxxxx010001xxxxxxxxxx", "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"],
          "SISD": ["011111110xxxxxxx010001xxxxxxxxxx", "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"]
        },
        "SRSHL_advsimd": {
          "SIMD": ["0x001110xx1xxxxx010101xxxxxxxxxx"],
          "SISD": ["01011110xx1xxxxx010101xxxxxxxxxx"]
        },
        "SRSHR_advsimd": {
          "SIMD": ["0x0011110xxxxxxx001001xxxxxxxxxx", "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"],
          "SISD": ["010111110xxxxxxx001001xxxxxxxxxx", "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"]
        },
        "SRSRA_advsimd": {
          "SIMD": ["0x0011110xxxxxxx001101xxxxxxxxxx", "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"],
          "SISD": ["010111110xxxxxxx001101xxxxxxxxxx", "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"]
        },
        "SSBB": {
          "SYSTEM": ["11010101000000110011000010011111"]
        },
        "SSHLL_advsimd": {
          "SIMD": ["0x0011110xxxxxxx101001xxxxxxxxxx", "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"]
        },
        "SSHL_advsimd": {
          "SIMD": ["0x001110xx1xxxxx010001xxxxxxxxxx"],
          "SISD": ["01011110xx1xxxxx010001xxxxxxxxxx"]
        },
        "SSHR_advsimd": {
          "SIMD": ["0x0011110xxxxxxx000001xxxxxxxxxx", "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"],
          "SISD": ["010111110xxxxxxx000001xxxxxxxxxx", "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"]
        },
        "SSRA_advsimd": {
          "SIMD": ["0x0011110xxxxxxx000101xxxxxxxxxx", "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"],
          "SISD": ["010111110xxxxxxx000101xxxxxxxxxx", "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"]
        },
        "SSUBL_advsimd": {
          "3REG_DIFF": ["0x001110xx1xxxxx001000xxxxxxxxxx"]
        },
        "SSUBW_advsimd": {
          "3REG_DIFF": ["0x001110xx1xxxxx001100xxxxxxxxxx"]
        },
        "ST1_advsimd_mult": {
          "AS_NO_POST_INDEX": ["0x00110000000000xx1xxxxxxxxxxxxx"],
          "AS_POST_INDEX": ["0x001100100xxxxxxx1xxxxxxxxxxxxx"]
        },
        "ST1_advsimd_sngl": {
          "AS_NO_POST_INDEX": ["0x00110100000000xx0xxxxxxxxxxxxx"],
          "AS_POST_INDEX": ["0x001101100xxxxxxx0xxxxxxxxxxxxx"]
        },
        "ST2G": {
          "POST_INDEXED": ["11011001101xxxxxxxxx01xxxxxxxxxx"],
          "PRE_INDEXED": ["11011001101xxxxxxxxx11xxxxxxxxxx"],
          "SIGNED_SCALED_OFFSET": ["11011001101xxxxxxxxx10xxxxxxxxxx"]
        },
        "ST2_advsimd_mult": {
          "AS_NO_POST_INDEX": ["0x001100000000001000xxxxxxxxxxxx"],
          "AS_POST_INDEX": ["0x001100100xxxxx1000xxxxxxxxxxxx"]
        },
        "ST2_advsimd_sngl": {
          "AS_NO_POST_INDEX": ["0x00110100100000xx0xxxxxxxxxxxxx"],
          "AS_POST_INDEX": ["0x001101101xxxxxxx0xxxxxxxxxxxxx"]
        },
        "ST3_advsimd_mult": {
          "AS_NO_POST_INDEX": ["0x001100000000000100xxxxxxxxxxxx"],
          "AS_POST_INDEX": ["0x001100100xxxxx0100xxxxxxxxxxxx"]
        },
        "ST3_advsimd_sngl": {
          "AS_NO_POST_INDEX": ["0x00110100000000xx1xxxxxxxxxxxxx"],
          "AS_POST_INDEX": ["0x001101100xxxxxxx1xxxxxxxxxxxxx"]
        },
        "ST4_advsimd_mult": {
          "AS_NO_POST_INDEX": ["0x001100000000000000xxxxxxxxxxxx"],
          "AS_POST_INDEX": ["0x001100100xxxxx0000xxxxxxxxxxxx"]
        },
        "ST4_advsimd_sngl": {
          "AS_NO_POST_INDEX": ["0x00110100100000xx1xxxxxxxxxxxxx"],
          "AS_POST_INDEX": ["0x001101101xxxxxxx1xxxxxxxxxxxxx"]
        },
        "ST64B": {
          "GENERAL": ["1111100000111111100100xxxxxxxxxx"]
        },
        "ST64BV": {
          "GENERAL": ["11111000001xxxxx101100xxxxxxxxxx"]
        },
        "ST64BV0": {
          "GENERAL": ["11111000001xxxxx101000xxxxxxxxxx"]
        },
        "STADDB_LDADDB": {
          "GENERAL": ["001110000x1xxxxx000000xxxxx11111"]
        },
        "STADDH_LDADDH": {
          "GENERAL": ["011110000x1xxxxx000000xxxxx11111"]
        },
        "STADD_LDADD": {
          "GENERAL": ["1x1110000x1xxxxx000000xxxxx11111"]
        },
        "STCLRB_LDCLRB": {
          "GENERAL": ["001110000x1xxxxx000100xxxxx11111"]
        },
        "STCLRH_LDCLRH": {
          "GENERAL": ["011110000x1xxxxx000100xxxxx11111"]
        },
        "STCLR_LDCLR": {
          "GENERAL": ["1x1110000x1xxxxx000100xxxxx11111"]
        },
        "STEORB_LDEORB": {
          "GENERAL": ["001110000x1xxxxx001000xxxxx11111"]
        },
        "STEORH_LDEORH": {
          "GENERAL": ["011110000x1xxxxx001000xxxxx11111"]
        },
        "STEOR_LDEOR": {
          "GENERAL": ["1x1110000x1xxxxx001000xxxxx11111"]
        },
        "STG": {
          "POST_INDEXED": ["11011001001xxxxxxxxx01xxxxxxxxxx"],
          "PRE_INDEXED": ["11011001001xxxxxxxxx11xxxxxxxxxx"],
          "SIGNED_SCALED_OFFSET": ["11011001001xxxxxxxxx10xxxxxxxxxx"]
        },
        "STGM": {
          "GENERAL": ["1101100110100000000000xxxxxxxxxx"]
        },
        "STGP": {
          "POST_INDEXED": ["0110100010xxxxxxxxxxxxxxxxxxxxxx"],
          "PRE_INDEXED": ["0110100110xxxxxxxxxxxxxxxxxxxxxx"],
          "SIGNED_SCALED_OFFSET": ["0110100100xxxxxxxxxxxxxxxxxxxxxx"]
        },
        "STLLR": {
          "BASE_REGISTER": ["1x00100010011111011111xxxxxxxxxx"]
        },
        "STLLRB": {
          "BASE_REGISTER": ["0000100010011111011111xxxxxxxxxx"]
        },
        "STLLRH": {
          "BASE_REGISTER": ["0100100010011111011111xxxxxxxxxx"]
        },
        "STLR": {
          "BASE_REGISTER": ["1x00100010011111111111xxxxxxxxxx"]
        },
        "STLRB": {
          "BASE_REGISTER": ["0000100010011111111111xxxxxxxxxx"]
        },
        "STLRH": {
          "BASE_REGISTER": ["0100100010011111111111xxxxxxxxxx"]
        },
        "STLURB": {
          "BASE_PLUS_OFFSET": ["00011001000xxxxxxxxx00xxxxxxxxxx"]
        },
        "STLURH": {
          "BASE_PLUS_OFFSET": ["01011001000xxxxxxxxx00xxxxxxxxxx"]
        },
        "STLUR_gen": {
          "BASE_PLUS_OFFSET": ["1x011001000xxxxxxxxx00xxxxxxxxxx"]
        },
        "STLXP": {
          "BASE_REGISTER": ["1x001000001xxxxx1xxxxxxxxxxxxxxx"]
        },
        "STLXR": {
          "BASE_REGISTER": ["1x001000000xxxxx111111xxxxxxxxxx"]
        },
        "STLXRB": {
          "BASE_REGISTER": ["00001000000xxxxx111111xxxxxxxxxx"]
        },
        "STLXRH": {
          "BASE_REGISTER": ["01001000000xxxxx111111xxxxxxxxxx"]
        },
        "STNP_fpsimd": {
          "SIGNED_SCALED_OFFSET": ["xx10110000xxxxxxxxxxxxxxxxxxxxxx"]
        },
        "STNP_gen": {
          "SIGNED_SCALED_OFFSET": ["x010100000xxxxxxxxxxxxxxxxxxxxxx"]
        },
        "STP_fpsimd": {
          "POST_INDEXED": ["xx10110010xxxxxxxxxxxxxxxxxxxxxx"],
          "PRE_INDEXED": ["xx10110110xxxxxxxxxxxxxxxxxxxxxx"],
          "SIGNED_SCALED_OFFSET": ["xx10110100xxxxxxxxxxxxxxxxxxxxxx"]
        },
        "STP_gen": {
          "POST_INDEXED": ["x010100010xxxxxxxxxxxxxxxxxxxxxx"],
          "PRE_INDEXED": ["x010100110xxxxxxxxxxxxxxxxxxxxxx"],
          "SIGNED_SCALED_OFFSET": ["x010100100xxxxxxxxxxxxxxxxxxxxxx"]
        },
        "STRB_imm": {
          "POST_INDEXED": ["00111000000xxxxxxxxx01xxxxxxxxxx"],
          "PRE_INDEXED": ["00111000000xxxxxxxxx11xxxxxxxxxx"],
          "UNSIGNED_SCALED_OFFSET": ["0011100100xxxxxxxxxxxxxxxxxxxxxx"]
        },
        "STRB_reg": {
          "32": ["00111000001xxxxxxxxx10xxxxxxxxxx"]
        },
        "STRH_imm": {
          "POST_INDEXED": ["01111000000xxxxxxxxx01xxxxxxxxxx"],
          "PRE_INDEXED": ["01111000000xxxxxxxxx11xxxxxxxxxx"],
          "UNSIGNED_SCALED_OFFSET": ["0111100100xxxxxxxxxxxxxxxxxxxxxx"]
        },
        "STRH_reg": {
          "32": ["01111000001xxxxxxxxx10xxxxxxxxxx"]
        },
        "STR_imm_fpsimd": {
          "POST_INDEXED": ["xx111100x00xxxxxxxxx01xxxxxxxxxx"],
          "PRE_INDEXED": ["xx111100x00xxxxxxxxx11xxxxxxxxxx"],
          "UNSIGNED_SCALED_OFFSET": ["xx111101x0xxxxxxxxxxxxxxxxxxxxxx"]
        },
        "STR_imm_gen": {
          "POST_INDEXED": ["1x111000000xxxxxxxxx01xxxxxxxxxx"],
          "PRE_INDEXED": ["1x111000000xxxxxxxxx11xxxxxxxxxx"],
          "UNSIGNED_SCALED_OFFSET": ["1x11100100xxxxxxxxxxxxxxxxxxxxxx"]
        },
        "STR_reg_fpsimd": {
          "FPSIMD": ["xx111100x01xxxxxxxxx10xxxxxxxxxx"]
        },
        "STR_reg_gen": {
          "GENERAL": ["1x111000001xxxxxxxxx10xxxxxxxxxx"]
        },
        "STSETB_LDSETB": {
          "GENERAL": ["001110000x1xxxxx001100xxxxx11111"]
        },
        "STSETH_LDSETH": {
          "GENERAL": ["011110000x1xxxxx001100xxxxx11111"]
        },
        "STSET_LDSET": {
          "GENERAL": ["1x1110000x1xxxxx001100xxxxx11111"]
        },
        "STSMAXB_LDSMAXB": {
          "GENERAL": ["001110000x1xxxxx010000xxxxx11111"]
        },
        "STSMAXH_LDSMAXH": {
          "GENERAL": ["011110000x1xxxxx010000xxxxx11111"]
        },
        "STSMAX_LDSMAX": {
          "GENERAL": ["1x1110000x1xxxxx010000xxxxx11111"]
        },
        "STSMINB_LDSMINB": {
          "GENERAL": ["001110000x1xxxxx010100xxxxx11111"]
        },
        "STSMINH_LDSMINH": {
          "GENERAL": ["011110000x1xxxxx010100xxxxx11111"]
        },
        "STSMIN_LDSMIN": {
          "GENERAL": ["1x1110000x1xxxxx010100xxxxx11111"]
        },
        "STTR": {
          "BASE_PLUS_OFFSET": ["1x111000000xxxxxxxxx10xxxxxxxxxx"]
        },
        "STTRB": {
          "BASE_PLUS_OFFSET": ["00111000000xxxxxxxxx10xxxxxxxxxx"]
        },
        "STTRH": {
          "BASE_PLUS_OFFSET": ["01111000000xxxxxxxxx10xxxxxxxxxx"]
        },
        "STUMAXB_LDUMAXB": {
          "GENERAL": ["001110000x1xxxxx011000xxxxx11111"]
        },
        "STUMAXH_LDUMAXH": {
          "GENERAL": ["011110000x1xxxxx011000xxxxx11111"]
        },
        "STUMAX_LDUMAX": {
          "GENERAL": ["1x1110000x1xxxxx011000xxxxx11111"]
        },
        "STUMINB_LDUMINB": {
          "GENERAL": ["001110000x1xxxxx011100xxxxx11111"]
        },
        "STUMINH_LDUMINH": {
          "GENERAL": ["011110000x1xxxxx011100xxxxx11111"]
        },
        "STUMIN_LDUMIN": {
          "GENERAL": ["1x1110000x1xxxxx011100xxxxx11111"]
        },
        "STURB": {
          "BASE_PLUS_OFFSET": ["00111000000xxxxxxxxx00xxxxxxxxxx"]
        },
        "STURH": {
          "BASE_PLUS_OFFSET": ["01111000000xxxxxxxxx00xxxxxxxxxx"]
        },
        "STUR_fpsimd": {
          "BASE_PLUS_OFFSET": ["xx111100x00xxxxxxxxx00xxxxxxxxxx"]
        },
        "STUR_gen": {
          "BASE_PLUS_OFFSET": ["1x111000000xxxxxxxxx00xxxxxxxxxx"]
        },
        "STXP": {
          "BASE_REGISTER": ["1x001000001xxxxx0xxxxxxxxxxxxxxx"]
        },
        "STXR": {
          "BASE_REGISTER": ["1x001000000xxxxx011111xxxxxxxxxx"]
        },
        "STXRB": {
          "BASE_REGISTER": ["00001000000xxxxx011111xxxxxxxxxx"]
        },
        "STXRH": {
          "BASE_REGISTER": ["01001000000xxxxx011111xxxxxxxxxx"]
        },
        "STZ2G": {
          "POST_INDEXED": ["11011001111xxxxxxxxx01xxxxxxxxxx"],
          "PRE_INDEXED": ["11011001111xxxxxxxxx11xxxxxxxxxx"],
          "SIGNED_SCALED_OFFSET": ["11011001111xxxxxxxxx10xxxxxxxxxx"]
        },
        "STZG": {
          "POST_INDEXED": ["11011001011xxxxxxxxx01xxxxxxxxxx"],
          "PRE_INDEXED": ["11011001011xxxxxxxxx11xxxxxxxxxx"],
          "SIGNED_SCALED_OFFSET": ["11011001011xxxxxxxxx10xxxxxxxxxx"]
        },
        "STZGM": {
          "GENERAL": ["1101100100100000000000xxxxxxxxxx"]
        },
        "SUBG": {
          "GENERAL": ["1101000110xxxxxx00xxxxxxxxxxxxxx"]
        },
        "SUBHN_advsimd": {
          "3REG_DIFF": ["0x001110xx1xxxxx011000xxxxxxxxxx"]
        },
        "SUBP": {
          "GENERAL": ["10011010110xxxxx000000xxxxxxxxxx"]
        },
        "SUBPS": {
          "GENERAL": ["10111010110xxxxx000000xxxxxxxxxx"]
        },
        "SUBS_addsub_ext": {
          "S": ["x1101011001xxxxxxxxxxxxxxxxxxxxx"]
        },
        "SUBS_addsub_imm": {
          "S": ["x11100010xxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "SUBS_addsub_shift": {
          "S": ["x1101011xx0xxxxxxxxxxxxxxxxxxxxx"]
        },
        "SUB_addsub_ext": {
          "NO_S": ["x1001011001xxxxxxxxxxxxxxxxxxxxx"]
        },
        "SUB_addsub_imm": {
          "NO_S": ["x10100010xxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "SUB_addsub_shift": {
          "NO_S": ["x1001011xx0xxxxxxxxxxxxxxxxxxxxx"]
        },
        "SUB_advsimd": {
          "SIMD": ["0x101110xx1xxxxx100001xxxxxxxxxx"],
          "SISD": ["01111110xx1xxxxx100001xxxxxxxxxx"]
        },
        "SUDOT_advsimd_elt": {
          "2REG_ELEMENT": ["0x00111100xxxxxx1111x0xxxxxxxxxx"]
        },
        "SUQADD_advsimd": {
          "SIMD": ["0x001110xx100000001110xxxxxxxxxx"],
          "SISD": ["01011110xx100000001110xxxxxxxxxx"]
        },
        "SVC": {
          "SYSTEM": ["11010100000xxxxxxxxxxxxxxxx00001"]
        },
        "SWP": {
          "GENERAL": ["1x111000xx1xxxxx100000xxxxxxxxxx"]
        },
        "SWPB": {
          "GENERAL": ["00111000xx1xxxxx100000xxxxxxxxxx"]
        },
        "SWPH": {
          "GENERAL": ["01111000xx1xxxxx100000xxxxxxxxxx"]
        },
        "SXTB_SBFM": {
          "SIGNED_FILL": ["x00100110x000000000111xxxxxxxxxx"]
        },
        "SXTH_SBFM": {
          "SIGNED_FILL": ["x00100110x000000001111xxxxxxxxxx"]
        },
        "SXTL_SSHLL_advsimd": {
          "SIMD": ["0x0011110xxxx000101001xxxxxxxxxx", "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"]
        },
        "SXTW_SBFM": {
          "SIGNED_FILL": ["1001001101000000011111xxxxxxxxxx"]
        },
        "SYS": {
          "SYSTEM": ["1101010100001xxxxxxxxxxxxxxxxxxx"]
        },
        "SYSL": {
          "SYSTEM": ["1101010100101xxxxxxxxxxxxxxxxxxx"]
        },
        "TBL_advsimd": {
          "ADVSIMD": ["0x001110000xxxxx0xx000xxxxxxxxxx"]
        },
        "TBNZ": {
          "BR14": ["x0110111xxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "TBX_advsimd": {
          "ADVSIMD": ["0x001110000xxxxx0xx100xxxxxxxxxx"]
        },
        "TBZ": {
          "BR14": ["x0110110xxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "TLBI_SYS": {
          "SYSTEM": ["1101010100001xxx1000xxxxxxxxxxxx"]
        },
        "TRN1_advsimd": {
          "ADVSIMD": ["0x001110xx0xxxxx001010xxxxxxxxxx"]
        },
        "TRN2_advsimd": {
          "ADVSIMD": ["0x001110xx0xxxxx011010xxxxxxxxxx"]
        },
        "TSB": {
          "SYSTEM": ["11010101000000110010001001011111"]
        },
        "TST_ANDS_log_imm": {
          "S": ["x11100100xxxxxxxxxxxxxxxxxx11111"]
        },
        "TST_ANDS_log_shift": {
          "S": ["x1101010xx0xxxxxxxxxxxxxxxx11111"]
        },
        "UABAL_advsimd": {
          "3REG_DIFF": ["0x101110xx1xxxxx010100xxxxxxxxxx"]
        },
        "UABA_advsimd": {
          "3REG_SAME": ["0x101110xx1xxxxx011111xxxxxxxxxx"]
        },
        "UABDL_advsimd": {
          "3REG_DIFF": ["0x101110xx1xxxxx011100xxxxxxxxxx"]
        },
        "UABD_advsimd": {
          "3REG_SAME": ["0x101110xx1xxxxx011101xxxxxxxxxx"]
        },
        "UADALP_advsimd": {
          "SIMD": ["0x101110xx100000011010xxxxxxxxxx"]
        },
        "UADDLP_advsimd": {
          "SIMD": ["0x101110xx100000001010xxxxxxxxxx"]
        },
        "UADDLV_advsimd": {
          "ADVSIMD": ["0x101110xx110000001110xxxxxxxxxx"]
        },
        "UADDL_advsimd": {
          "3REG_DIFF": ["0x101110xx1xxxxx000000xxxxxxxxxx"]
        },
        "UADDW_advsimd": {
          "3REG_DIFF": ["0x101110xx1xxxxx000100xxxxxxxxxx"]
        },
        "UBFIZ_UBFM": {
          "ZERO_FILL": ["x10100110xxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "UBFM": {
          "ZERO_FILL": ["x10100110xxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "UBFX_UBFM": {
          "ZERO_FILL": ["x10100110xxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "UCVTF_advsimd_fix": {
          "SIMD": ["0x1011110xxxxxxx111001xxxxxxxxxx", "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"],
          "SISD": ["011111110xxxxxxx111001xxxxxxxxxx", "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"]
        },
        "UCVTF_advsimd_int": {
          "SIMD_HALF": ["0x10111001111001110110xxxxxxxxxx"],
          "SIMD_SINGLE_AND_DOUBLE": ["0x1011100x100001110110xxxxxxxxxx"],
          "SISD_HALF": ["0111111001111001110110xxxxxxxxxx"],
          "SISD_SINGLE_AND_DOUBLE": ["011111100x100001110110xxxxxxxxxx"]
        },
        "UCVTF_float_fix": {
          "FLOAT": ["x0011110xx000011xxxxxxxxxxxxxxxx"]
        },
        "UCVTF_float_int": {
          "FLOAT": ["x0011110xx100011000000xxxxxxxxxx"]
        },
        "UDF_perm_undef": {
          "GENERAL": ["0000000000000000xxxxxxxxxxxxxxxx"]
        },
        "UDIV": {
          "GENERAL": ["x0011010110xxxxx000010xxxxxxxxxx"]
        },
        "UDOT_advsimd_elt": {
          "2REG_ELEMENT": ["0x101111xxxxxxxx1110x0xxxxxxxxxx"]
        },
        "UDOT_advsimd_vec": {
          "SIMD": ["0x101110xx0xxxxx100101xxxxxxxxxx"]
        },
        "UHADD_advsimd": {
          "3REG_SAME": ["0x101110xx1xxxxx000001xxxxxxxxxx"]
        },
        "UHSUB_advsimd": {
          "3REG_SAME": ["0x101110xx1xxxxx001001xxxxxxxxxx"]
        },
        "UMADDL": {
          "64": ["10011011101xxxxx0xxxxxxxxxxxxxxx"]
        },
        "UMAXP_advsimd": {
          "3REG_SAME": ["0x101110xx1xxxxx101001xxxxxxxxxx"]
        },
        "UMAXV_advsimd": {
          "ADVSIMD": ["0x101110xx110000101010xxxxxxxxxx"]
        },
        "UMAX_advsimd": {
          "3REG_SAME": ["0x101110xx1xxxxx011001xxxxxxxxxx"]
        },
        "UMINP_advsimd": {
          "3REG_SAME": ["0x101110xx1xxxxx101011xxxxxxxxxx"]
        },
        "UMINV_advsimd": {
          "ADVSIMD": ["0x101110xx110001101010xxxxxxxxxx"]
        },
        "UMIN_advsimd": {
          "3REG_SAME": ["0x101110xx1xxxxx011011xxxxxxxxxx"]
        },
        "UMLAL_advsimd_elt": {
          "2REG_ELEMENT": ["0x101111xxxxxxxx0010x0xxxxxxxxxx"]
        },
        "UMLAL_advsimd_vec": {
          "3REG_DIFF": ["0x101110xx1xxxxx100000xxxxxxxxxx"]
        },
        "UMLSL_advsimd_elt": {
          "2REG_ELEMENT": ["0x101111xxxxxxxx0110x0xxxxxxxxxx"]
        },
        "UMLSL_advsimd_vec": {
          "3REG_DIFF": ["0x101110xx1xxxxx101000xxxxxxxxxx"]
        },
        "UMMLA_advsimd_vec": {
          "SIMD": ["01101110100xxxxx101001xxxxxxxxxx"]
        },
        "UMNEGL_UMSUBL": {
          "64": ["10011011101xxxxx111111xxxxxxxxxx"]
        },
        "UMOV_advsimd": {
          "ADVSIMD": ["0x001110000xxxxx001111xxxxxxxxxx"]
        },
        "UMSUBL": {
          "64": ["10011011101xxxxx1xxxxxxxxxxxxxxx"]
        },
        "UMULH": {
          "64": ["10011011110xxxxx011111xxxxxxxxxx"]
        },
        "UMULL_UMADDL": {
          "64": ["10011011101xxxxx011111xxxxxxxxxx"]
        },
        "UMULL_advsimd_elt": {
          "2REG_ELEMENT": ["0x101111xxxxxxxx1010x0xxxxxxxxxx"]
        },
        "UMULL_advsimd_vec": {
          "3REG_DIFF": ["0x101110xx1xxxxx110000xxxxxxxxxx"]
        },
        "UQADD_advsimd": {
          "SIMD": ["0x101110xx1xxxxx000011xxxxxxxxxx"],
          "SISD": ["01111110xx1xxxxx000011xxxxxxxxxx"]
        },
        "UQRSHL_advsimd": {
          "SIMD": ["0x101110xx1xxxxx010111xxxxxxxxxx"],
          "SISD": ["01111110xx1xxxxx010111xxxxxxxxxx"]
        },
        "UQRSHRN_advsimd": {
          "SIMD": ["0x1011110xxxxxxx100111xxxxxxxxxx", "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"],
          "SISD": ["011111110xxxxxxx100111xxxxxxxxxx", "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"]
        },
        "UQSHL_advsimd_imm": {
          "SIMD": ["0x1011110xxxxxxx011101xxxxxxxxxx", "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"],
          "SISD": ["011111110xxxxxxx011101xxxxxxxxxx", "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"]
        },
        "UQSHL_advsimd_reg": {
          "SIMD": ["0x101110xx1xxxxx010011xxxxxxxxxx"],
          "SISD": ["01111110xx1xxxxx010011xxxxxxxxxx"]
        },
        "UQSHRN_advsimd": {
          "SIMD": ["0x1011110xxxxxxx100101xxxxxxxxxx", "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"],
          "SISD": ["011111110xxxxxxx100101xxxxxxxxxx", "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"]
        },
        "UQSUB_advsimd": {
          "SIMD": ["0x101110xx1xxxxx001011xxxxxxxxxx"],
          "SISD": ["01111110xx1xxxxx001011xxxxxxxxxx"]
        },
        "UQXTN_advsimd": {
          "SIMD": ["0x101110xx100001010010xxxxxxxxxx"],
          "SISD": ["01111110xx100001010010xxxxxxxxxx"]
        },
        "URECPE_advsimd": {
          "SIMD": ["0x0011101x100001110010xxxxxxxxxx"]
        },
        "URHADD_advsimd": {
          "3REG_SAME": ["0x101110xx1xxxxx000101xxxxxxxxxx"]
        },
        "URSHL_advsimd": {
          "SIMD": ["0x101110xx1xxxxx010101xxxxxxxxxx"],
          "SISD": ["01111110xx1xxxxx010101xxxxxxxxxx"]
        },
        "URSHR_advsimd": {
          "SIMD": ["0x1011110xxxxxxx001001xxxxxxxxxx", "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"],
          "SISD": ["011111110xxxxxxx001001xxxxxxxxxx", "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"]
        },
        "URSQRTE_advsimd": {
          "SIMD": ["0x1011101x100001110010xxxxxxxxxx"]
        },
        "URSRA_advsimd": {
          "SIMD": ["0x1011110xxxxxxx001101xxxxxxxxxx", "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"],
          "SISD": ["011111110xxxxxxx001101xxxxxxxxxx", "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"]
        },
        "USDOT_advsimd_elt": {
          "2REG_ELEMENT": ["0x00111110xxxxxx1111x0xxxxxxxxxx"]
        },
        "USDOT_advsimd_vec": {
          "SIMD": ["0x001110100xxxxx100111xxxxxxxxxx"]
        },
        "USHLL_advsimd": {
          "SIMD": ["0x1011110xxxxxxx101001xxxxxxxxxx", "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"]
        },
        "USHL_advsimd": {
          "SIMD": ["0x101110xx1xxxxx010001xxxxxxxxxx"],
          "SISD": ["01111110xx1xxxxx010001xxxxxxxxxx"]
        },
        "USHR_advsimd": {
          "SIMD": ["0x1011110xxxxxxx000001xxxxxxxxxx", "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"],
          "SISD": ["011111110xxxxxxx000001xxxxxxxxxx", "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"]
        },
        "USMMLA_advsimd_vec": {
          "SIMD": ["01001110100xxxxx101011xxxxxxxxxx"]
        },
        "USQADD_advsimd": {
          "SIMD": ["0x101110xx100000001110xxxxxxxxxx"],
          "SISD": ["01111110xx100000001110xxxxxxxxxx"]
        },
        "USRA_advsimd": {
          "SIMD": ["0x1011110xxxxxxx000101xxxxxxxxxx", "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"],
          "SISD": ["011111110xxxxxxx000101xxxxxxxxxx", "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"]
        },
        "USUBL_advsimd": {
          "3REG_DIFF": ["0x101110xx1xxxxx001000xxxxxxxxxx"]
        },
        "USUBW_advsimd": {
          "3REG_DIFF": ["0x101110xx1xxxxx001100xxxxxxxxxx"]
        },
        "UXTB_UBFM": {
          "ZERO_FILL": ["0101001100000000000111xxxxxxxxxx"]
        },
        "UXTH_UBFM": {
          "ZERO_FILL": ["0101001100000000001111xxxxxxxxxx"]
        },
        "UXTL_USHLL_advsimd": {
          "SIMD": ["0x1011110xxxx000101001xxxxxxxxxx", "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"]
        },
        "UZP1_advsimd": {
          "ADVSIMD": ["0x001110xx0xxxxx000110xxxxxxxxxx"]
        },
        "UZP2_advsimd": {
          "ADVSIMD": ["0x001110xx0xxxxx010110xxxxxxxxxx"]
        },
        "WFE": {
          "SYSTEM": ["11010101000000110010000001011111"]
        },
        "WFET": {
          "SYSTEM": ["110101010000001100010000000xxxxx"]
        },
        "WFI": {
          "SYSTEM": ["11010101000000110010000001111111"]
        },
        "WFIT": {
          "SYSTEM": ["110101010000001100010000001xxxxx"]
        },
        "XAFLAG": {
          "SYSTEM": ["11010101000000000100000000111111"]
        },
        "XAR_advsimd": {
          "ADVSIMD": ["11001110100xxxxxxxxxxxxxxxxxxxxx"]
        },
        "XPAC": {
          "GENERAL": ["110110101100000101000x11111xxxxx"],
          "SYSTEM": ["11010101000000110010000011111111"]
        },
        "XTN_advsimd": {
          "SIMD": ["0x001110xx100001001010xxxxxxxxxx"]
        },
        "YIELD": {
          "SYSTEM": ["11010101000000110010000000111111"]
        },
        "ZIP1_advsimd": {
          "ADVSIMD": ["0x001110xx0xxxxx001110xxxxxxxxxx"]
        },
        "ZIP2_advsimd": {
          "ADVSIMD": ["0x001110xx0xxxxx011110xxxxxxxxxx"]
        }
      }
    },
    "simd_fp": {
      "ABS_advsimd": {
        "authored": "Absolute value (vector). This instruction calculates the absolute value of each\nvector element in the source SIMD&FP register, puts the result into a vector,\nand writes the vector to the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "ABS",
        "templates": {
          "SIMD": [
            "ABS  <Vd>.<T>, <Vn>.<T>"
          ],
          "SISD": [
            "ABS  <V><d>, <V><n>"
          ]
        }
      },
      "ADDHN_advsimd": {
        "authored": "Add returning High Narrow. This instruction adds each vector element in the\nfirst source SIMD&FP register to the corresponding vector element in the second\nsource SIMD&FP register, places the most significant half of the result into a\nvector, and writes the vector to the lower or upper half of the destination\nSIMD&FP register.\n\nThe results are truncated. For rounded results, see RADDHN.\n\nThe ADDHN instruction writes the vector to the lower half of the destination\nregister and clears the upper half, while the ADDHN2 instruction writes the\nvector to the upper half of the destination register without affecting the other\nbits of the register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "ADDHN, ADDHN2",
        "templates": {
          "3REG_DIFF": [
            "ADDHN{2}  <Vd>.<Tb>, <Vn>.<Ta>, <Vm>.<Ta>"
          ]
        }
      },
      "ADDP_advsimd_pair": {
        "authored": "Add Pair of elements (scalar). This instruction adds two vector elements in the\nsource SIMD&FP register and writes the scalar result into the destination\nSIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "ADDP (scalar)",
        "templates": {
          "ADVSIMD": [
            "ADDP  <V><d>, <Vn>.<T>"
          ]
        }
      },
      "ADDP_advsimd_vec": {
        "authored": "Add Pairwise (vector). This instruction creates a vector by concatenating the\nvector elements of the first source SIMD&FP register after the vector elements\nof the second source SIMD&FP register, reads each pair of adjacent vector\nelements from the concatenated vector, adds each pair of values together, places\nthe result into a vector, and writes the vector to the destination SIMD&FP\nregister.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "ADDP (vector)",
        "templates": {
          "3REG_SAME": [
            "ADDP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ]
        }
      },
      "ADDV_advsimd": {
        "authored": "Add across Vector. This instruction adds every vector element in the source\nSIMD&FP register together, and writes the scalar result to the destination\nSIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "ADDV",
        "templates": {
          "ADVSIMD": [
            "ADDV  <V><d>, <Vn>.<T>"
          ]
        }
      },
      "ADD_advsimd": {
        "authored": "Add (vector). This instruction adds corresponding elements in the two source\nSIMD&FP registers, places the results into a vector, and writes the vector to\nthe destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "ADD (vector)",
        "templates": {
          "SIMD": [
            "ADD  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ],
          "SISD": [
            "ADD  <V><d>, <V><n>, <V><m>"
          ]
        }
      },
      "AESD_advsimd": {
        "authored": "AES single round decryption.",
        "heading": "AESD",
        "templates": {
          "ADVSIMD": [
            "AESD  <Vd>.16B, <Vn>.16B"
          ]
        }
      },
      "AESE_advsimd": {
        "authored": "AES single round encryption.",
        "heading": "AESE",
        "templates": {
          "ADVSIMD": [
            "AESE  <Vd>.16B, <Vn>.16B"
          ]
        }
      },
      "AESIMC_advsimd": {
        "authored": "AES inverse mix columns.",
        "heading": "AESIMC",
        "templates": {
          "ADVSIMD": [
            "AESIMC  <Vd>.16B, <Vn>.16B"
          ]
        }
      },
      "AESMC_advsimd": {
        "authored": "AES mix columns.",
        "heading": "AESMC",
        "templates": {
          "ADVSIMD": [
            "AESMC  <Vd>.16B, <Vn>.16B"
          ]
        }
      },
      "AND_advsimd": {
        "authored": "Bitwise AND (vector). This instruction performs a bitwise AND between the two\nsource SIMD&FP registers, and writes the result to the destination SIMD&FP\nregister.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "AND (vector)",
        "templates": {
          "3REG_SAME": [
            "AND  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ]
        }
      },
      "BCAX_advsimd": {
        "authored": "Bit Clear and Exclusive OR performs a bitwise AND of the 128-bit vector in a\nsource SIMD&FP register and the complement of the vector in another source\nSIMD&FP register, then performs a bitwise exclusive OR of the resulting vector\nand the vector in a third source SIMD&FP register, and writes the result to the\ndestination SIMD&FP register.\n\nThis instruction is implemented only when FEAT_SHA3 is implemented.",
        "heading": "BCAX",
        "templates": {
          "ADVSIMD": [
            "BCAX  <Vd>.16B, <Vn>.16B, <Vm>.16B, <Va>.16B"
          ]
        }
      },
      "BFCVTN_advsimd": {
        "authored": "Floating-point convert from single-precision to BFloat16 format (vector) reads\neach single-precision element in the SIMD&FP source vector, converts each value\nto BFloat16 format, and writes the results in the lower or upper half of the\nSIMD&FP destination vector. The result elements are half the width of the source\nelements.\n\nThe BFCVTN instruction writes the half-width results to the lower half of the\ndestination vector and clears the upper half to zero, while the BFCVTN2\ninstruction writes the results to the upper half of the destination vector\nwithout affecting the other bits in the register.\n\nUnlike the BFloat16 multiplication instructions, this instruction honors all of\nthe control bits in the FPCR that apply to single-precision arithmetic,\nincluding the rounding mode. It can also generate a floating-point exception\nthat causes cumulative exception bits in the FPSR to be set, or a synchronous\nexception to be taken, depending on the enable bits in the FPCR.",
        "heading": "BFCVTN, BFCVTN2",
        "templates": {
          "SIMD_SINGLE_AND_BF16": [
            "BFCVTN{2}  <Vd>.<Ta>, <Vn>.4S"
          ]
        }
      },
      "BFCVT_float": {
        "authored": "Floating-point convert from single-precision to BFloat16 format (scalar)\nconverts the single-precision floating-point value in the 32-bit SIMD&FP source\nregister to BFloat16 format and writes the result in the 16-bit SIMD&FP\ndestination register.\n\nUnlike the BFloat16 multiplication instructions, this instruction honors all the\ncontrol bits in the FPCR that apply to single-precision arithmetic, including\nthe rounding mode. This instruction can generate a floating-point exception that\ncauses a cumulative exception bit in the FPSR to be set, or a synchronous\nexception to be taken, depending on the enable bits in the FPCR.\nID_AA64ISAR1_EL1.BF16 indicates whether this instruction is supported.",
        "heading": "BFCVT",
        "templates": {
          "SINGLE_TO_BF16": [
            "BFCVT  <Hd>, <Sn>"
          ]
        }
      },
      "BFDOT_advsimd_elt": {
        "authored": "BFloat16 floating-point dot product (vector, by element). This instruction\ndelimits the source vectors into pairs of 16-bit BF16 elements. Each pair of\nelements in the first source vector is multiplied by the specified pair of\nelements in the second source vector. The resulting single-precision products\nare then summed and added destructively to the single-precision element of the\ndestination vector that aligns with the pair of BF16 values in the first source\nvector. The instruction ignores the FPCR and does not update the FPSR exception\nstatus.\n\nThe BF16 pair within the second source vector is specified using an immediate\nindex. The index range is from 0 to 3 inclusive. ID_AA64ISAR1_EL1.BF16 indicates\nwhether this instruction is supported.",
        "heading": "BFDOT (by element)",
        "templates": {
          "2REG_ELEMENT": [
            "BFDOT  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.2H[<index>]"
          ]
        }
      },
      "BFDOT_advsimd_vec": {
        "authored": "BFloat16 floating-point dot product (vector). This instruction delimits the\nsource vectors into pairs of 16-bit BF16 elements. Within each pair, the\nelements in the first source vector are multiplied by the corresponding elements\nin the second source vector. The resulting single-precision products are then\nsummed and added destructively to the single-precision element of the\ndestination vector that aligns with the pair of BF16 values in the first source\nvector. The instruction ignores the FPCR and does not update the FPSR exception\nstatus.",
        "heading": "BFDOT (vector)",
        "templates": {
          "SIMD": [
            "BFDOT  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>"
          ]
        }
      },
      "BFMLAL_advsimd_elt": {
        "authored": "BFloat16 floating-point widening multiply-add long (by element) widens the even-\nnumbered (bottom) or odd-numbered (top) 16-bit elements in the first source\nvector, and the indexed element in the second source vector from Bfloat16 to\nsingle-precision format. The instruction then multiplies and adds these values\nto the overlapping single-precision elements of the destination vector.\n\nThis performs a fused multiply-add without intermediate rounding that honors all\nof the control bits in the FPCR that apply to single-precision arithmetic,\nincluding the rounding mode. It can also generate a floating-point exception\nthat causes cumulative exception bits in the FPSR to be set, or a synchronous\nexception to be taken, depending on the enable bits in the FPCR.\nID_AA64ISAR1_EL1.BF16 indicates whether this instruction is supported.",
        "heading": "BFMLALB, BFMLALT (by element)",
        "templates": {
          "2REG_ELEMENT": [
            "BFMLAL<bt>  <Vd>.4S, <Vn>.8H, <Vm>.H[<index>]"
          ]
        }
      },
      "BFMLAL_advsimd_vec": {
        "authored": "BFloat16 floating-point widening multiply-add long (vector) widens the even-\nnumbered (bottom) or odd-numbered (top) 16-bit elements in the first and second\nsource vectors from Bfloat16 to single-precision format. The instruction then\nmultiplies and adds these values to the overlapping single-precision elements of\nthe destination vector.\n\nThis performs a fused multiply-add without intermediate rounding that honors all\nof the control bits in the FPCR that apply to single-precision arithmetic,\nincluding the rounding mode. It can also generate a floating-point exception\nthat causes cumulative exception bits in the FPSR to be set, or a synchronous\nexception to be taken, depending on the enable bits in the FPCR.\nID_AA64ISAR1_EL1.BF16 indicates whether these instruction is supported.",
        "heading": "BFMLALB, BFMLALT (vector)",
        "templates": {
          "SIMD": [
            "BFMLAL<bt>  <Vd>.4S, <Vn>.8H, <Vm>.8H"
          ]
        }
      },
      "BFMMLA_advsimd": {
        "authored": "BFloat16 floating-point matrix multiply-accumulate into 2x2 matrix. This\ninstruction multiplies the 2x4 matrix of BF16 values held in the first 128-bit\nsource vector by the 4x2 BF16 matrix in the second 128-bit source vector. The\nresulting 2x2 single-precision matrix product is then added destructively to the\n2x2 single-precision matrix in the 128-bit destination vector. This is\nequivalent to performing a 4-way dot product per destination element. The\ninstruction ignores the FPCR and does not update the FPSR exception status.\n\nArm expects that the BFMMLA instruction will deliver a peak BF16 multiply\nthroughput that is at least as high as can be achieved using two BFDOT\ninstructions, with a goal that it should have significantly higher throughput.",
        "heading": "BFMMLA",
        "templates": {
          "SIMD": [
            "BFMMLA  <Vd>.4S, <Vn>.8H, <Vm>.8H"
          ]
        }
      },
      "BIC_advsimd_imm": {
        "authored": "Bitwise bit Clear (vector, immediate). This instruction reads each vector\nelement from the destination SIMD&FP register, performs a bitwise AND between\neach result and the complement of an immediate constant, places the result into\na vector, and writes the vector to the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "BIC (vector, immediate)",
        "templates": {
          "SHIFTED_IMMEDIATE": [
            "BIC  <Vd>.<T>, #<imm8>{, LSL #<amount>}",
            "BIC  <Vd>.<T>, #<imm8>{, LSL #<amount>}"
          ]
        }
      },
      "BIC_advsimd_reg": {
        "authored": "Bitwise bit Clear (vector, register). This instruction performs a bitwise AND\nbetween the first source SIMD&FP register and the complement of the second\nsource SIMD&FP register, and writes the result to the destination SIMD&FP\nregister.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "BIC (vector, register)",
        "templates": {
          "3REG_SAME": [
            "BIC  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ]
        }
      },
      "BIF_advsimd": {
        "authored": "Bitwise Insert if False. This instruction inserts each bit from the first source\nSIMD&FP register into the destination SIMD&FP register if the corresponding bit\nof the second source SIMD&FP register is 0, otherwise leaves the bit in the\ndestination register unchanged.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "BIF",
        "templates": {
          "3REG_SAME": [
            "BIF  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ]
        }
      },
      "BIT_advsimd": {
        "authored": "Bitwise Insert if True. This instruction inserts each bit from the first source\nSIMD&FP register into the SIMD&FP destination register if the corresponding bit\nof the second source SIMD&FP register is 1, otherwise leaves the bit in the\ndestination register unchanged.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "BIT",
        "templates": {
          "3REG_SAME": [
            "BIT  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ]
        }
      },
      "BSL_advsimd": {
        "authored": "Bitwise Select. This instruction sets each bit in the destination SIMD&FP\nregister to the corresponding bit from the first source SIMD&FP register when\nthe original destination bit was 1, otherwise from the second source SIMD&FP\nregister.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "BSL",
        "templates": {
          "3REG_SAME": [
            "BSL  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ]
        }
      },
      "CLS_advsimd": {
        "authored": "Count Leading Sign bits (vector). This instruction counts the number of\nconsecutive bits following the most significant bit that are the same as the\nmost significant bit in each vector element in the source SIMD&FP register,\nplaces the result into a vector, and writes the vector to the destination\nSIMD&FP register. The count does not include the most significant bit itself.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "CLS (vector)",
        "templates": {
          "SIMD": [
            "CLS  <Vd>.<T>, <Vn>.<T>"
          ]
        }
      },
      "CLZ_advsimd": {
        "authored": "Count Leading Zero bits (vector). This instruction counts the number of\nconsecutive zeros, starting from the most significant bit, in each vector\nelement in the source SIMD&FP register, places the result into a vector, and\nwrites the vector to the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "CLZ (vector)",
        "templates": {
          "SIMD": [
            "CLZ  <Vd>.<T>, <Vn>.<T>"
          ]
        }
      },
      "CMEQ_advsimd_reg": {
        "authored": "Compare bitwise Equal (vector). This instruction compares each vector element\nfrom the first source SIMD&FP register with the corresponding vector element\nfrom the second source SIMD&FP register, and if the comparison is equal sets\nevery bit of the corresponding vector element in the destination SIMD&FP\nregister to one, otherwise sets every bit of the corresponding vector element in\nthe destination SIMD&FP register to zero.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "CMEQ (register)",
        "templates": {
          "SIMD": [
            "CMEQ  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ],
          "SISD": [
            "CMEQ  <V><d>, <V><n>, <V><m>"
          ]
        }
      },
      "CMEQ_advsimd_zero": {
        "authored": "Compare bitwise Equal to zero (vector). This instruction reads each vector\nelement in the source SIMD&FP register and if the value is equal to zero sets\nevery bit of the corresponding vector element in the destination SIMD&FP\nregister to one, otherwise sets every bit of the corresponding vector element in\nthe destination SIMD&FP register to zero.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "CMEQ (zero)",
        "templates": {
          "SIMD": [
            "CMEQ  <Vd>.<T>, <Vn>.<T>, #0"
          ],
          "SISD": [
            "CMEQ  <V><d>, <V><n>, #0"
          ]
        }
      },
      "CMGE_advsimd_reg": {
        "authored": "Compare signed Greater than or Equal (vector). This instruction compares each\nvector element in the first source SIMD&FP register with the corresponding\nvector element in the second source SIMD&FP register and if the first signed\ninteger value is greater than or equal to the second signed integer value sets\nevery bit of the corresponding vector element in the destination SIMD&FP\nregister to one, otherwise sets every bit of the corresponding vector element in\nthe destination SIMD&FP register to zero.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "CMGE (register)",
        "templates": {
          "SIMD": [
            "CMGE  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ],
          "SISD": [
            "CMGE  <V><d>, <V><n>, <V><m>"
          ]
        }
      },
      "CMGE_advsimd_zero": {
        "authored": "Compare signed Greater than or Equal to zero (vector). This instruction reads\neach vector element in the source SIMD&FP register and if the signed integer\nvalue is greater than or equal to zero sets every bit of the corresponding\nvector element in the destination SIMD&FP register to one, otherwise sets every\nbit of the corresponding vector element in the destination SIMD&FP register to\nzero.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "CMGE (zero)",
        "templates": {
          "SIMD": [
            "CMGE  <Vd>.<T>, <Vn>.<T>, #0"
          ],
          "SISD": [
            "CMGE  <V><d>, <V><n>, #0"
          ]
        }
      },
      "CMGT_advsimd_reg": {
        "authored": "Compare signed Greater than (vector). This instruction compares each vector\nelement in the first source SIMD&FP register with the corresponding vector\nelement in the second source SIMD&FP register and if the first signed integer\nvalue is greater than the second signed integer value sets every bit of the\ncorresponding vector element in the destination SIMD&FP register to one,\notherwise sets every bit of the corresponding vector element in the destination\nSIMD&FP register to zero.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "CMGT (register)",
        "templates": {
          "SIMD": [
            "CMGT  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ],
          "SISD": [
            "CMGT  <V><d>, <V><n>, <V><m>"
          ]
        }
      },
      "CMGT_advsimd_zero": {
        "authored": "Compare signed Greater than zero (vector). This instruction reads each vector\nelement in the source SIMD&FP register and if the signed integer value is\ngreater than zero sets every bit of the corresponding vector element in the\ndestination SIMD&FP register to one, otherwise sets every bit of the\ncorresponding vector element in the destination SIMD&FP register to zero.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "CMGT (zero)",
        "templates": {
          "SIMD": [
            "CMGT  <Vd>.<T>, <Vn>.<T>, #0"
          ],
          "SISD": [
            "CMGT  <V><d>, <V><n>, #0"
          ]
        }
      },
      "CMHI_advsimd": {
        "authored": "Compare unsigned Higher (vector). This instruction compares each vector element\nin the first source SIMD&FP register with the corresponding vector element in\nthe second source SIMD&FP register and if the first unsigned integer value is\ngreater than the second unsigned integer value sets every bit of the\ncorresponding vector element in the destination SIMD&FP register to one,\notherwise sets every bit of the corresponding vector element in the destination\nSIMD&FP register to zero.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "CMHI (register)",
        "templates": {
          "SIMD": [
            "CMHI  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ],
          "SISD": [
            "CMHI  <V><d>, <V><n>, <V><m>"
          ]
        }
      },
      "CMHS_advsimd": {
        "authored": "Compare unsigned Higher or Same (vector). This instruction compares each vector\nelement in the first source SIMD&FP register with the corresponding vector\nelement in the second source SIMD&FP register and if the first unsigned integer\nvalue is greater than or equal to the second unsigned integer value sets every\nbit of the corresponding vector element in the destination SIMD&FP register to\none, otherwise sets every bit of the corresponding vector element in the\ndestination SIMD&FP register to zero.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "CMHS (register)",
        "templates": {
          "SIMD": [
            "CMHS  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ],
          "SISD": [
            "CMHS  <V><d>, <V><n>, <V><m>"
          ]
        }
      },
      "CMLE_advsimd": {
        "authored": "Compare signed Less than or Equal to zero (vector). This instruction reads each\nvector element in the source SIMD&FP register and if the signed integer value is\nless than or equal to zero sets every bit of the corresponding vector element in\nthe destination SIMD&FP register to one, otherwise sets every bit of the\ncorresponding vector element in the destination SIMD&FP register to zero.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "CMLE (zero)",
        "templates": {
          "SIMD": [
            "CMLE  <Vd>.<T>, <Vn>.<T>, #0"
          ],
          "SISD": [
            "CMLE  <V><d>, <V><n>, #0"
          ]
        }
      },
      "CMLT_advsimd": {
        "authored": "Compare signed Less than zero (vector). This instruction reads each vector\nelement in the source SIMD&FP register and if the signed integer value is less\nthan zero sets every bit of the corresponding vector element in the destination\nSIMD&FP register to one, otherwise sets every bit of the corresponding vector\nelement in the destination SIMD&FP register to zero.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "CMLT (zero)",
        "templates": {
          "SIMD": [
            "CMLT  <Vd>.<T>, <Vn>.<T>, #0"
          ],
          "SISD": [
            "CMLT  <V><d>, <V><n>, #0"
          ]
        }
      },
      "CMTST_advsimd": {
        "authored": "Compare bitwise Test bits nonzero (vector). This instruction reads each vector\nelement in the first source SIMD&FP register, performs an AND with the\ncorresponding vector element in the second source SIMD&FP register, and if the\nresult is not zero, sets every bit of the corresponding vector element in the\ndestination SIMD&FP register to one, otherwise sets every bit of the\ncorresponding vector element in the destination SIMD&FP register to zero.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "CMTST",
        "templates": {
          "SIMD": [
            "CMTST  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ],
          "SISD": [
            "CMTST  <V><d>, <V><n>, <V><m>"
          ]
        }
      },
      "CNT_advsimd": {
        "authored": "Population Count per byte. This instruction counts the number of bits that have\na value of one in each vector element in the source SIMD&FP register, places the\nresult into a vector, and writes the vector to the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "CNT",
        "templates": {
          "SIMD": [
            "CNT  <Vd>.<T>, <Vn>.<T>"
          ]
        }
      },
      "DUP_advsimd_elt": {
        "authored": "Duplicate vector element to vector or scalar. This instruction duplicates the\nvector element at the specified element index in the source SIMD&FP register\ninto a scalar or each element in a vector, and writes the result to the\ndestination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "DUP (element)",
        "templates": {
          "SCALAR_FROM_ELEMENT": [
            "DUP  <V><d>, <Vn>.<T>[<index>]"
          ],
          "VECTOR_FROM_ELEMENT": [
            "DUP  <Vd>.<T>, <Vn>.<Ts>[<index>]"
          ]
        }
      },
      "DUP_advsimd_gen": {
        "authored": "Duplicate general-purpose register to vector. This instruction duplicates the\ncontents of the source general-purpose register into a scalar or each element in\na vector, and writes the result to the SIMD&FP destination register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "DUP (general)",
        "templates": {
          "ADVSIMD": [
            "DUP  <Vd>.<T>, <R><n>"
          ]
        }
      },
      "EOR3_advsimd": {
        "authored": "Three-way Exclusive OR performs a three-way exclusive OR of the values in the\nthree source SIMD&FP registers, and writes the result to the destination SIMD&FP\nregister.\n\nThis instruction is implemented only when FEAT_SHA3 is implemented.",
        "heading": "EOR3",
        "templates": {
          "ADVSIMD": [
            "EOR3  <Vd>.16B, <Vn>.16B, <Vm>.16B, <Va>.16B"
          ]
        }
      },
      "EOR_advsimd": {
        "authored": "Bitwise Exclusive OR (vector). This instruction performs a bitwise Exclusive OR\noperation between the two source SIMD&FP registers, and places the result in the\ndestination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "EOR (vector)",
        "templates": {
          "3REG_SAME": [
            "EOR  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ]
        }
      },
      "EXT_advsimd": {
        "authored": "Extract vector from pair of vectors. This instruction extracts the lowest vector\nelements from the second source SIMD&FP register and the highest vector elements\nfrom the first source SIMD&FP register, concatenates the results into a vector,\nand writes the vector to the destination SIMD&FP register vector. The index\nvalue specifies the lowest vector element to extract from the first source\nregister, and consecutive elements are extracted from the first, then second,\nsource registers until the destination vector is filled.\n\n\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "EXT",
        "templates": {
          "ADVSIMD": [
            "EXT  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>, #<index>"
          ]
        }
      },
      "FABD_advsimd": {
        "authored": "Floating-point Absolute Difference (vector). This instruction subtracts the\nfloating-point values in the elements of the second source SIMD&FP register,\nfrom the corresponding floating-point values in the elements of the first source\nSIMD&FP register, places the absolute value of each result in a vector, and\nwrites the vector to the destination SIMD&FP register.\n\nThis instruction can generate a floating-point exception. Depending on the\nsettings in FPCR, the exception results in either a flag being set in FPSR, or a\nsynchronous exception being generated. For more information, see Floating-point\nexception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FABD",
        "templates": {
          "SIMD_HALF": [
            "FABD  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ],
          "SIMD_SINGLE_AND_DOUBLE": [
            "FABD  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ],
          "SISD_HALF": [
            "FABD  <Hd>, <Hn>, <Hm>"
          ],
          "SISD_SINGLE_AND_DOUBLE": [
            "FABD  <V><d>, <V><n>, <V><m>"
          ]
        }
      },
      "FABS_advsimd": {
        "authored": "Floating-point Absolute value (vector). This instruction calculates the absolute\nvalue of each vector element in the source SIMD&FP register, writes the result\nto a vector, and writes the vector to the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FABS (vector)",
        "templates": {
          "HALF": [
            "FABS  <Vd>.<T>, <Vn>.<T>"
          ],
          "SINGLE_AND_DOUBLE": [
            "FABS  <Vd>.<T>, <Vn>.<T>"
          ]
        }
      },
      "FABS_float": {
        "authored": "Floating-point Absolute value (scalar). This instruction calculates the absolute\nvalue in the SIMD&FP source register and writes the result to the SIMD&FP\ndestination register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FABS (scalar)",
        "templates": {
          "FLOAT": [
            "FABS  <Hd>, <Hn>",
            "FABS  <Sd>, <Sn>",
            "FABS  <Dd>, <Dn>"
          ]
        }
      },
      "FACGE_advsimd": {
        "authored": "Floating-point Absolute Compare Greater than or Equal (vector). This instruction\ncompares the absolute value of each floating-point value in the first source\nSIMD&FP register with the absolute value of the corresponding floating-point\nvalue in the second source SIMD&FP register and if the first value is greater\nthan or equal to the second value sets every bit of the corresponding vector\nelement in the destination SIMD&FP register to one, otherwise sets every bit of\nthe corresponding vector element in the destination SIMD&FP register to zero.\n\nThis instruction can generate a floating-point exception. Depending on the\nsettings in FPCR, the exception results in either a flag being set in FPSR, or a\nsynchronous exception being generated. For more information, see Floating-point\nexception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FACGE",
        "templates": {
          "SIMD_HALF": [
            "FACGE  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ],
          "SIMD_SINGLE_AND_DOUBLE": [
            "FACGE  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ],
          "SISD_HALF": [
            "FACGE  <Hd>, <Hn>, <Hm>"
          ],
          "SISD_SINGLE_AND_DOUBLE": [
            "FACGE  <V><d>, <V><n>, <V><m>"
          ]
        }
      },
      "FACGT_advsimd": {
        "authored": "Floating-point Absolute Compare Greater than (vector). This instruction compares\nthe absolute value of each vector element in the first source SIMD&FP register\nwith the absolute value of the corresponding vector element in the second source\nSIMD&FP register and if the first value is greater than the second value sets\nevery bit of the corresponding vector element in the destination SIMD&FP\nregister to one, otherwise sets every bit of the corresponding vector element in\nthe destination SIMD&FP register to zero.\n\nThis instruction can generate a floating-point exception. Depending on the\nsettings in FPCR, the exception results in either a flag being set in FPSR, or a\nsynchronous exception being generated. For more information, see Floating-point\nexception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FACGT",
        "templates": {
          "SIMD_HALF": [
            "FACGT  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ],
          "SIMD_SINGLE_AND_DOUBLE": [
            "FACGT  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ],
          "SISD_HALF": [
            "FACGT  <Hd>, <Hn>, <Hm>"
          ],
          "SISD_SINGLE_AND_DOUBLE": [
            "FACGT  <V><d>, <V><n>, <V><m>"
          ]
        }
      },
      "FADDP_advsimd_pair": {
        "authored": "Floating-point Add Pair of elements (scalar). This instruction adds two\nfloating-point vector elements in the source SIMD&FP register and writes the\nscalar result into the destination SIMD&FP register.\n\nThis instruction can generate a floating-point exception. Depending on the\nsettings in FPCR, the exception results in either a flag being set in FPSR or a\nsynchronous exception being generated. For more information, see Floating-point\nexception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FADDP (scalar)",
        "templates": {
          "HALF": [
            "FADDP  <V><d>, <Vn>.<T>"
          ],
          "SINGLE_AND_DOUBLE": [
            "FADDP  <V><d>, <Vn>.<T>"
          ]
        }
      },
      "FADDP_advsimd_vec": {
        "authored": "Floating-point Add Pairwise (vector). This instruction creates a vector by\nconcatenating the vector elements of the first source SIMD&FP register after the\nvector elements of the second source SIMD&FP register, reads each pair of\nadjacent vector elements from the concatenated vector, adds each pair of values\ntogether, places the result into a vector, and writes the vector to the\ndestination SIMD&FP register. All the values in this instruction are floating-\npoint values.\n\nThis instruction can generate a floating-point exception. Depending on the\nsettings in FPCR, the exception results in either a flag being set in FPSR or a\nsynchronous exception being generated. For more information, see Floating-point\nexception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FADDP (vector)",
        "templates": {
          "HALF": [
            "FADDP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ],
          "SINGLE_AND_DOUBLE": [
            "FADDP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ]
        }
      },
      "FADD_advsimd": {
        "authored": "Floating-point Add (vector). This instruction adds corresponding vector elements\nin the two source SIMD&FP registers, writes the result into a vector, and writes\nthe vector to the destination SIMD&FP register. All the values in this\ninstruction are floating-point values.\n\nThis instruction can generate a floating-point exception. Depending on the\nsettings in FPCR, the exception results in either a flag being set in FPSR or a\nsynchronous exception being generated. For more information, see Floating-point\nexception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FADD (vector)",
        "templates": {
          "HALF": [
            "FADD  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ],
          "SINGLE_AND_DOUBLE": [
            "FADD  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ]
        }
      },
      "FADD_float": {
        "authored": "Floating-point Add (scalar). This instruction adds the floating-point values of\nthe two source SIMD&FP registers, and writes the result to the destination\nSIMD&FP register.\n\nThis instruction can generate a floating-point exception. Depending on the\nsettings in FPCR, the exception results in either a flag being set in FPSR, or a\nsynchronous exception being generated. For more information, see Floating-point\nexception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FADD (scalar)",
        "templates": {
          "FLOAT": [
            "FADD  <Hd>, <Hn>, <Hm>",
            "FADD  <Sd>, <Sn>, <Sm>",
            "FADD  <Dd>, <Dn>, <Dm>"
          ]
        }
      },
      "FCADD_advsimd_vec": {
        "authored": "Floating-point Complex Add.\n\nThis instruction operates on complex numbers that are represented in SIMD&FP\nregisters as pairs of elements, with the more significant element holding the\nimaginary part of the number and the less significant element holding the real\npart of the number. Each element holds a floating-point value. It performs the\nfollowing computation on the corresponding complex number element pairs from the\ntwo source registers:\n  - Considering the complex number from the second source register on an Argand\ndiagram, the number is rotated counterclockwise by 90 or 270 degrees.\n  - The rotated complex number is added to the complex number from the first\nsource register.\n\nThis instruction can generate a floating-point exception. Depending on the\nsettings in FPCR, the exception results in either a flag being set in FPSR or a\nsynchronous exception being generated. For more information, see Floating-point\nexception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FCADD",
        "templates": {
          "SIMD": [
            "FCADD  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>, #<rotate>"
          ]
        }
      },
      "FCCMPE_float": {
        "authored": "Floating-point Conditional signaling Compare (scalar). This instruction compares\nthe two SIMD&FP source register values and writes the result to the PSTATE.{N,\nZ, C, V} flags. If the condition does not pass then the PSTATE.{N, Z, C, V}\nflags are set to the flag bit specifier.\n\nThis instruction raises an Invalid Operation floating-point exception if either\nor both of the operands is any type of NaN.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FCCMPE",
        "templates": {
          "FLOAT": [
            "FCCMPE  <Hn>, <Hm>, #<nzcv>, <cond>",
            "FCCMPE  <Sn>, <Sm>, #<nzcv>, <cond>",
            "FCCMPE  <Dn>, <Dm>, #<nzcv>, <cond>"
          ]
        }
      },
      "FCCMP_float": {
        "authored": "Floating-point Conditional quiet Compare (scalar). This instruction compares the\ntwo SIMD&FP source register values and writes the result to the PSTATE.{N, Z, C,\nV} flags. If the condition does not pass then the PSTATE.{N, Z, C, V} flags are\nset to the flag bit specifier.\n\nThis instruction raises an Invalid Operation floating-point exception if either\nor both of the operands is a signaling NaN.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FCCMP",
        "templates": {
          "FLOAT": [
            "FCCMP  <Hn>, <Hm>, #<nzcv>, <cond>",
            "FCCMP  <Sn>, <Sm>, #<nzcv>, <cond>",
            "FCCMP  <Dn>, <Dm>, #<nzcv>, <cond>"
          ]
        }
      },
      "FCMEQ_advsimd_reg": {
        "authored": "Floating-point Compare Equal (vector). This instruction compares each floating-\npoint value from the first source SIMD&FP register, with the corresponding\nfloating-point value from the second source SIMD&FP register, and if the\ncomparison is equal sets every bit of the corresponding vector element in the\ndestination SIMD&FP register to one, otherwise sets every bit of the\ncorresponding vector element in the destination SIMD&FP register to zero.\n\nThis instruction can generate a floating-point exception. Depending on the\nsettings in FPCR, the exception results in either a flag being set in FPSR, or a\nsynchronous exception being generated. For more information, see Floating-point\nexception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FCMEQ (register)",
        "templates": {
          "SIMD_HALF": [
            "FCMEQ  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ],
          "SIMD_SINGLE_AND_DOUBLE": [
            "FCMEQ  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ],
          "SISD_HALF": [
            "FCMEQ  <Hd>, <Hn>, <Hm>"
          ],
          "SISD_SINGLE_AND_DOUBLE": [
            "FCMEQ  <V><d>, <V><n>, <V><m>"
          ]
        }
      },
      "FCMEQ_advsimd_zero": {
        "authored": "Floating-point Compare Equal to zero (vector). This instruction reads each\nfloating-point value in the source SIMD&FP register and if the value is equal to\nzero sets every bit of the corresponding vector element in the destination\nSIMD&FP register to one, otherwise sets every bit of the corresponding vector\nelement in the destination SIMD&FP register to zero.\n\nThis instruction can generate a floating-point exception. Depending on the\nsettings in FPCR, the exception results in either a flag being set in FPSR, or a\nsynchronous exception being generated. For more information, see Floating-point\nexception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FCMEQ (zero)",
        "templates": {
          "SIMD_HALF": [
            "FCMEQ  <Vd>.<T>, <Vn>.<T>, #0.0"
          ],
          "SIMD_SINGLE_AND_DOUBLE": [
            "FCMEQ  <Vd>.<T>, <Vn>.<T>, #0.0"
          ],
          "SISD_HALF": [
            "FCMEQ  <Hd>, <Hn>, #0.0"
          ],
          "SISD_SINGLE_AND_DOUBLE": [
            "FCMEQ  <V><d>, <V><n>, #0.0"
          ]
        }
      },
      "FCMGE_advsimd_reg": {
        "authored": "Floating-point Compare Greater than or Equal (vector). This instruction reads\neach floating-point value in the first source SIMD&FP register and if the value\nis greater than or equal to the corresponding floating-point value in the second\nsource SIMD&FP register sets every bit of the corresponding vector element in\nthe destination SIMD&FP register to one, otherwise sets every bit of the\ncorresponding vector element in the destination SIMD&FP register to zero.\n\nThis instruction can generate a floating-point exception. Depending on the\nsettings in FPCR, the exception results in either a flag being set in FPSR, or a\nsynchronous exception being generated. For more information, see Floating-point\nexception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FCMGE (register)",
        "templates": {
          "SIMD_HALF": [
            "FCMGE  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ],
          "SIMD_SINGLE_AND_DOUBLE": [
            "FCMGE  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ],
          "SISD_HALF": [
            "FCMGE  <Hd>, <Hn>, <Hm>"
          ],
          "SISD_SINGLE_AND_DOUBLE": [
            "FCMGE  <V><d>, <V><n>, <V><m>"
          ]
        }
      },
      "FCMGE_advsimd_zero": {
        "authored": "Floating-point Compare Greater than or Equal to zero (vector). This instruction\nreads each floating-point value in the source SIMD&FP register and if the value\nis greater than or equal to zero sets every bit of the corresponding vector\nelement in the destination SIMD&FP register to one, otherwise sets every bit of\nthe corresponding vector element in the destination SIMD&FP register to zero.\n\nThis instruction can generate a floating-point exception. Depending on the\nsettings in FPCR, the exception results in either a flag being set in FPSR, or a\nsynchronous exception being generated. For more information, see Floating-point\nexception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FCMGE (zero)",
        "templates": {
          "SIMD_HALF": [
            "FCMGE  <Vd>.<T>, <Vn>.<T>, #0.0"
          ],
          "SIMD_SINGLE_AND_DOUBLE": [
            "FCMGE  <Vd>.<T>, <Vn>.<T>, #0.0"
          ],
          "SISD_HALF": [
            "FCMGE  <Hd>, <Hn>, #0.0"
          ],
          "SISD_SINGLE_AND_DOUBLE": [
            "FCMGE  <V><d>, <V><n>, #0.0"
          ]
        }
      },
      "FCMGT_advsimd_reg": {
        "authored": "Floating-point Compare Greater than (vector). This instruction reads each\nfloating-point value in the first source SIMD&FP register and if the value is\ngreater than the corresponding floating-point value in the second source SIMD&FP\nregister sets every bit of the corresponding vector element in the destination\nSIMD&FP register to one, otherwise sets every bit of the corresponding vector\nelement in the destination SIMD&FP register to zero.\n\nThis instruction can generate a floating-point exception. Depending on the\nsettings in FPCR, the exception results in either a flag being set in FPSR, or a\nsynchronous exception being generated. For more information, see Floating-point\nexception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FCMGT (register)",
        "templates": {
          "SIMD_HALF": [
            "FCMGT  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ],
          "SIMD_SINGLE_AND_DOUBLE": [
            "FCMGT  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ],
          "SISD_HALF": [
            "FCMGT  <Hd>, <Hn>, <Hm>"
          ],
          "SISD_SINGLE_AND_DOUBLE": [
            "FCMGT  <V><d>, <V><n>, <V><m>"
          ]
        }
      },
      "FCMGT_advsimd_zero": {
        "authored": "Floating-point Compare Greater than zero (vector). This instruction reads each\nfloating-point value in the source SIMD&FP register and if the value is greater\nthan zero sets every bit of the corresponding vector element in the destination\nSIMD&FP register to one, otherwise sets every bit of the corresponding vector\nelement in the destination SIMD&FP register to zero.\n\nThis instruction can generate a floating-point exception. Depending on the\nsettings in FPCR, the exception results in either a flag being set in FPSR, or a\nsynchronous exception being generated. For more information, see Floating-point\nexception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FCMGT (zero)",
        "templates": {
          "SIMD_HALF": [
            "FCMGT  <Vd>.<T>, <Vn>.<T>, #0.0"
          ],
          "SIMD_SINGLE_AND_DOUBLE": [
            "FCMGT  <Vd>.<T>, <Vn>.<T>, #0.0"
          ],
          "SISD_HALF": [
            "FCMGT  <Hd>, <Hn>, #0.0"
          ],
          "SISD_SINGLE_AND_DOUBLE": [
            "FCMGT  <V><d>, <V><n>, #0.0"
          ]
        }
      },
      "FCMLA_advsimd_elt": {
        "authored": "Floating-point Complex Multiply Accumulate (by element).\n\nThis instruction operates on complex numbers that are represented in SIMD&FP\nregisters as pairs of elements, with the more significant element holding the\nimaginary part of the number and the less significant element holding the real\npart of the number. Each element holds a floating-point value. It performs the\nfollowing computation on complex numbers from the first source register and the\ndestination register with the specified complex number from the second source\nregister:\n  - Considering the complex number from the second source register on an Argand\ndiagram, the number is rotated counterclockwise by 0, 90, 180, or 270 degrees.\n  - The two elements of the transformed complex number are multiplied by:\n    - The real element of the complex number from the first source register, if\nthe transformation was a rotation by 0 or 180 degrees.\n    - The imaginary element of the complex number from the first source\nregister, if the transformation was a rotation by 90 or 270 degrees.\n  - The complex number resulting from that multiplication is added to the\ncomplex number from the destination register.\n\nThe multiplication and addition operations are performed as a fused multiply-\nadd, without any intermediate rounding.\n\nThis instruction can generate a floating-point exception. Depending on the\nsettings in FPCR, the exception results in either a flag being set in FPSR or a\nsynchronous exception being generated. For more information, see Floating-point\nexception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FCMLA (by element)",
        "templates": {
          "2REG_ELEMENT": [
            "FCMLA  <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>], #<rotate>",
            "FCMLA  <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>], #<rotate>"
          ]
        }
      },
      "FCMLA_advsimd_vec": {
        "authored": "Floating-point Complex Multiply Accumulate.\n\nThis instruction operates on complex numbers that are represented in SIMD&FP\nregisters as pairs of elements, with the more significant element holding the\nimaginary part of the number and the less significant element holding the real\npart of the number. Each element holds a floating-point value. It performs the\nfollowing computation on the corresponding complex number element pairs from the\ntwo source registers and the destination register:\n  - Considering the complex number from the second source register on an Argand\ndiagram, the number is rotated counterclockwise by 0, 90, 180, or 270 degrees.\n  - The two elements of the transformed complex number are multiplied by:\n    - The real element of the complex number from the first source register, if\nthe transformation was a rotation by 0 or 180 degrees.\n    - The imaginary element of the complex number from the first source\nregister, if the transformation was a rotation by 90 or 270 degrees.\n  - The complex number resulting from that multiplication is added to the\ncomplex number from the destination register.\n\nThe multiplication and addition operations are performed as a fused multiply-\nadd, without any intermediate rounding.\n\nThis instruction can generate a floating-point exception. Depending on the\nsettings in FPCR, the exception results in either a flag being set in FPSR or a\nsynchronous exception being generated. For more information, see Floating-point\nexception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FCMLA",
        "templates": {
          "SIMD": [
            "FCMLA  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>, #<rotate>"
          ]
        }
      },
      "FCMLE_advsimd": {
        "authored": "Floating-point Compare Less than or Equal to zero (vector). This instruction\nreads each floating-point value in the source SIMD&FP register and if the value\nis less than or equal to zero sets every bit of the corresponding vector element\nin the destination SIMD&FP register to one, otherwise sets every bit of the\ncorresponding vector element in the destination SIMD&FP register to zero.\n\nThis instruction can generate a floating-point exception. Depending on the\nsettings in FPCR, the exception results in either a flag being set in FPSR, or a\nsynchronous exception being generated. For more information, see Floating-point\nexception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FCMLE (zero)",
        "templates": {
          "SIMD_HALF": [
            "FCMLE  <Vd>.<T>, <Vn>.<T>, #0.0"
          ],
          "SIMD_SINGLE_AND_DOUBLE": [
            "FCMLE  <Vd>.<T>, <Vn>.<T>, #0.0"
          ],
          "SISD_HALF": [
            "FCMLE  <Hd>, <Hn>, #0.0"
          ],
          "SISD_SINGLE_AND_DOUBLE": [
            "FCMLE  <V><d>, <V><n>, #0.0"
          ]
        }
      },
      "FCMLT_advsimd": {
        "authored": "Floating-point Compare Less than zero (vector). This instruction reads each\nfloating-point value in the source SIMD&FP register and if the value is less\nthan zero sets every bit of the corresponding vector element in the destination\nSIMD&FP register to one, otherwise sets every bit of the corresponding vector\nelement in the destination SIMD&FP register to zero.\n\nThis instruction can generate a floating-point exception. Depending on the\nsettings in FPCR, the exception results in either a flag being set in FPSR, or a\nsynchronous exception being generated. For more information, see Floating-point\nexception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FCMLT (zero)",
        "templates": {
          "SIMD_HALF": [
            "FCMLT  <Vd>.<T>, <Vn>.<T>, #0.0"
          ],
          "SIMD_SINGLE_AND_DOUBLE": [
            "FCMLT  <Vd>.<T>, <Vn>.<T>, #0.0"
          ],
          "SISD_HALF": [
            "FCMLT  <Hd>, <Hn>, #0.0"
          ],
          "SISD_SINGLE_AND_DOUBLE": [
            "FCMLT  <V><d>, <V><n>, #0.0"
          ]
        }
      },
      "FCMPE_float": {
        "authored": "Floating-point signaling Compare (scalar). This instruction compares the two\nSIMD&FP source register values, or the first SIMD&FP source register value and\nzero. It writes the result to the PSTATE.{N, Z, C, V} flags.\n\nThis instruction raises an Invalid Operation floating-point exception if either\nor both of the operands is any type of NaN.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FCMPE",
        "templates": {
          "FLOAT": [
            "FCMPE  <Hn>, <Hm>",
            "FCMPE  <Hn>, #0.0",
            "FCMPE  <Sn>, <Sm>",
            "FCMPE  <Sn>, #0.0",
            "FCMPE  <Dn>, <Dm>",
            "FCMPE  <Dn>, #0.0"
          ]
        }
      },
      "FCMP_float": {
        "authored": "Floating-point quiet Compare (scalar). This instruction compares the two SIMD&FP\nsource register values, or the first SIMD&FP source register value and zero. It\nwrites the result to the PSTATE.{N, Z, C, V} flags.\n\nThis instruction raises an Invalid Operation floating-point exception if either\nor both of the operands is a signaling NaN.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FCMP",
        "templates": {
          "FLOAT": [
            "FCMP  <Hn>, <Hm>",
            "FCMP  <Hn>, #0.0",
            "FCMP  <Sn>, <Sm>",
            "FCMP  <Sn>, #0.0",
            "FCMP  <Dn>, <Dm>",
            "FCMP  <Dn>, #0.0"
          ]
        }
      },
      "FCSEL_float": {
        "authored": "Floating-point Conditional Select (scalar). This instruction allows the SIMD&FP\ndestination register to take the value from either one or the other of two\nSIMD&FP source registers. If the condition passes, the first SIMD&FP source\nregister value is taken, otherwise the second SIMD&FP source register value is\ntaken.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FCSEL",
        "templates": {
          "FLOAT": [
            "FCSEL  <Hd>, <Hn>, <Hm>, <cond>",
            "FCSEL  <Sd>, <Sn>, <Sm>, <cond>",
            "FCSEL  <Dd>, <Dn>, <Dm>, <cond>"
          ]
        }
      },
      "FCVTAS_advsimd": {
        "authored": "Floating-point Convert to Signed integer, rounding to nearest with ties to Away\n(vector). This instruction converts each element in a vector from a floating-\npoint value to a signed integer value using the Round to Nearest with Ties to\nAway rounding mode and writes the result to the SIMD&FP destination register.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FCVTAS (vector)",
        "templates": {
          "SIMD_HALF": [
            "FCVTAS  <Vd>.<T>, <Vn>.<T>"
          ],
          "SIMD_SINGLE_AND_DOUBLE": [
            "FCVTAS  <Vd>.<T>, <Vn>.<T>"
          ],
          "SISD_HALF": [
            "FCVTAS  <Hd>, <Hn>"
          ],
          "SISD_SINGLE_AND_DOUBLE": [
            "FCVTAS  <V><d>, <V><n>"
          ]
        }
      },
      "FCVTAS_float": {
        "authored": "Floating-point Convert to Signed integer, rounding to nearest with ties to Away\n(scalar). This instruction converts the floating-point value in the SIMD&FP\nsource register to a 32-bit or 64-bit signed integer using the Round to Nearest\nwith Ties to Away rounding mode, and writes the result to the general-purpose\ndestination register.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FCVTAS (scalar)",
        "templates": {
          "FLOAT": [
            "FCVTAS  <Wd>, <Hn>",
            "FCVTAS  <Xd>, <Hn>",
            "FCVTAS  <Wd>, <Sn>",
            "FCVTAS  <Xd>, <Sn>",
            "FCVTAS  <Wd>, <Dn>",
            "FCVTAS  <Xd>, <Dn>"
          ]
        }
      },
      "FCVTAU_advsimd": {
        "authored": "Floating-point Convert to Unsigned integer, rounding to nearest with ties to\nAway (vector). This instruction converts each element in a vector from a\nfloating-point value to an unsigned integer value using the Round to Nearest\nwith Ties to Away rounding mode and writes the result to the SIMD&FP destination\nregister.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FCVTAU (vector)",
        "templates": {
          "SIMD_HALF": [
            "FCVTAU  <Vd>.<T>, <Vn>.<T>"
          ],
          "SIMD_SINGLE_AND_DOUBLE": [
            "FCVTAU  <Vd>.<T>, <Vn>.<T>"
          ],
          "SISD_HALF": [
            "FCVTAU  <Hd>, <Hn>"
          ],
          "SISD_SINGLE_AND_DOUBLE": [
            "FCVTAU  <V><d>, <V><n>"
          ]
        }
      },
      "FCVTAU_float": {
        "authored": "Floating-point Convert to Unsigned integer, rounding to nearest with ties to\nAway (scalar). This instruction converts the floating-point value in the SIMD&FP\nsource register to a 32-bit or 64-bit unsigned integer using the Round to\nNearest with Ties to Away rounding mode, and writes the result to the general-\npurpose destination register.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FCVTAU (scalar)",
        "templates": {
          "FLOAT": [
            "FCVTAU  <Wd>, <Hn>",
            "FCVTAU  <Xd>, <Hn>",
            "FCVTAU  <Wd>, <Sn>",
            "FCVTAU  <Xd>, <Sn>",
            "FCVTAU  <Wd>, <Dn>",
            "FCVTAU  <Xd>, <Dn>"
          ]
        }
      },
      "FCVTL_advsimd": {
        "authored": "Floating-point Convert to higher precision Long (vector). This instruction reads\neach element in a vector in the SIMD&FP source register, converts each value to\ndouble the precision of the source element using the rounding mode that is\ndetermined by the FPCR, and writes each result to the equivalent element of the\nvector in the SIMD&FP destination register.\n\nWhere the operation lengthens a 64-bit vector to a 128-bit vector, the FCVTL2\nvariant operates on the elements in the top 64 bits of the source register.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FCVTL, FCVTL2",
        "templates": {
          "SIMD_SINGLE_AND_DOUBLE": [
            "FCVTL{2}  <Vd>.<Ta>, <Vn>.<Tb>"
          ]
        }
      },
      "FCVTMS_advsimd": {
        "authored": "Floating-point Convert to Signed integer, rounding toward Minus infinity\n(vector). This instruction converts a scalar or each element in a vector from a\nfloating-point value to a signed integer value using the Round towards Minus\nInfinity rounding mode, and writes the result to the SIMD&FP destination\nregister.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the Security state and Exception level in which the instruction is executed,\nan attempt to execute the instruction might be trapped.",
        "heading": "FCVTMS (vector)",
        "templates": {
          "SIMD_HALF": [
            "FCVTMS  <Vd>.<T>, <Vn>.<T>"
          ],
          "SIMD_SINGLE_AND_DOUBLE": [
            "FCVTMS  <Vd>.<T>, <Vn>.<T>"
          ],
          "SISD_HALF": [
            "FCVTMS  <Hd>, <Hn>"
          ],
          "SISD_SINGLE_AND_DOUBLE": [
            "FCVTMS  <V><d>, <V><n>"
          ]
        }
      },
      "FCVTMS_float": {
        "authored": "Floating-point Convert to Signed integer, rounding toward Minus infinity\n(scalar). This instruction converts the floating-point value in the SIMD&FP\nsource register to a 32-bit or 64-bit signed integer using the Round towards\nMinus Infinity rounding mode, and writes the result to the general-purpose\ndestination register.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FCVTMS (scalar)",
        "templates": {
          "FLOAT": [
            "FCVTMS  <Wd>, <Hn>",
            "FCVTMS  <Xd>, <Hn>",
            "FCVTMS  <Wd>, <Sn>",
            "FCVTMS  <Xd>, <Sn>",
            "FCVTMS  <Wd>, <Dn>",
            "FCVTMS  <Xd>, <Dn>"
          ]
        }
      },
      "FCVTMU_advsimd": {
        "authored": "Floating-point Convert to Unsigned integer, rounding toward Minus infinity\n(vector). This instruction converts a scalar or each element in a vector from a\nfloating-point value to an unsigned integer value using the Round towards Minus\nInfinity rounding mode, and writes the result to the SIMD&FP destination\nregister.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the Security state and Exception level in which the instruction is executed,\nan attempt to execute the instruction might be trapped.",
        "heading": "FCVTMU (vector)",
        "templates": {
          "SIMD_HALF": [
            "FCVTMU  <Vd>.<T>, <Vn>.<T>"
          ],
          "SIMD_SINGLE_AND_DOUBLE": [
            "FCVTMU  <Vd>.<T>, <Vn>.<T>"
          ],
          "SISD_HALF": [
            "FCVTMU  <Hd>, <Hn>"
          ],
          "SISD_SINGLE_AND_DOUBLE": [
            "FCVTMU  <V><d>, <V><n>"
          ]
        }
      },
      "FCVTMU_float": {
        "authored": "Floating-point Convert to Unsigned integer, rounding toward Minus infinity\n(scalar). This instruction converts the floating-point value in the SIMD&FP\nsource register to a 32-bit or 64-bit unsigned integer using the Round towards\nMinus Infinity rounding mode, and writes the result to the general-purpose\ndestination register.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FCVTMU (scalar)",
        "templates": {
          "FLOAT": [
            "FCVTMU  <Wd>, <Hn>",
            "FCVTMU  <Xd>, <Hn>",
            "FCVTMU  <Wd>, <Sn>",
            "FCVTMU  <Xd>, <Sn>",
            "FCVTMU  <Wd>, <Dn>",
            "FCVTMU  <Xd>, <Dn>"
          ]
        }
      },
      "FCVTNS_advsimd": {
        "authored": "Floating-point Convert to Signed integer, rounding to nearest with ties to even\n(vector). This instruction converts a scalar or each element in a vector from a\nfloating-point value to a signed integer value using the Round to Nearest\nrounding mode, and writes the result to the SIMD&FP destination register.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the Security state and Exception level in which the instruction is executed,\nan attempt to execute the instruction might be trapped.",
        "heading": "FCVTNS (vector)",
        "templates": {
          "SIMD_HALF": [
            "FCVTNS  <Vd>.<T>, <Vn>.<T>"
          ],
          "SIMD_SINGLE_AND_DOUBLE": [
            "FCVTNS  <Vd>.<T>, <Vn>.<T>"
          ],
          "SISD_HALF": [
            "FCVTNS  <Hd>, <Hn>"
          ],
          "SISD_SINGLE_AND_DOUBLE": [
            "FCVTNS  <V><d>, <V><n>"
          ]
        }
      },
      "FCVTNS_float": {
        "authored": "Floating-point Convert to Signed integer, rounding to nearest with ties to even\n(scalar). This instruction converts the floating-point value in the SIMD&FP\nsource register to a 32-bit or 64-bit signed integer using the Round to Nearest\nrounding mode, and writes the result to the general-purpose destination\nregister.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FCVTNS (scalar)",
        "templates": {
          "FLOAT": [
            "FCVTNS  <Wd>, <Hn>",
            "FCVTNS  <Xd>, <Hn>",
            "FCVTNS  <Wd>, <Sn>",
            "FCVTNS  <Xd>, <Sn>",
            "FCVTNS  <Wd>, <Dn>",
            "FCVTNS  <Xd>, <Dn>"
          ]
        }
      },
      "FCVTNU_advsimd": {
        "authored": "Floating-point Convert to Unsigned integer, rounding to nearest with ties to\neven (vector). This instruction converts a scalar or each element in a vector\nfrom a floating-point value to an unsigned integer value using the Round to\nNearest rounding mode, and writes the result to the SIMD&FP destination\nregister.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the Security state and Exception level in which the instruction is executed,\nan attempt to execute the instruction might be trapped.",
        "heading": "FCVTNU (vector)",
        "templates": {
          "SIMD_HALF": [
            "FCVTNU  <Vd>.<T>, <Vn>.<T>"
          ],
          "SIMD_SINGLE_AND_DOUBLE": [
            "FCVTNU  <Vd>.<T>, <Vn>.<T>"
          ],
          "SISD_HALF": [
            "FCVTNU  <Hd>, <Hn>"
          ],
          "SISD_SINGLE_AND_DOUBLE": [
            "FCVTNU  <V><d>, <V><n>"
          ]
        }
      },
      "FCVTNU_float": {
        "authored": "Floating-point Convert to Unsigned integer, rounding to nearest with ties to\neven (scalar). This instruction converts the floating-point value in the SIMD&FP\nsource register to a 32-bit or 64-bit unsigned integer using the Round to\nNearest rounding mode, and writes the result to the general-purpose destination\nregister.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FCVTNU (scalar)",
        "templates": {
          "FLOAT": [
            "FCVTNU  <Wd>, <Hn>",
            "FCVTNU  <Xd>, <Hn>",
            "FCVTNU  <Wd>, <Sn>",
            "FCVTNU  <Xd>, <Sn>",
            "FCVTNU  <Wd>, <Dn>",
            "FCVTNU  <Xd>, <Dn>"
          ]
        }
      },
      "FCVTN_advsimd": {
        "authored": "Floating-point Convert to lower precision Narrow (vector). This instruction\nreads each vector element in the SIMD&FP source register, converts each result\nto half the precision of the source element, writes the final result to a\nvector, and writes the vector to the lower or upper half of the destination\nSIMD&FP register. The destination vector elements are half as long as the source\nvector elements. The rounding mode is determined by the FPCR.\n\nThe FCVTN instruction writes the vector to the lower half of the destination\nregister and clears the upper half, while the FCVTN2 instruction writes the\nvector to the upper half of the destination register without affecting the other\nbits of the register.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the Security state and Exception level in which the instruction is executed,\nan attempt to execute the instruction might be trapped.",
        "heading": "FCVTN, FCVTN2",
        "templates": {
          "SIMD_SINGLE_AND_DOUBLE": [
            "FCVTN{2}  <Vd>.<Tb>, <Vn>.<Ta>"
          ]
        }
      },
      "FCVTPS_advsimd": {
        "authored": "Floating-point Convert to Signed integer, rounding toward Plus infinity\n(vector). This instruction converts a scalar or each element in a vector from a\nfloating-point value to a signed integer value using the Round towards Plus\nInfinity rounding mode, and writes the result to the SIMD&FP destination\nregister.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the Security state and Exception level in which the instruction is executed,\nan attempt to execute the instruction might be trapped.",
        "heading": "FCVTPS (vector)",
        "templates": {
          "SIMD_HALF": [
            "FCVTPS  <Vd>.<T>, <Vn>.<T>"
          ],
          "SIMD_SINGLE_AND_DOUBLE": [
            "FCVTPS  <Vd>.<T>, <Vn>.<T>"
          ],
          "SISD_HALF": [
            "FCVTPS  <Hd>, <Hn>"
          ],
          "SISD_SINGLE_AND_DOUBLE": [
            "FCVTPS  <V><d>, <V><n>"
          ]
        }
      },
      "FCVTPS_float": {
        "authored": "Floating-point Convert to Signed integer, rounding toward Plus infinity\n(scalar). This instruction converts the floating-point value in the SIMD&FP\nsource register to a 32-bit or 64-bit signed integer using the Round towards\nPlus Infinity rounding mode, and writes the result to the general-purpose\ndestination register.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FCVTPS (scalar)",
        "templates": {
          "FLOAT": [
            "FCVTPS  <Wd>, <Hn>",
            "FCVTPS  <Xd>, <Hn>",
            "FCVTPS  <Wd>, <Sn>",
            "FCVTPS  <Xd>, <Sn>",
            "FCVTPS  <Wd>, <Dn>",
            "FCVTPS  <Xd>, <Dn>"
          ]
        }
      },
      "FCVTPU_advsimd": {
        "authored": "Floating-point Convert to Unsigned integer, rounding toward Plus infinity\n(vector). This instruction converts a scalar or each element in a vector from a\nfloating-point value to an unsigned integer value using the Round towards Plus\nInfinity rounding mode, and writes the result to the SIMD&FP destination\nregister.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the Security state and Exception level in which the instruction is executed,\nan attempt to execute the instruction might be trapped.",
        "heading": "FCVTPU (vector)",
        "templates": {
          "SIMD_HALF": [
            "FCVTPU  <Vd>.<T>, <Vn>.<T>"
          ],
          "SIMD_SINGLE_AND_DOUBLE": [
            "FCVTPU  <Vd>.<T>, <Vn>.<T>"
          ],
          "SISD_HALF": [
            "FCVTPU  <Hd>, <Hn>"
          ],
          "SISD_SINGLE_AND_DOUBLE": [
            "FCVTPU  <V><d>, <V><n>"
          ]
        }
      },
      "FCVTPU_float": {
        "authored": "Floating-point Convert to Unsigned integer, rounding toward Plus infinity\n(scalar). This instruction converts the floating-point value in the SIMD&FP\nsource register to a 32-bit or 64-bit unsigned integer using the Round towards\nPlus Infinity rounding mode, and writes the result to the general-purpose\ndestination register.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FCVTPU (scalar)",
        "templates": {
          "FLOAT": [
            "FCVTPU  <Wd>, <Hn>",
            "FCVTPU  <Xd>, <Hn>",
            "FCVTPU  <Wd>, <Sn>",
            "FCVTPU  <Xd>, <Sn>",
            "FCVTPU  <Wd>, <Dn>",
            "FCVTPU  <Xd>, <Dn>"
          ]
        }
      },
      "FCVTXN_advsimd": {
        "authored": "Floating-point Convert to lower precision Narrow, rounding to odd (vector). This\ninstruction reads each vector element in the source SIMD&FP register, narrows\neach value to half the precision of the source element using the Round to Odd\nrounding mode, writes the result to a vector, and writes the vector to the\ndestination SIMD&FP register.\n\nThis instruction uses the Round to Odd rounding mode which is not defined by the\nIEEE 754-2008 standard. This rounding mode ensures that if the result of the\nconversion is inexact the least significant bit of the mantissa is forced to 1.\nThis rounding mode enables a floating-point value to be converted to a lower\nprecision format via an intermediate precision format while avoiding double\nrounding errors. For example, a 64-bit floating-point value can be converted to\na correctly rounded 16-bit floating-point value by first using this instruction\nto produce a 32-bit value and then using another instruction with the wanted\nrounding mode to convert the 32-bit value to the final 16-bit floating-point\nvalue.\n\nThe FCVTXN instruction writes the vector to the lower half of the destination\nregister and clears the upper half, while the FCVTXN2 instruction writes the\nvector to the upper half of the destination register without affecting the other\nbits of the register.\n\nThis instruction can generate a floating-point exception. Depending on the\nsettings in FPCR, the exception results in either a flag being set in FPSR or a\nsynchronous exception being generated. For more information, see Floating-point\nexception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FCVTXN, FCVTXN2",
        "templates": {
          "SIMD": [
            "FCVTXN{2}  <Vd>.<Tb>, <Vn>.<Ta>"
          ],
          "SISD": [
            "FCVTXN  <Vb><d>, <Va><n>"
          ]
        }
      },
      "FCVTZS_advsimd_fix": {
        "authored": "Floating-point Convert to Signed fixed-point, rounding toward Zero (vector).\nThis instruction converts a scalar or each element in a vector from floating-\npoint to fixed-point signed integer using the Round towards Zero rounding mode,\nand writes the result to the SIMD&FP destination register.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the Security state and Exception level in which the instruction is executed,\nan attempt to execute the instruction might be trapped.",
        "heading": "FCVTZS (vector, fixed-point)",
        "templates": {
          "SIMD": [
            "FCVTZS  <Vd>.<T>, <Vn>.<T>, #<fbits>"
          ],
          "SISD": [
            "FCVTZS  <V><d>, <V><n>, #<fbits>"
          ]
        }
      },
      "FCVTZS_advsimd_int": {
        "authored": "Floating-point Convert to Signed integer, rounding toward Zero (vector). This\ninstruction converts a scalar or each element in a vector from a floating-point\nvalue to a signed integer value using the Round towards Zero rounding mode, and\nwrites the result to the SIMD&FP destination register.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the Security state and Exception level in which the instruction is executed,\nan attempt to execute the instruction might be trapped.",
        "heading": "FCVTZS (vector, integer)",
        "templates": {
          "SIMD_HALF": [
            "FCVTZS  <Vd>.<T>, <Vn>.<T>"
          ],
          "SIMD_SINGLE_AND_DOUBLE": [
            "FCVTZS  <Vd>.<T>, <Vn>.<T>"
          ],
          "SISD_HALF": [
            "FCVTZS  <Hd>, <Hn>"
          ],
          "SISD_SINGLE_AND_DOUBLE": [
            "FCVTZS  <V><d>, <V><n>"
          ]
        }
      },
      "FCVTZS_float_fix": {
        "authored": "Floating-point Convert to Signed fixed-point, rounding toward Zero (scalar).\nThis instruction converts the floating-point value in the SIMD&FP source\nregister to a 32-bit or 64-bit fixed-point signed integer using the Round\ntowards Zero rounding mode, and writes the result to the general-purpose\ndestination register.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the Security state and Exception level in which the instruction is executed,\nan attempt to execute the instruction might be trapped.",
        "heading": "FCVTZS (scalar, fixed-point)",
        "templates": {
          "FLOAT": [
            "FCVTZS  <Wd>, <Hn>, #<fbits>",
            "FCVTZS  <Xd>, <Hn>, #<fbits>",
            "FCVTZS  <Wd>, <Sn>, #<fbits>",
            "FCVTZS  <Xd>, <Sn>, #<fbits>",
            "FCVTZS  <Wd>, <Dn>, #<fbits>",
            "FCVTZS  <Xd>, <Dn>, #<fbits>"
          ]
        }
      },
      "FCVTZS_float_int": {
        "authored": "Floating-point Convert to Signed integer, rounding toward Zero (scalar). This\ninstruction converts the floating-point value in the SIMD&FP source register to\na 32-bit or 64-bit signed integer using the Round towards Zero rounding mode,\nand writes the result to the general-purpose destination register.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FCVTZS (scalar, integer)",
        "templates": {
          "FLOAT": [
            "FCVTZS  <Wd>, <Hn>",
            "FCVTZS  <Xd>, <Hn>",
            "FCVTZS  <Wd>, <Sn>",
            "FCVTZS  <Xd>, <Sn>",
            "FCVTZS  <Wd>, <Dn>",
            "FCVTZS  <Xd>, <Dn>"
          ]
        }
      },
      "FCVTZU_advsimd_fix": {
        "authored": "Floating-point Convert to Unsigned fixed-point, rounding toward Zero (vector).\nThis instruction converts a scalar or each element in a vector from floating-\npoint to fixed-point unsigned integer using the Round towards Zero rounding\nmode, and writes the result to the general-purpose destination register.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the Security state and Exception level in which the instruction is executed,\nan attempt to execute the instruction might be trapped.",
        "heading": "FCVTZU (vector, fixed-point)",
        "templates": {
          "SIMD": [
            "FCVTZU  <Vd>.<T>, <Vn>.<T>, #<fbits>"
          ],
          "SISD": [
            "FCVTZU  <V><d>, <V><n>, #<fbits>"
          ]
        }
      },
      "FCVTZU_advsimd_int": {
        "authored": "Floating-point Convert to Unsigned integer, rounding toward Zero (vector). This\ninstruction converts a scalar or each element in a vector from a floating-point\nvalue to an unsigned integer value using the Round towards Zero rounding mode,\nand writes the result to the SIMD&FP destination register.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the Security state and Exception level in which the instruction is executed,\nan attempt to execute the instruction might be trapped.",
        "heading": "FCVTZU (vector, integer)",
        "templates": {
          "SIMD_HALF": [
            "FCVTZU  <Vd>.<T>, <Vn>.<T>"
          ],
          "SIMD_SINGLE_AND_DOUBLE": [
            "FCVTZU  <Vd>.<T>, <Vn>.<T>"
          ],
          "SISD_HALF": [
            "FCVTZU  <Hd>, <Hn>"
          ],
          "SISD_SINGLE_AND_DOUBLE": [
            "FCVTZU  <V><d>, <V><n>"
          ]
        }
      },
      "FCVTZU_float_fix": {
        "authored": "Floating-point Convert to Unsigned fixed-point, rounding toward Zero (scalar).\nThis instruction converts the floating-point value in the SIMD&FP source\nregister to a 32-bit or 64-bit fixed-point unsigned integer using the Round\ntowards Zero rounding mode, and writes the result to the general-purpose\ndestination register.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the Security state and Exception level in which the instruction is executed,\nan attempt to execute the instruction might be trapped.",
        "heading": "FCVTZU (scalar, fixed-point)",
        "templates": {
          "FLOAT": [
            "FCVTZU  <Wd>, <Hn>, #<fbits>",
            "FCVTZU  <Xd>, <Hn>, #<fbits>",
            "FCVTZU  <Wd>, <Sn>, #<fbits>",
            "FCVTZU  <Xd>, <Sn>, #<fbits>",
            "FCVTZU  <Wd>, <Dn>, #<fbits>",
            "FCVTZU  <Xd>, <Dn>, #<fbits>"
          ]
        }
      },
      "FCVTZU_float_int": {
        "authored": "Floating-point Convert to Unsigned integer, rounding toward Zero (scalar). This\ninstruction converts the floating-point value in the SIMD&FP source register to\na 32-bit or 64-bit unsigned integer using the Round towards Zero rounding mode,\nand writes the result to the general-purpose destination register.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FCVTZU (scalar, integer)",
        "templates": {
          "FLOAT": [
            "FCVTZU  <Wd>, <Hn>",
            "FCVTZU  <Xd>, <Hn>",
            "FCVTZU  <Wd>, <Sn>",
            "FCVTZU  <Xd>, <Sn>",
            "FCVTZU  <Wd>, <Dn>",
            "FCVTZU  <Xd>, <Dn>"
          ]
        }
      },
      "FCVT_float": {
        "authored": "Floating-point Convert precision (scalar). This instruction converts the\nfloating-point value in the SIMD&FP source register to the precision for the\ndestination register data type using the rounding mode that is determined by the\nFPCR and writes the result to the SIMD&FP destination register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FCVT",
        "templates": {
          "FLOAT": [
            "FCVT  <Sd>, <Hn>",
            "FCVT  <Dd>, <Hn>",
            "FCVT  <Hd>, <Sn>",
            "FCVT  <Dd>, <Sn>",
            "FCVT  <Hd>, <Dn>",
            "FCVT  <Sd>, <Dn>"
          ]
        }
      },
      "FDIV_advsimd": {
        "authored": "Floating-point Divide (vector). This instruction divides the floating-point\nvalues in the elements in the first source SIMD&FP register, by the floating-\npoint values in the corresponding elements in the second source SIMD&FP\nregister, places the results in a vector, and writes the vector to the\ndestination SIMD&FP register.\n\nThis instruction can generate a floating-point exception. Depending on the\nsettings in FPCR, the exception results in either a flag being set in FPSR, or a\nsynchronous exception being generated. For more information, see Floating-point\nexception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FDIV (vector)",
        "templates": {
          "HALF": [
            "FDIV  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ],
          "SINGLE_AND_DOUBLE": [
            "FDIV  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ]
        }
      },
      "FDIV_float": {
        "authored": "Floating-point Divide (scalar). This instruction divides the floating-point\nvalue of the first source SIMD&FP register by the floating-point value of the\nsecond source SIMD&FP register, and writes the result to the destination SIMD&FP\nregister.\n\nThis instruction can generate a floating-point exception. Depending on the\nsettings in FPCR, the exception results in either a flag being set in FPSR, or a\nsynchronous exception being generated. For more information, see Floating-point\nexception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FDIV (scalar)",
        "templates": {
          "FLOAT": [
            "FDIV  <Hd>, <Hn>, <Hm>",
            "FDIV  <Sd>, <Sn>, <Sm>",
            "FDIV  <Dd>, <Dn>, <Dm>"
          ]
        }
      },
      "FJCVTZS": {
        "authored": "Floating-point Javascript Convert to Signed fixed-point, rounding toward Zero.\nThis instruction converts the double-precision floating-point value in the\nSIMD&FP source register to a 32-bit signed integer using the Round towards Zero\nrounding mode, and writes the result to the general-purpose destination\nregister. If the result is too large to be represented as a signed 32-bit\ninteger, then the result is the integer modulo 2^32, as held in a 32-bit signed\ninteger.\n\nThis instruction can generate a floating-point exception. Depending on the\nsettings in FPCR, the exception results in either a flag being set in FPSR or a\nsynchronous exception being generated. For more information, see Floating-point\nexception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FJCVTZS",
        "templates": {
          "DOUBLE_TO_32": [
            "FJCVTZS  <Wd>, <Dn>"
          ]
        }
      },
      "FMADD_float": {
        "authored": "Floating-point fused Multiply-Add (scalar). This instruction multiplies the\nvalues of the first two SIMD&FP source registers, adds the product to the value\nof the third SIMD&FP source register, and writes the result to the SIMD&FP\ndestination register.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FMADD",
        "templates": {
          "FLOAT": [
            "FMADD  <Hd>, <Hn>, <Hm>, <Ha>",
            "FMADD  <Sd>, <Sn>, <Sm>, <Sa>",
            "FMADD  <Dd>, <Dn>, <Dm>, <Da>"
          ]
        }
      },
      "FMAXNMP_advsimd_pair": {
        "authored": "Floating-point Maximum Number of Pair of elements (scalar). This instruction\ncompares two vector elements in the source SIMD&FP register and writes the\nlargest of the floating-point values as a scalar to the destination SIMD&FP\nregister.\n\nThis instruction can generate a floating-point exception. Depending on the\nsettings in FPCR, the exception results in either a flag being set in FPSR or a\nsynchronous exception being generated. For more information, see Floating-point\nexception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FMAXNMP (scalar)",
        "templates": {
          "HALF": [
            "FMAXNMP  <V><d>, <Vn>.<T>"
          ],
          "SINGLE_AND_DOUBLE": [
            "FMAXNMP  <V><d>, <Vn>.<T>"
          ]
        }
      },
      "FMAXNMP_advsimd_vec": {
        "authored": "Floating-point Maximum Number Pairwise (vector). This instruction creates a\nvector by concatenating the vector elements of the first source SIMD&FP register\nafter the vector elements of the second source SIMD&FP register, reads each pair\nof adjacent vector elements in the two source SIMD&FP registers, writes the\nlargest of each pair of values into a vector, and writes the vector to the\ndestination SIMD&FP register. All the values in this instruction are floating-\npoint values.\n\nNaNs are handled according to the IEEE 754-2008 standard. If one vector element\nis numeric and the other is a quiet NaN, the result is the numerical value,\notherwise the result is identical to FMAX (scalar).\n\nThis instruction can generate a floating-point exception. Depending on the\nsettings in FPCR, the exception results in either a flag being set in FPSR or a\nsynchronous exception being generated. For more information, see Floating-point\nexception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FMAXNMP (vector)",
        "templates": {
          "HALF": [
            "FMAXNMP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ],
          "SINGLE_AND_DOUBLE": [
            "FMAXNMP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ]
        }
      },
      "FMAXNMV_advsimd": {
        "authored": "Floating-point Maximum Number across Vector. This instruction compares all the\nvector elements in the source SIMD&FP register, and writes the largest of the\nvalues as a scalar to the destination SIMD&FP register. All the values in this\ninstruction are floating-point values.\n\nNaNs are handled according to the IEEE 754-2008 standard. If one vector element\nis numeric and the other is a quiet NaN, the result of the comparison is the\nnumerical value, otherwise the result is identical to FMAX (scalar).\n\nThis instruction can generate a floating-point exception. Depending on the\nsettings in FPCR, the exception results in either a flag being set in FPSR or a\nsynchronous exception being generated. For more information, see Floating-point\nexception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FMAXNMV",
        "templates": {
          "HALF": [
            "FMAXNMV  <V><d>, <Vn>.<T>"
          ],
          "SINGLE_AND_DOUBLE": [
            "FMAXNMV  <V><d>, <Vn>.<T>"
          ]
        }
      },
      "FMAXNM_advsimd": {
        "authored": "Floating-point Maximum Number (vector). This instruction compares corresponding\nvector elements in the two source SIMD&FP registers, writes the larger of the\ntwo floating-point values into a vector, and writes the vector to the\ndestination SIMD&FP register.\n\nNaNs are handled according to the IEEE 754-2008 standard. If one vector element\nis numeric and the other is a quiet NaN, the result placed in the vector is the\nnumerical value, otherwise the result is identical to FMAX (scalar).\n\nThis instruction can generate a floating-point exception. Depending on the\nsettings in FPCR, the exception results in either a flag being set in FPSR, or a\nsynchronous exception being generated. For more information, see Floating-point\nexception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FMAXNM (vector)",
        "templates": {
          "HALF": [
            "FMAXNM  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ],
          "SINGLE_AND_DOUBLE": [
            "FMAXNM  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ]
        }
      },
      "FMAXNM_float": {
        "authored": "Floating-point Maximum Number (scalar). This instruction compares the first and\nsecond source SIMD&FP register values, and writes the larger of the two\nfloating-point values to the destination SIMD&FP register.\n\nNaNs are handled according to the IEEE 754-2008 standard. If one vector element\nis numeric and the other is a quiet NaN, the result that is placed in the vector\nis the numerical value, otherwise the result is identical to FMAX (scalar).\n\nThis instruction can generate a floating-point exception. Depending on the\nsettings in FPCR, the exception results in either a flag being set in FPSR, or a\nsynchronous exception being generated. For more information, see Floating-point\nexception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FMAXNM (scalar)",
        "templates": {
          "FLOAT": [
            "FMAXNM  <Hd>, <Hn>, <Hm>",
            "FMAXNM  <Sd>, <Sn>, <Sm>",
            "FMAXNM  <Dd>, <Dn>, <Dm>"
          ]
        }
      },
      "FMAXP_advsimd_pair": {
        "authored": "Floating-point Maximum of Pair of elements (scalar). This instruction compares\ntwo vector elements in the source SIMD&FP register and writes the largest of the\nfloating-point values as a scalar to the destination SIMD&FP register.\n\nThis instruction can generate a floating-point exception. Depending on the\nsettings in FPCR, the exception results in either a flag being set in FPSR or a\nsynchronous exception being generated. For more information, see Floating-point\nexception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FMAXP (scalar)",
        "templates": {
          "HALF": [
            "FMAXP  <V><d>, <Vn>.<T>"
          ],
          "SINGLE_AND_DOUBLE": [
            "FMAXP  <V><d>, <Vn>.<T>"
          ]
        }
      },
      "FMAXP_advsimd_vec": {
        "authored": "Floating-point Maximum Pairwise (vector). This instruction creates a vector by\nconcatenating the vector elements of the first source SIMD&FP register after the\nvector elements of the second source SIMD&FP register, reads each pair of\nadjacent vector elements from the concatenated vector, writes the larger of each\npair of values into a vector, and writes the vector to the destination SIMD&FP\nregister. All the values in this instruction are floating-point values.\n\nThis instruction can generate a floating-point exception. Depending on the\nsettings in FPCR, the exception results in either a flag being set in FPSR or a\nsynchronous exception being generated. For more information, see Floating-point\nexception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FMAXP (vector)",
        "templates": {
          "HALF": [
            "FMAXP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ],
          "SINGLE_AND_DOUBLE": [
            "FMAXP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ]
        }
      },
      "FMAXV_advsimd": {
        "authored": "Floating-point Maximum across Vector. This instruction compares all the vector\nelements in the source SIMD&FP register, and writes the largest of the values as\na scalar to the destination SIMD&FP register. All the values in this instruction\nare floating-point values.\n\nThis instruction can generate a floating-point exception. Depending on the\nsettings in FPCR, the exception results in either a flag being set in FPSR or a\nsynchronous exception being generated. For more information, see Floating-point\nexception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FMAXV",
        "templates": {
          "HALF": [
            "FMAXV  <V><d>, <Vn>.<T>"
          ],
          "SINGLE_AND_DOUBLE": [
            "FMAXV  <V><d>, <Vn>.<T>"
          ]
        }
      },
      "FMAX_advsimd": {
        "authored": "Floating-point Maximum (vector). This instruction compares corresponding vector\nelements in the two source SIMD&FP registers, places the larger of each of the\ntwo floating-point values into a vector, and writes the vector to the\ndestination SIMD&FP register.\n\nThis instruction can generate a floating-point exception. Depending on the\nsettings in FPCR, the exception results in either a flag being set in FPSR, or a\nsynchronous exception being generated. For more information, see Floating-point\nexception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FMAX (vector)",
        "templates": {
          "HALF": [
            "FMAX  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ],
          "SINGLE_AND_DOUBLE": [
            "FMAX  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ]
        }
      },
      "FMAX_float": {
        "authored": "Floating-point Maximum (scalar). This instruction compares the two source\nSIMD&FP registers, and writes the larger of the two floating-point values to the\ndestination SIMD&FP register.\n\nThis instruction can generate a floating-point exception. Depending on the\nsettings in FPCR, the exception results in either a flag being set in FPSR, or a\nsynchronous exception being generated. For more information, see Floating-point\nexception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FMAX (scalar)",
        "templates": {
          "FLOAT": [
            "FMAX  <Hd>, <Hn>, <Hm>",
            "FMAX  <Sd>, <Sn>, <Sm>",
            "FMAX  <Dd>, <Dn>, <Dm>"
          ]
        }
      },
      "FMINNMP_advsimd_pair": {
        "authored": "Floating-point Minimum Number of Pair of elements (scalar). This instruction\ncompares two vector elements in the source SIMD&FP register and writes the\nsmallest of the floating-point values as a scalar to the destination SIMD&FP\nregister.\n\nThis instruction can generate a floating-point exception. Depending on the\nsettings in FPCR, the exception results in either a flag being set in FPSR or a\nsynchronous exception being generated. For more information, see Floating-point\nexception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FMINNMP (scalar)",
        "templates": {
          "HALF": [
            "FMINNMP  <V><d>, <Vn>.<T>"
          ],
          "SINGLE_AND_DOUBLE": [
            "FMINNMP  <V><d>, <Vn>.<T>"
          ]
        }
      },
      "FMINNMP_advsimd_vec": {
        "authored": "Floating-point Minimum Number Pairwise (vector). This instruction creates a\nvector by concatenating the vector elements of the first source SIMD&FP register\nafter the vector elements of the second source SIMD&FP register, reads each pair\nof adjacent vector elements in the two source SIMD&FP registers, writes the\nsmallest of each pair of floating-point values into a vector, and writes the\nvector to the destination SIMD&FP register. All the values in this instruction\nare floating-point values.\n\nNaNs are handled according to the IEEE 754-2008 standard. If one vector element\nis numeric and the other is a quiet NaN, the result is the numerical value,\notherwise the result is identical to FMIN (scalar).\n\nThis instruction can generate a floating-point exception. Depending on the\nsettings in FPCR, the exception results in either a flag being set in FPSR or a\nsynchronous exception being generated. For more information, see Floating-point\nexception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FMINNMP (vector)",
        "templates": {
          "HALF": [
            "FMINNMP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ],
          "SINGLE_AND_DOUBLE": [
            "FMINNMP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ]
        }
      },
      "FMINNMV_advsimd": {
        "authored": "Floating-point Minimum Number across Vector. This instruction compares all the\nvector elements in the source SIMD&FP register, and writes the smallest of the\nvalues as a scalar to the destination SIMD&FP register. All the values in this\ninstruction are floating-point values.\n\nNaNs are handled according to the IEEE 754-2008 standard. If one vector element\nis numeric and the other is a quiet NaN, the result of the comparison is the\nnumerical value, otherwise the result is identical to FMIN (scalar).\n\nThis instruction can generate a floating-point exception. Depending on the\nsettings in FPCR, the exception results in either a flag being set in FPSR or a\nsynchronous exception being generated. For more information, see Floating-point\nexception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FMINNMV",
        "templates": {
          "HALF": [
            "FMINNMV  <V><d>, <Vn>.<T>"
          ],
          "SINGLE_AND_DOUBLE": [
            "FMINNMV  <V><d>, <Vn>.<T>"
          ]
        }
      },
      "FMINNM_advsimd": {
        "authored": "Floating-point Minimum Number (vector). This instruction compares corresponding\nvector elements in the two source SIMD&FP registers, writes the smaller of the\ntwo floating-point values into a vector, and writes the vector to the\ndestination SIMD&FP register.\n\nNaNs are handled according to the IEEE 754-2008 standard. If one vector element\nis numeric and the other is a quiet NaN, the result placed in the vector is the\nnumerical value, otherwise the result is identical to FMIN (scalar).\n\nThis instruction can generate a floating-point exception. Depending on the\nsettings in FPCR, the exception results in either a flag being set in FPSR or a\nsynchronous exception being generated. For more information, see Floating-point\nexception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FMINNM (vector)",
        "templates": {
          "HALF": [
            "FMINNM  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ],
          "SINGLE_AND_DOUBLE": [
            "FMINNM  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ]
        }
      },
      "FMINNM_float": {
        "authored": "Floating-point Minimum Number (scalar). This instruction compares the first and\nsecond source SIMD&FP register values, and writes the smaller of the two\nfloating-point values to the destination SIMD&FP register.\n\nNaNs are handled according to the IEEE 754-2008 standard. If one vector element\nis numeric and the other is a quiet NaN, the result that is placed in the vector\nis the numerical value, otherwise the result is identical to FMIN (scalar).\n\nThis instruction can generate a floating-point exception. Depending on the\nsettings in FPCR, the exception results in either a flag being set in FPSR or a\nsynchronous exception being generated. For more information, see Floating-point\nexception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FMINNM (scalar)",
        "templates": {
          "FLOAT": [
            "FMINNM  <Hd>, <Hn>, <Hm>",
            "FMINNM  <Sd>, <Sn>, <Sm>",
            "FMINNM  <Dd>, <Dn>, <Dm>"
          ]
        }
      },
      "FMINP_advsimd_pair": {
        "authored": "Floating-point Minimum of Pair of elements (scalar). This instruction compares\ntwo vector elements in the source SIMD&FP register and writes the smallest of\nthe floating-point values as a scalar to the destination SIMD&FP register.\n\nThis instruction can generate a floating-point exception. Depending on the\nsettings in FPCR, the exception results in either a flag being set in FPSR or a\nsynchronous exception being generated. For more information, see Floating-point\nexception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FMINP (scalar)",
        "templates": {
          "HALF": [
            "FMINP  <V><d>, <Vn>.<T>"
          ],
          "SINGLE_AND_DOUBLE": [
            "FMINP  <V><d>, <Vn>.<T>"
          ]
        }
      },
      "FMINP_advsimd_vec": {
        "authored": "Floating-point Minimum Pairwise (vector). This instruction creates a vector by\nconcatenating the vector elements of the first source SIMD&FP register after the\nvector elements of the second source SIMD&FP register, reads each pair of\nadjacent vector elements from the concatenated vector, writes the smaller of\neach pair of values into a vector, and writes the vector to the destination\nSIMD&FP register. All the values in this instruction are floating-point values.\n\nThis instruction can generate a floating-point exception. Depending on the\nsettings in FPCR, the exception results in either a flag being set in FPSR or a\nsynchronous exception being generated. For more information, see Floating-point\nexception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FMINP (vector)",
        "templates": {
          "HALF": [
            "FMINP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ],
          "SINGLE_AND_DOUBLE": [
            "FMINP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ]
        }
      },
      "FMINV_advsimd": {
        "authored": "Floating-point Minimum across Vector. This instruction compares all the vector\nelements in the source SIMD&FP register, and writes the smallest of the values\nas a scalar to the destination SIMD&FP register. All the values in this\ninstruction are floating-point values.\n\nThis instruction can generate a floating-point exception. Depending on the\nsettings in FPCR, the exception results in either a flag being set in FPSR or a\nsynchronous exception being generated. For more information, see Floating-point\nexception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FMINV",
        "templates": {
          "HALF": [
            "FMINV  <V><d>, <Vn>.<T>"
          ],
          "SINGLE_AND_DOUBLE": [
            "FMINV  <V><d>, <Vn>.<T>"
          ]
        }
      },
      "FMIN_advsimd": {
        "authored": "Floating-point minimum (vector). This instruction compares corresponding\nelements in the vectors in the two source SIMD&FP registers, places the smaller\nof each of the two floating-point values into a vector, and writes the vector to\nthe destination SIMD&FP register.\n\nThis instruction can generate a floating-point exception. Depending on the\nsettings in FPCR, the exception results in either a flag being set in FPSR, or a\nsynchronous exception being generated. For more information, see Floating-point\nexception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FMIN (vector)",
        "templates": {
          "HALF": [
            "FMIN  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ],
          "SINGLE_AND_DOUBLE": [
            "FMIN  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ]
        }
      },
      "FMIN_float": {
        "authored": "Floating-point Minimum (scalar). This instruction compares the first and second\nsource SIMD&FP register values, and writes the smaller of the two floating-point\nvalues to the destination SIMD&FP register.\n\nThis instruction can generate a floating-point exception. Depending on the\nsettings in FPCR, the exception results in either a flag being set in FPSR, or a\nsynchronous exception being generated. For more information, see Floating-point\nexception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FMIN (scalar)",
        "templates": {
          "FLOAT": [
            "FMIN  <Hd>, <Hn>, <Hm>",
            "FMIN  <Sd>, <Sn>, <Sm>",
            "FMIN  <Dd>, <Dn>, <Dm>"
          ]
        }
      },
      "FMLAL_advsimd_elt": {
        "authored": "Floating-point fused Multiply-Add Long to accumulator (by element). This\ninstruction multiplies the vector elements in the first source SIMD&FP register\nby the specified value in the second source SIMD&FP register, and accumulates\nthe product to the corresponding vector element of the destination SIMD&FP\nregister. The instruction does not round the result of the multiply before the\naccumulation.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.\n\nIn Armv8.2 and Armv8.3, this is an optional instruction. From Armv8.4 it is\nmandatory for all implementations to support it.\n\nID_AA64ISAR0_EL1.FHM indicates whether this instruction is supported.",
        "heading": "FMLAL, FMLAL2 (by element)",
        "templates": {
          "FMLAL": [
            "FMLAL  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.H[<index>]"
          ],
          "FMLAL2": [
            "FMLAL2  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.H[<index>]"
          ]
        }
      },
      "FMLAL_advsimd_vec": {
        "authored": "Floating-point fused Multiply-Add Long to accumulator (vector). This instruction\nmultiplies corresponding half-precision floating-point values in the vectors in\nthe two source SIMD&FP registers, and accumulates the product to the\ncorresponding vector element of the destination SIMD&FP register. The\ninstruction does not round the result of the multiply before the accumulation.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.\n\nIn Armv8.2 and Armv8.3, this is an optional instruction. From Armv8.4 it is\nmandatory for all implementations to support it.\n\nID_AA64ISAR0_EL1.FHM indicates whether this instruction is supported.",
        "heading": "FMLAL, FMLAL2 (vector)",
        "templates": {
          "FMLAL": [
            "FMLAL  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>"
          ],
          "FMLAL2": [
            "FMLAL2  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>"
          ]
        }
      },
      "FMLA_advsimd_elt": {
        "authored": "Floating-point fused Multiply-Add to accumulator (by element). This instruction\nmultiplies the vector elements in the first source SIMD&FP register by the\nspecified value in the second source SIMD&FP register, and accumulates the\nresults in the vector elements of the destination SIMD&FP register. All the\nvalues in this instruction are floating-point values.\n\nThis instruction can generate a floating-point exception. Depending on the\nsettings in FPCR, the exception results in either a flag being set in FPSR or a\nsynchronous exception being generated. For more information, see Floating-point\nexception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FMLA (by element)",
        "templates": {
          "2REG_ELEMENT_HALF": [
            "FMLA  <Vd>.<T>, <Vn>.<T>, <Vm>.H[<index>]"
          ],
          "2REG_ELEMENT_SINGLE_AND_DOUBLE": [
            "FMLA  <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]"
          ],
          "2REG_SCALAR_HALF": [
            "FMLA  <Hd>, <Hn>, <Vm>.H[<index>]"
          ],
          "2REG_SCALAR_SINGLE_AND_DOUBLE": [
            "FMLA  <V><d>, <V><n>, <Vm>.<Ts>[<index>]"
          ]
        }
      },
      "FMLA_advsimd_vec": {
        "authored": "Floating-point fused Multiply-Add to accumulator (vector). This instruction\nmultiplies corresponding floating-point values in the vectors in the two source\nSIMD&FP registers, adds the product to the corresponding vector element of the\ndestination SIMD&FP register, and writes the result to the destination SIMD&FP\nregister.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FMLA (vector)",
        "templates": {
          "HALF": [
            "FMLA  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ],
          "SINGLE_AND_DOUBLE": [
            "FMLA  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ]
        }
      },
      "FMLSL_advsimd_elt": {
        "authored": "Floating-point fused Multiply-Subtract Long from accumulator (by element). This\ninstruction multiplies the negated vector elements in the first source SIMD&FP\nregister by the specified value in the second source SIMD&FP register, and\naccumulates the product to the corresponding vector element of the destination\nSIMD&FP register. The instruction does not round the result of the multiply\nbefore the accumulation.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.\n\nIn Armv8.2 and Armv8.3, this is an optional instruction. From Armv8.4 it is\nmandatory for all implementations to support it.\n\nID_AA64ISAR0_EL1.FHM indicates whether this instruction is supported.",
        "heading": "FMLSL, FMLSL2 (by element)",
        "templates": {
          "FMLSL": [
            "FMLSL  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.H[<index>]"
          ],
          "FMLSL2": [
            "FMLSL2  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.H[<index>]"
          ]
        }
      },
      "FMLSL_advsimd_vec": {
        "authored": "Floating-point fused Multiply-Subtract Long from accumulator (vector). This\ninstruction negates the values in the vector of one SIMD&FP register, multiplies\nthese with the corresponding values in another vector, and accumulates the\nproduct to the corresponding vector element of the destination SIMD&FP register.\nThe instruction does not round the result of the multiply before the\naccumulation.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.\n\nIn Armv8.2 and Armv8.3, this is an optional instruction. From Armv8.4 it is\nmandatory for all implementations to support it.\n\nID_AA64ISAR0_EL1.FHM indicates whether this instruction is supported.",
        "heading": "FMLSL, FMLSL2 (vector)",
        "templates": {
          "FMLSL": [
            "FMLSL  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>"
          ],
          "FMLSL2": [
            "FMLSL2  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>"
          ]
        }
      },
      "FMLS_advsimd_elt": {
        "authored": "Floating-point fused Multiply-Subtract from accumulator (by element). This\ninstruction multiplies the vector elements in the first source SIMD&FP register\nby the specified value in the second source SIMD&FP register, and subtracts the\nresults from the vector elements of the destination SIMD&FP register. All the\nvalues in this instruction are floating-point values.\n\nThis instruction can generate a floating-point exception. Depending on the\nsettings in FPCR, the exception results in either a flag being set in FPSR or a\nsynchronous exception being generated. For more information, see Floating-point\nexception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FMLS (by element)",
        "templates": {
          "2REG_ELEMENT_HALF": [
            "FMLS  <Vd>.<T>, <Vn>.<T>, <Vm>.H[<index>]"
          ],
          "2REG_ELEMENT_SINGLE_AND_DOUBLE": [
            "FMLS  <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]"
          ],
          "2REG_SCALAR_HALF": [
            "FMLS  <Hd>, <Hn>, <Vm>.H[<index>]"
          ],
          "2REG_SCALAR_SINGLE_AND_DOUBLE": [
            "FMLS  <V><d>, <V><n>, <Vm>.<Ts>[<index>]"
          ]
        }
      },
      "FMLS_advsimd_vec": {
        "authored": "Floating-point fused Multiply-Subtract from accumulator (vector). This\ninstruction multiplies corresponding floating-point values in the vectors in the\ntwo source SIMD&FP registers, negates the product, adds the result to the\ncorresponding vector element of the destination SIMD&FP register, and writes the\nresult to the destination SIMD&FP register.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FMLS (vector)",
        "templates": {
          "HALF": [
            "FMLS  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ],
          "SINGLE_AND_DOUBLE": [
            "FMLS  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ]
        }
      },
      "FMOV_advsimd": {
        "authored": "Floating-point move immediate (vector). This instruction copies an immediate\nfloating-point constant into every element of the SIMD&FP destination register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FMOV (vector, immediate)",
        "templates": {
          "PER_HALF": [
            "FMOV  <Vd>.<T>, #<imm>"
          ],
          "SINGLE_AND_DOUBLE": [
            "FMOV  <Vd>.<T>, #<imm>",
            "FMOV  <Vd>.2D, #<imm>"
          ]
        }
      },
      "FMOV_float": {
        "authored": "Floating-point Move register without conversion. This instruction copies the\nfloating-point value in the SIMD&FP source register to the SIMD&FP destination\nregister.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FMOV (register)",
        "templates": {
          "FLOAT": [
            "FMOV  <Hd>, <Hn>",
            "FMOV  <Sd>, <Sn>",
            "FMOV  <Dd>, <Dn>"
          ]
        }
      },
      "FMOV_float_gen": {
        "authored": "Floating-point Move to or from general-purpose register without conversion. This\ninstruction transfers the contents of a SIMD&FP register to a general-purpose\nregister, or the contents of a general-purpose register to a SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FMOV (general)",
        "templates": {
          "FLOAT": [
            "FMOV  <Wd>, <Hn>",
            "FMOV  <Xd>, <Hn>",
            "FMOV  <Hd>, <Wn>",
            "FMOV  <Sd>, <Wn>",
            "FMOV  <Wd>, <Sn>",
            "FMOV  <Hd>, <Xn>",
            "FMOV  <Dd>, <Xn>",
            "FMOV  <Vd>.D[1], <Xn>",
            "FMOV  <Xd>, <Dn>",
            "FMOV  <Xd>, <Vn>.D[1]"
          ]
        }
      },
      "FMOV_float_imm": {
        "authored": "Floating-point move immediate (scalar). This instruction copies a floating-point\nimmediate constant into the SIMD&FP destination register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FMOV (scalar, immediate)",
        "templates": {
          "IMM8F": [
            "FMOV  <Hd>, #<imm>",
            "FMOV  <Sd>, #<imm>",
            "FMOV  <Dd>, #<imm>"
          ]
        }
      },
      "FMSUB_float": {
        "authored": "Floating-point Fused Multiply-Subtract (scalar). This instruction multiplies the\nvalues of the first two SIMD&FP source registers, negates the product, adds that\nto the value of the third SIMD&FP source register, and writes the result to the\nSIMD&FP destination register.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FMSUB",
        "templates": {
          "FLOAT": [
            "FMSUB  <Hd>, <Hn>, <Hm>, <Ha>",
            "FMSUB  <Sd>, <Sn>, <Sm>, <Sa>",
            "FMSUB  <Dd>, <Dn>, <Dm>, <Da>"
          ]
        }
      },
      "FMULX_advsimd_elt": {
        "authored": "Floating-point Multiply extended (by element). This instruction multiplies the\nfloating-point values in the vector elements in the first source SIMD&FP\nregister by the specified floating-point value in the second source SIMD&FP\nregister, places the results in a vector, and writes the vector to the\ndestination SIMD&FP register.\n\nIf one value is zero and the other value is infinite, the result is 2.0. In this\ncase, the result is negative if only one of the values is negative, otherwise\nthe result is positive.\n\nThis instruction can generate a floating-point exception. Depending on the\nsettings in FPCR, the exception results in either a flag being set in FPSR or a\nsynchronous exception being generated. For more information, see Floating-point\nexception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FMULX (by element)",
        "templates": {
          "2REG_ELEMENT_HALF": [
            "FMULX  <Vd>.<T>, <Vn>.<T>, <Vm>.H[<index>]"
          ],
          "2REG_ELEMENT_SINGLE_AND_DOUBLE": [
            "FMULX  <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]"
          ],
          "2REG_SCALAR_HALF": [
            "FMULX  <Hd>, <Hn>, <Vm>.H[<index>]"
          ],
          "2REG_SCALAR_SINGLE_AND_DOUBLE": [
            "FMULX  <V><d>, <V><n>, <Vm>.<Ts>[<index>]"
          ]
        }
      },
      "FMULX_advsimd_vec": {
        "authored": "Floating-point Multiply extended. This instruction multiplies corresponding\nfloating-point values in the vectors of the two source SIMD&FP registers, places\nthe resulting floating-point values in a vector, and writes the vector to the\ndestination SIMD&FP register.\n\nIf one value is zero and the other value is infinite, the result is 2.0. In this\ncase, the result is negative if only one of the values is negative, otherwise\nthe result is positive.\n\nThis instruction can generate a floating-point exception. Depending on the\nsettings in FPCR, the exception results in either a flag being set in FPSR, or a\nsynchronous exception being generated. For more information, see Floating-point\nexception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FMULX",
        "templates": {
          "SIMD_HALF": [
            "FMULX  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ],
          "SIMD_SINGLE_AND_DOUBLE": [
            "FMULX  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ],
          "SISD_HALF": [
            "FMULX  <Hd>, <Hn>, <Hm>"
          ],
          "SISD_SINGLE_AND_DOUBLE": [
            "FMULX  <V><d>, <V><n>, <V><m>"
          ]
        }
      },
      "FMUL_advsimd_elt": {
        "authored": "Floating-point Multiply (by element). This instruction multiplies the vector\nelements in the first source SIMD&FP register by the specified value in the\nsecond source SIMD&FP register, places the results in a vector, and writes the\nvector to the destination SIMD&FP register. All the values in this instruction\nare floating-point values.\n\nThis instruction can generate a floating-point exception. Depending on the\nsettings in FPCR, the exception results in either a flag being set in FPSR or a\nsynchronous exception being generated. For more information, see Floating-point\nexception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FMUL (by element)",
        "templates": {
          "2REG_ELEMENT_HALF": [
            "FMUL  <Vd>.<T>, <Vn>.<T>, <Vm>.H[<index>]"
          ],
          "2REG_ELEMENT_SINGLE_AND_DOUBLE": [
            "FMUL  <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]"
          ],
          "2REG_SCALAR_HALF": [
            "FMUL  <Hd>, <Hn>, <Vm>.H[<index>]"
          ],
          "2REG_SCALAR_SINGLE_AND_DOUBLE": [
            "FMUL  <V><d>, <V><n>, <Vm>.<Ts>[<index>]"
          ]
        }
      },
      "FMUL_advsimd_vec": {
        "authored": "Floating-point Multiply (vector). This instruction multiplies corresponding\nfloating-point values in the vectors in the two source SIMD&FP registers, places\nthe result in a vector, and writes the vector to the destination SIMD&FP\nregister.\n\nThis instruction can generate a floating-point exception. Depending on the\nsettings in FPCR, the exception results in either a flag being set in FPSR, or a\nsynchronous exception being generated. For more information, see Floating-point\nexception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FMUL (vector)",
        "templates": {
          "HALF": [
            "FMUL  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ],
          "SINGLE_AND_DOUBLE": [
            "FMUL  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ]
        }
      },
      "FMUL_float": {
        "authored": "Floating-point Multiply (scalar). This instruction multiplies the floating-point\nvalues of the two source SIMD&FP registers, and writes the result to the\ndestination SIMD&FP register.\n\nThis instruction can generate a floating-point exception. Depending on the\nsettings in FPCR, the exception results in either a flag being set in FPSR, or a\nsynchronous exception being generated. For more information, see Floating-point\nexception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FMUL (scalar)",
        "templates": {
          "FLOAT": [
            "FMUL  <Hd>, <Hn>, <Hm>",
            "FMUL  <Sd>, <Sn>, <Sm>",
            "FMUL  <Dd>, <Dn>, <Dm>"
          ]
        }
      },
      "FNEG_advsimd": {
        "authored": "Floating-point Negate (vector). This instruction negates the value of each\nvector element in the source SIMD&FP register, writes the result to a vector,\nand writes the vector to the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FNEG (vector)",
        "templates": {
          "HALF": [
            "FNEG  <Vd>.<T>, <Vn>.<T>"
          ],
          "SINGLE_AND_DOUBLE": [
            "FNEG  <Vd>.<T>, <Vn>.<T>"
          ]
        }
      },
      "FNEG_float": {
        "authored": "Floating-point Negate (scalar). This instruction negates the value in the\nSIMD&FP source register and writes the result to the SIMD&FP destination\nregister.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FNEG (scalar)",
        "templates": {
          "FLOAT": [
            "FNEG  <Hd>, <Hn>",
            "FNEG  <Sd>, <Sn>",
            "FNEG  <Dd>, <Dn>"
          ]
        }
      },
      "FNMADD_float": {
        "authored": "Floating-point Negated fused Multiply-Add (scalar). This instruction multiplies\nthe values of the first two SIMD&FP source registers, negates the product,\nsubtracts the value of the third SIMD&FP source register, and writes the result\nto the destination SIMD&FP register.\n\nThis instruction can generate a floating-point exception. Depending on the\nsettings in FPCR, the exception results in either a flag being set in FPSR, or a\nsynchronous exception being generated. For more information, see Floating-point\nexception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FNMADD",
        "templates": {
          "FLOAT": [
            "FNMADD  <Hd>, <Hn>, <Hm>, <Ha>",
            "FNMADD  <Sd>, <Sn>, <Sm>, <Sa>",
            "FNMADD  <Dd>, <Dn>, <Dm>, <Da>"
          ]
        }
      },
      "FNMSUB_float": {
        "authored": "Floating-point Negated fused Multiply-Subtract (scalar). This instruction\nmultiplies the values of the first two SIMD&FP source registers, subtracts the\nvalue of the third SIMD&FP source register, and writes the result to the\ndestination SIMD&FP register.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FNMSUB",
        "templates": {
          "FLOAT": [
            "FNMSUB  <Hd>, <Hn>, <Hm>, <Ha>",
            "FNMSUB  <Sd>, <Sn>, <Sm>, <Sa>",
            "FNMSUB  <Dd>, <Dn>, <Dm>, <Da>"
          ]
        }
      },
      "FNMUL_float": {
        "authored": "Floating-point Multiply-Negate (scalar). This instruction multiplies the\nfloating-point values of the two source SIMD&FP registers, and writes the\nnegation of the result to the destination SIMD&FP register.\n\nThis instruction can generate a floating-point exception. Depending on the\nsettings in FPCR, the exception results in either a flag being set in FPSR, or a\nsynchronous exception being generated. For more information, see Floating-point\nexception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FNMUL (scalar)",
        "templates": {
          "FLOAT": [
            "FNMUL  <Hd>, <Hn>, <Hm>",
            "FNMUL  <Sd>, <Sn>, <Sm>",
            "FNMUL  <Dd>, <Dn>, <Dm>"
          ]
        }
      },
      "FRECPE_advsimd": {
        "authored": "Floating-point Reciprocal Estimate. This instruction finds an approximate\nreciprocal estimate for each vector element in the source SIMD&FP register,\nplaces the result in a vector, and writes the vector to the destination SIMD&FP\nregister.\n\nThis instruction can generate a floating-point exception. Depending on the\nsettings in FPCR, the exception results in either a flag being set in FPSR or a\nsynchronous exception being generated. For more information, see Floating-point\nexception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FRECPE",
        "templates": {
          "SIMD_HALF": [
            "FRECPE  <Vd>.<T>, <Vn>.<T>"
          ],
          "SIMD_SINGLE_AND_DOUBLE": [
            "FRECPE  <Vd>.<T>, <Vn>.<T>"
          ],
          "SISD_HALF": [
            "FRECPE  <Hd>, <Hn>"
          ],
          "SISD_SINGLE_AND_DOUBLE": [
            "FRECPE  <V><d>, <V><n>"
          ]
        }
      },
      "FRECPS_advsimd": {
        "authored": "Floating-point Reciprocal Step. This instruction multiplies the corresponding\nfloating-point values in the vectors of the two source SIMD&FP registers,\nsubtracts each of the products from 2.0, places the resulting floating-point\nvalues in a vector, and writes the vector to the destination SIMD&FP register.\n\nThis instruction can generate a floating-point exception. Depending on the\nsettings in FPCR, the exception results in either a flag being set in FPSR, or a\nsynchronous exception being generated. For more information, see Floating-point\nexception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FRECPS",
        "templates": {
          "SIMD_HALF": [
            "FRECPS  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ],
          "SIMD_SINGLE_AND_DOUBLE": [
            "FRECPS  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ],
          "SISD_HALF": [
            "FRECPS  <Hd>, <Hn>, <Hm>"
          ],
          "SISD_SINGLE_AND_DOUBLE": [
            "FRECPS  <V><d>, <V><n>, <V><m>"
          ]
        }
      },
      "FRECPX_advsimd": {
        "authored": "Floating-point Reciprocal exponent (scalar). This instruction finds an\napproximate reciprocal exponent for each vector element in the source SIMD&FP\nregister, places the result in a vector, and writes the vector to the\ndestination SIMD&FP register.\n\nThis instruction can generate a floating-point exception. Depending on the\nsettings in FPCR, the exception results in either a flag being set in FPSR or a\nsynchronous exception being generated. For more information, see Floating-point\nexception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FRECPX",
        "templates": {
          "HALF": [
            "FRECPX  <Hd>, <Hn>"
          ],
          "SINGLE_AND_DOUBLE": [
            "FRECPX  <V><d>, <V><n>"
          ]
        }
      },
      "FRINT32X_advsimd": {
        "authored": "Floating-point Round to 32-bit Integer, using current rounding mode (vector).\nThis instruction rounds a vector of floating-point values in the SIMD&FP source\nregister to integral floating-point values that fit into a 32-bit integer size\nusing the rounding mode that is determined by the FPCR, and writes the result to\nthe SIMD&FP destination register.\n\nA zero input returns a zero result with the same sign. When one of the result\nvalues is not numerically equal to the corresponding input value, an Inexact\nexception is raised. When an input is infinite, NaN or out-of-range, the\ninstruction returns for the corresponding result value the most negative integer\nrepresentable in the destination size, and an Invalid Operation floating-point\nexception is raised.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FRINT32X (vector)",
        "templates": {
          "SIMD_SINGLE_AND_DOUBLE": [
            "FRINT32X  <Vd>.<T>, <Vn>.<T>"
          ]
        }
      },
      "FRINT32X_float": {
        "authored": "Floating-point Round to 32-bit Integer, using current rounding mode (scalar).\nThis instruction rounds a floating-point value in the SIMD&FP source register to\nan integral floating-point value that fits into a 32-bit integer size using the\nrounding mode that is determined by the FPCR, and writes the result to the\nSIMD&FP destination register.\n\nA zero input returns a zero result with the same sign. When the result value is\nnot numerically equal to the input value, an Inexact exception is raised. When\nthe input is infinite, NaN or out-of-range, the instruction returns {for the\ncorresponding result value} the most negative integer representable in the\ndestination size, and an Invalid Operation floating-point exception is raised.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FRINT32X (scalar)",
        "templates": {
          "FLOAT": [
            "FRINT32X  <Sd>, <Sn>",
            "FRINT32X  <Dd>, <Dn>"
          ]
        }
      },
      "FRINT32Z_advsimd": {
        "authored": "Floating-point Round to 32-bit Integer toward Zero (vector). This instruction\nrounds a vector of floating-point values in the SIMD&FP source register to\nintegral floating-point values that fit into a 32-bit integer size using the\nRound towards Zero rounding mode, and writes the result to the SIMD&FP\ndestination register.\n\nA zero input returns a zero result with the same sign. When one of the result\nvalues is not numerically equal to the corresponding input value, an Inexact\nexception is raised. When an input is infinite, NaN or out-of-range, the\ninstruction returns for the corresponding result value the most negative integer\nrepresentable in the destination size, and an Invalid Operation floating-point\nexception is raised.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FRINT32Z (vector)",
        "templates": {
          "SIMD_SINGLE_AND_DOUBLE": [
            "FRINT32Z  <Vd>.<T>, <Vn>.<T>"
          ]
        }
      },
      "FRINT32Z_float": {
        "authored": "Floating-point Round to 32-bit Integer toward Zero (scalar). This instruction\nrounds a floating-point value in the SIMD&FP source register to an integral\nfloating-point value that fits into a 32-bit integer size using the Round\ntowards Zero rounding mode, and writes the result to the SIMD&FP destination\nregister.\n\nA zero input returns a zero result with the same sign. When the result value is\nnot numerically equal to the {corresponding} input value, an Inexact exception\nis raised. When the input is infinite, NaN or out-of-range, the instruction\nreturns {for the corresponding result value} the most negative integer\nrepresentable in the destination size, and an Invalid Operation floating-point\nexception is raised.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FRINT32Z (scalar)",
        "templates": {
          "FLOAT": [
            "FRINT32Z  <Sd>, <Sn>",
            "FRINT32Z  <Dd>, <Dn>"
          ]
        }
      },
      "FRINT64X_advsimd": {
        "authored": "Floating-point Round to 64-bit Integer, using current rounding mode (vector).\nThis instruction rounds a vector of floating-point values in the SIMD&FP source\nregister to integral floating-point values that fit into a 64-bit integer size\nusing the rounding mode that is determined by the FPCR, and writes the result to\nthe SIMD&FP destination register.\n\nA zero input returns a zero result with the same sign. When one of the result\nvalues is not numerically equal to the corresponding input value, an Inexact\nexception is raised. When an input is infinite, NaN or out-of-range, the\ninstruction returns for the corresponding result value the most negative integer\nrepresentable in the destination size, and an Invalid Operation floating-point\nexception is raised.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FRINT64X (vector)",
        "templates": {
          "SIMD_SINGLE_AND_DOUBLE": [
            "FRINT64X  <Vd>.<T>, <Vn>.<T>"
          ]
        }
      },
      "FRINT64X_float": {
        "authored": "Floating-point Round to 64-bit Integer, using current rounding mode (scalar).\nThis instruction rounds a floating-point value in the SIMD&FP source register to\nan integral floating-point value that fits into a 64-bit integer size using the\nrounding mode that is determined by the FPCR, and writes the result to the\nSIMD&FP destination register.\n\nA zero input returns a zero result with the same sign. When the result value is\nnot numerically equal to the input value, an Inexact exception is raised. When\nthe input is infinite, NaN or out-of-range, the instruction returns {for the\ncorresponding result value} the most negative integer representable in the\ndestination size, and an Invalid Operation floating-point exception is raised.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FRINT64X (scalar)",
        "templates": {
          "FLOAT": [
            "FRINT64X  <Sd>, <Sn>",
            "FRINT64X  <Dd>, <Dn>"
          ]
        }
      },
      "FRINT64Z_advsimd": {
        "authored": "Floating-point Round to 64-bit Integer toward Zero (vector). This instruction\nrounds a vector of floating-point values in the SIMD&FP source register to\nintegral floating-point values that fit into a 64-bit integer size using the\nRound towards Zero rounding mode, and writes the result to the SIMD&FP\ndestination register.\n\nA zero input returns a zero result with the same sign. When one of the result\nvalues is not numerically equal to the corresponding input value, an Inexact\nexception is raised. When an input is infinite, NaN or out-of-range, the\ninstruction returns for the corresponding result value the most negative integer\nrepresentable in the destination size, and an Invalid Operation floating-point\nexception is raised.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FRINT64Z (vector)",
        "templates": {
          "SIMD_SINGLE_AND_DOUBLE": [
            "FRINT64Z  <Vd>.<T>, <Vn>.<T>"
          ]
        }
      },
      "FRINT64Z_float": {
        "authored": "Floating-point Round to 64-bit Integer toward Zero (scalar). This instruction\nrounds a floating-point value in the SIMD&FP source register to an integral\nfloating-point value that fits into a 64-bit integer size using the Round\ntowards Zero rounding mode, and writes the result to the SIMD&FP destination\nregister.\n\nA zero input returns a zero result with the same sign. When the result value is\nnot numerically equal to the {corresponding} input value, an Inexact exception\nis raised. When the input is infinite, NaN or out-of-range, the instruction\nreturns {for the corresponding result value} the most negative integer\nrepresentable in the destination size, and an Invalid Operation floating-point\nexception is raised.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FRINT64Z (scalar)",
        "templates": {
          "FLOAT": [
            "FRINT64Z  <Sd>, <Sn>",
            "FRINT64Z  <Dd>, <Dn>"
          ]
        }
      },
      "FRINTA_advsimd": {
        "authored": "Floating-point Round to Integral, to nearest with ties to Away (vector). This\ninstruction rounds a vector of floating-point values in the SIMD&FP source\nregister to integral floating-point values of the same size using the Round to\nNearest with Ties to Away rounding mode, and writes the result to the SIMD&FP\ndestination register.\n\nA zero input gives a zero result with the same sign, an infinite input gives an\ninfinite result with the same sign, and a NaN is propagated as for normal\narithmetic.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FRINTA (vector)",
        "templates": {
          "HALF": [
            "FRINTA  <Vd>.<T>, <Vn>.<T>"
          ],
          "SINGLE_AND_DOUBLE": [
            "FRINTA  <Vd>.<T>, <Vn>.<T>"
          ]
        }
      },
      "FRINTA_float": {
        "authored": "Floating-point Round to Integral, to nearest with ties to Away (scalar). This\ninstruction rounds a floating-point value in the SIMD&FP source register to an\nintegral floating-point value of the same size using the Round to Nearest with\nTies to Away rounding mode, and writes the result to the SIMD&FP destination\nregister.\n\nA zero input gives a zero result with the same sign, an infinite input gives an\ninfinite result with the same sign, and a NaN is propagated as for normal\narithmetic.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FRINTA (scalar)",
        "templates": {
          "FLOAT": [
            "FRINTA  <Hd>, <Hn>",
            "FRINTA  <Sd>, <Sn>",
            "FRINTA  <Dd>, <Dn>"
          ]
        }
      },
      "FRINTI_advsimd": {
        "authored": "Floating-point Round to Integral, using current rounding mode (vector). This\ninstruction rounds a vector of floating-point values in the SIMD&FP source\nregister to integral floating-point values of the same size using the rounding\nmode that is determined by the FPCR, and writes the result to the SIMD&FP\ndestination register.\n\nA zero input gives a zero result with the same sign, an infinite input gives an\ninfinite result with the same sign, and a NaN is propagated as for normal\narithmetic.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FRINTI (vector)",
        "templates": {
          "HALF": [
            "FRINTI  <Vd>.<T>, <Vn>.<T>"
          ],
          "SINGLE_AND_DOUBLE": [
            "FRINTI  <Vd>.<T>, <Vn>.<T>"
          ]
        }
      },
      "FRINTI_float": {
        "authored": "Floating-point Round to Integral, using current rounding mode (scalar). This\ninstruction rounds a floating-point value in the SIMD&FP source register to an\nintegral floating-point value of the same size using the rounding mode that is\ndetermined by the FPCR, and writes the result to the SIMD&FP destination\nregister.\n\nA zero input gives a zero result with the same sign, an infinite input gives an\ninfinite result with the same sign, and a NaN is propagated as for normal\narithmetic.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FRINTI (scalar)",
        "templates": {
          "FLOAT": [
            "FRINTI  <Hd>, <Hn>",
            "FRINTI  <Sd>, <Sn>",
            "FRINTI  <Dd>, <Dn>"
          ]
        }
      },
      "FRINTM_advsimd": {
        "authored": "Floating-point Round to Integral, toward Minus infinity (vector). This\ninstruction rounds a vector of floating-point values in the SIMD&FP source\nregister to integral floating-point values of the same size using the Round\ntowards Minus Infinity rounding mode, and writes the result to the SIMD&FP\ndestination register.\n\nA zero input gives a zero result with the same sign, an infinite input gives an\ninfinite result with the same sign, and a NaN is propagated as for normal\narithmetic.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FRINTM (vector)",
        "templates": {
          "HALF": [
            "FRINTM  <Vd>.<T>, <Vn>.<T>"
          ],
          "SINGLE_AND_DOUBLE": [
            "FRINTM  <Vd>.<T>, <Vn>.<T>"
          ]
        }
      },
      "FRINTM_float": {
        "authored": "Floating-point Round to Integral, toward Minus infinity (scalar). This\ninstruction rounds a floating-point value in the SIMD&FP source register to an\nintegral floating-point value of the same size using the Round towards Minus\nInfinity rounding mode, and writes the result to the SIMD&FP destination\nregister.\n\nA zero input gives a zero result with the same sign, an infinite input gives an\ninfinite result with the same sign, and a NaN is propagated as for normal\narithmetic.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FRINTM (scalar)",
        "templates": {
          "FLOAT": [
            "FRINTM  <Hd>, <Hn>",
            "FRINTM  <Sd>, <Sn>",
            "FRINTM  <Dd>, <Dn>"
          ]
        }
      },
      "FRINTN_advsimd": {
        "authored": "Floating-point Round to Integral, to nearest with ties to even (vector). This\ninstruction rounds a vector of floating-point values in the SIMD&FP source\nregister to integral floating-point values of the same size using the Round to\nNearest rounding mode, and writes the result to the SIMD&FP destination\nregister.\n\nA zero input gives a zero result with the same sign, an infinite input gives an\ninfinite result with the same sign, and a NaN is propagated as for normal\narithmetic.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FRINTN (vector)",
        "templates": {
          "HALF": [
            "FRINTN  <Vd>.<T>, <Vn>.<T>"
          ],
          "SINGLE_AND_DOUBLE": [
            "FRINTN  <Vd>.<T>, <Vn>.<T>"
          ]
        }
      },
      "FRINTN_float": {
        "authored": "Floating-point Round to Integral, to nearest with ties to even (scalar). This\ninstruction rounds a floating-point value in the SIMD&FP source register to an\nintegral floating-point value of the same size using the Round to Nearest\nrounding mode, and writes the result to the SIMD&FP destination register.\n\nA zero input gives a zero result with the same sign, an infinite input gives an\ninfinite result with the same sign, and a NaN is propagated as for normal\narithmetic.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FRINTN (scalar)",
        "templates": {
          "FLOAT": [
            "FRINTN  <Hd>, <Hn>",
            "FRINTN  <Sd>, <Sn>",
            "FRINTN  <Dd>, <Dn>"
          ]
        }
      },
      "FRINTP_advsimd": {
        "authored": "Floating-point Round to Integral, toward Plus infinity (vector). This\ninstruction rounds a vector of floating-point values in the SIMD&FP source\nregister to integral floating-point values of the same size using the Round\ntowards Plus Infinity rounding mode, and writes the result to the SIMD&FP\ndestination register.\n\nA zero input gives a zero result with the same sign, an infinite input gives an\ninfinite result with the same sign, and a NaN is propagated as for normal\narithmetic.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FRINTP (vector)",
        "templates": {
          "HALF": [
            "FRINTP  <Vd>.<T>, <Vn>.<T>"
          ],
          "SINGLE_AND_DOUBLE": [
            "FRINTP  <Vd>.<T>, <Vn>.<T>"
          ]
        }
      },
      "FRINTP_float": {
        "authored": "Floating-point Round to Integral, toward Plus infinity (scalar). This\ninstruction rounds a floating-point value in the SIMD&FP source register to an\nintegral floating-point value of the same size using the Round towards Plus\nInfinity rounding mode, and writes the result to the SIMD&FP destination\nregister.\n\nA zero input gives a zero result with the same sign, an infinite input gives an\ninfinite result with the same sign, and a NaN is propagated as for normal\narithmetic.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FRINTP (scalar)",
        "templates": {
          "FLOAT": [
            "FRINTP  <Hd>, <Hn>",
            "FRINTP  <Sd>, <Sn>",
            "FRINTP  <Dd>, <Dn>"
          ]
        }
      },
      "FRINTX_advsimd": {
        "authored": "Floating-point Round to Integral exact, using current rounding mode (vector).\nThis instruction rounds a vector of floating-point values in the SIMD&FP source\nregister to integral floating-point values of the same size using the rounding\nmode that is determined by the FPCR, and writes the result to the SIMD&FP\ndestination register.\n\nWhen a result value is not numerically equal to the corresponding input value,\nan Inexact exception is raised. A zero input gives a zero result with the same\nsign, an infinite input gives an infinite result with the same sign, and a NaN\nis propagated as for normal arithmetic.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FRINTX (vector)",
        "templates": {
          "HALF": [
            "FRINTX  <Vd>.<T>, <Vn>.<T>"
          ],
          "SINGLE_AND_DOUBLE": [
            "FRINTX  <Vd>.<T>, <Vn>.<T>"
          ]
        }
      },
      "FRINTX_float": {
        "authored": "Floating-point Round to Integral exact, using current rounding mode (scalar).\nThis instruction rounds a floating-point value in the SIMD&FP source register to\nan integral floating-point value of the same size using the rounding mode that\nis determined by the FPCR, and writes the result to the SIMD&FP destination\nregister.\n\nWhen the result value is not numerically equal to the input value, an Inexact\nexception is raised. A zero input gives a zero result with the same sign, an\ninfinite input gives an infinite result with the same sign, and a NaN is\npropagated as for normal arithmetic.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FRINTX (scalar)",
        "templates": {
          "FLOAT": [
            "FRINTX  <Hd>, <Hn>",
            "FRINTX  <Sd>, <Sn>",
            "FRINTX  <Dd>, <Dn>"
          ]
        }
      },
      "FRINTZ_advsimd": {
        "authored": "Floating-point Round to Integral, toward Zero (vector). This instruction rounds\na vector of floating-point values in the SIMD&FP source register to integral\nfloating-point values of the same size using the Round towards Zero rounding\nmode, and writes the result to the SIMD&FP destination register.\n\nA zero input gives a zero result with the same sign, an infinite input gives an\ninfinite result with the same sign, and a NaN is propagated as for normal\narithmetic.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FRINTZ (vector)",
        "templates": {
          "HALF": [
            "FRINTZ  <Vd>.<T>, <Vn>.<T>"
          ],
          "SINGLE_AND_DOUBLE": [
            "FRINTZ  <Vd>.<T>, <Vn>.<T>"
          ]
        }
      },
      "FRINTZ_float": {
        "authored": "Floating-point Round to Integral, toward Zero (scalar). This instruction rounds\na floating-point value in the SIMD&FP source register to an integral floating-\npoint value of the same size using the Round towards Zero rounding mode, and\nwrites the result to the SIMD&FP destination register.\n\nA zero input gives a zero result with the same sign, an infinite input gives an\ninfinite result with the same sign, and a NaN is propagated as for normal\narithmetic.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FRINTZ (scalar)",
        "templates": {
          "FLOAT": [
            "FRINTZ  <Hd>, <Hn>",
            "FRINTZ  <Sd>, <Sn>",
            "FRINTZ  <Dd>, <Dn>"
          ]
        }
      },
      "FRSQRTE_advsimd": {
        "authored": "Floating-point Reciprocal Square Root Estimate. This instruction calculates an\napproximate square root for each vector element in the source SIMD&FP register,\nplaces the result in a vector, and writes the vector to the destination SIMD&FP\nregister.\n\nThis instruction can generate a floating-point exception. Depending on the\nsettings in FPCR, the exception results in either a flag being set in FPSR or a\nsynchronous exception being generated. For more information, see Floating-point\nexception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FRSQRTE",
        "templates": {
          "SIMD_HALF": [
            "FRSQRTE  <Vd>.<T>, <Vn>.<T>"
          ],
          "SIMD_SINGLE_AND_DOUBLE": [
            "FRSQRTE  <Vd>.<T>, <Vn>.<T>"
          ],
          "SISD_HALF": [
            "FRSQRTE  <Hd>, <Hn>"
          ],
          "SISD_SINGLE_AND_DOUBLE": [
            "FRSQRTE  <V><d>, <V><n>"
          ]
        }
      },
      "FRSQRTS_advsimd": {
        "authored": "Floating-point Reciprocal Square Root Step. This instruction multiplies\ncorresponding floating-point values in the vectors of the two source SIMD&FP\nregisters, subtracts each of the products from 3.0, divides these results by\n2.0, places the results into a vector, and writes the vector to the destination\nSIMD&FP register.\n\nThis instruction can generate a floating-point exception. Depending on the\nsettings in FPCR, the exception results in either a flag being set in FPSR, or a\nsynchronous exception being generated. For more information, see Floating-point\nexception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FRSQRTS",
        "templates": {
          "SIMD_HALF": [
            "FRSQRTS  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ],
          "SIMD_SINGLE_AND_DOUBLE": [
            "FRSQRTS  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ],
          "SISD_HALF": [
            "FRSQRTS  <Hd>, <Hn>, <Hm>"
          ],
          "SISD_SINGLE_AND_DOUBLE": [
            "FRSQRTS  <V><d>, <V><n>, <V><m>"
          ]
        }
      },
      "FSQRT_advsimd": {
        "authored": "Floating-point Square Root (vector). This instruction calculates the square root\nfor each vector element in the source SIMD&FP register, places the result in a\nvector, and writes the vector to the destination SIMD&FP register.\n\nThis instruction can generate a floating-point exception. Depending on the\nsettings in FPCR, the exception results in either a flag being set in FPSR or a\nsynchronous exception being generated. For more information, see Floating-point\nexception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FSQRT (vector)",
        "templates": {
          "HALF": [
            "FSQRT  <Vd>.<T>, <Vn>.<T>"
          ],
          "SINGLE_AND_DOUBLE": [
            "FSQRT  <Vd>.<T>, <Vn>.<T>"
          ]
        }
      },
      "FSQRT_float": {
        "authored": "Floating-point Square Root (scalar). This instruction calculates the square root\nof the value in the SIMD&FP source register and writes the result to the SIMD&FP\ndestination register.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FSQRT (scalar)",
        "templates": {
          "FLOAT": [
            "FSQRT  <Hd>, <Hn>",
            "FSQRT  <Sd>, <Sn>",
            "FSQRT  <Dd>, <Dn>"
          ]
        }
      },
      "FSUB_advsimd": {
        "authored": "Floating-point Subtract (vector). This instruction subtracts the elements in the\nvector in the second source SIMD&FP register, from the corresponding elements in\nthe vector in the first source SIMD&FP register, places each result into\nelements of a vector, and writes the vector to the destination SIMD&FP register.\n\nThis instruction can generate a floating-point exception. Depending on the\nsettings in FPCR, the exception results in either a flag being set in FPSR, or a\nsynchronous exception being generated. For more information, see Floating-point\nexception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FSUB (vector)",
        "templates": {
          "HALF": [
            "FSUB  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ],
          "SINGLE_AND_DOUBLE": [
            "FSUB  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ]
        }
      },
      "FSUB_float": {
        "authored": "Floating-point Subtract (scalar). This instruction subtracts the floating-point\nvalue of the second source SIMD&FP register from the floating-point value of the\nfirst source SIMD&FP register, and writes the result to the destination SIMD&FP\nregister.\n\nThis instruction can generate a floating-point exception. Depending on the\nsettings in FPCR, the exception results in either a flag being set in FPSR, or a\nsynchronous exception being generated. For more information, see Floating-point\nexception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FSUB (scalar)",
        "templates": {
          "FLOAT": [
            "FSUB  <Hd>, <Hn>, <Hm>",
            "FSUB  <Sd>, <Sn>, <Sm>",
            "FSUB  <Dd>, <Dn>, <Dm>"
          ]
        }
      },
      "INS_advsimd_elt": {
        "authored": "Insert vector element from another vector element. This instruction copies the\nvector element of the source SIMD&FP register to the specified vector element of\nthe destination SIMD&FP register.\n\nThis instruction can insert data into individual elements within a SIMD&FP\nregister without clearing the remaining bits to zero.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "INS (element)",
        "templates": {
          "ADVSIMD": [
            "INS  <Vd>.<Ts>[<index1>], <Vn>.<Ts>[<index2>]"
          ]
        }
      },
      "INS_advsimd_gen": {
        "authored": "Insert vector element from general-purpose register. This instruction copies the\ncontents of the source general-purpose register to the specified vector element\nin the destination SIMD&FP register.\n\nThis instruction can insert data into individual elements within a SIMD&FP\nregister without clearing the remaining bits to zero.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "INS (general)",
        "templates": {
          "ADVSIMD": [
            "INS  <Vd>.<Ts>[<index>], <R><n>"
          ]
        }
      },
      "LD1R_advsimd": {
        "authored": "Load one single-element structure and Replicate to all lanes (of one register).\nThis instruction loads a single-element structure from memory and replicates the\nstructure to all the lanes of the SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "LD1R",
        "templates": {
          "AS_NO_POST_INDEX": [
            "LD1R  { <Vt>.<T> }, [<Xn|SP>]"
          ],
          "AS_POST_INDEX": [
            "LD1R  { <Vt>.<T> }, [<Xn|SP>], <imm>",
            "LD1R  { <Vt>.<T> }, [<Xn|SP>], <Xm>"
          ]
        }
      },
      "LD1_advsimd_mult": {
        "authored": "Load multiple single-element structures to one, two, three, or four registers.\nThis instruction loads multiple single-element structures from memory and writes\nthe result to one, two, three, or four SIMD&FP registers.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "LD1 (multiple structures)",
        "templates": {
          "AS_NO_POST_INDEX": [
            "LD1  { <Vt>.<T> }, [<Xn|SP>]",
            "LD1  { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>]",
            "LD1  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>]",
            "LD1  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>]"
          ],
          "AS_POST_INDEX": [
            "LD1  { <Vt>.<T> }, [<Xn|SP>], <imm>",
            "LD1  { <Vt>.<T> }, [<Xn|SP>], <Xm>",
            "LD1  { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>], <imm>",
            "LD1  { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>], <Xm>",
            "LD1  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>], <imm>",
            "LD1  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>], <Xm>",
            "LD1  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>], <imm>",
            "LD1  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>], <Xm>"
          ]
        }
      },
      "LD1_advsimd_sngl": {
        "authored": "Load one single-element structure to one lane of one register. This instruction\nloads a single-element structure from memory and writes the result to the\nspecified lane of the SIMD&FP register without affecting the other bits of the\nregister.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "LD1 (single structure)",
        "templates": {
          "AS_NO_POST_INDEX": [
            "LD1  { <Vt>.B }[<index>], [<Xn|SP>]",
            "LD1  { <Vt>.H }[<index>], [<Xn|SP>]",
            "LD1  { <Vt>.S }[<index>], [<Xn|SP>]",
            "LD1  { <Vt>.D }[<index>], [<Xn|SP>]"
          ],
          "AS_POST_INDEX": [
            "LD1  { <Vt>.B }[<index>], [<Xn|SP>], #1",
            "LD1  { <Vt>.B }[<index>], [<Xn|SP>], <Xm>",
            "LD1  { <Vt>.H }[<index>], [<Xn|SP>], #2",
            "LD1  { <Vt>.H }[<index>], [<Xn|SP>], <Xm>",
            "LD1  { <Vt>.S }[<index>], [<Xn|SP>], #4",
            "LD1  { <Vt>.S }[<index>], [<Xn|SP>], <Xm>",
            "LD1  { <Vt>.D }[<index>], [<Xn|SP>], #8",
            "LD1  { <Vt>.D }[<index>], [<Xn|SP>], <Xm>"
          ]
        }
      },
      "LD2R_advsimd": {
        "authored": "Load single 2-element structure and Replicate to all lanes of two registers.\nThis instruction loads a 2-element structure from memory and replicates the\nstructure to all the lanes of the two SIMD&FP registers.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "LD2R",
        "templates": {
          "AS_NO_POST_INDEX": [
            "LD2R  { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>]"
          ],
          "AS_POST_INDEX": [
            "LD2R  { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>], <imm>",
            "LD2R  { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>], <Xm>"
          ]
        }
      },
      "LD2_advsimd_mult": {
        "authored": "Load multiple 2-element structures to two registers. This instruction loads\nmultiple 2-element structures from memory and writes the result to the two\nSIMD&FP registers, with de-interleaving.\n\nFor an example of de-interleaving, see LD3 (multiple structures).\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "LD2 (multiple structures)",
        "templates": {
          "AS_NO_POST_INDEX": [
            "LD2  { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>]"
          ],
          "AS_POST_INDEX": [
            "LD2  { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>], <imm>",
            "LD2  { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>], <Xm>"
          ]
        }
      },
      "LD2_advsimd_sngl": {
        "authored": "Load single 2-element structure to one lane of two registers. This instruction\nloads a 2-element structure from memory and writes the result to the\ncorresponding elements of the two SIMD&FP registers without affecting the other\nbits of the registers.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "LD2 (single structure)",
        "templates": {
          "AS_NO_POST_INDEX": [
            "LD2  { <Vt>.B, <Vt2>.B }[<index>], [<Xn|SP>]",
            "LD2  { <Vt>.H, <Vt2>.H }[<index>], [<Xn|SP>]",
            "LD2  { <Vt>.S, <Vt2>.S }[<index>], [<Xn|SP>]",
            "LD2  { <Vt>.D, <Vt2>.D }[<index>], [<Xn|SP>]"
          ],
          "AS_POST_INDEX": [
            "LD2  { <Vt>.B, <Vt2>.B }[<index>], [<Xn|SP>], #2",
            "LD2  { <Vt>.B, <Vt2>.B }[<index>], [<Xn|SP>], <Xm>",
            "LD2  { <Vt>.H, <Vt2>.H }[<index>], [<Xn|SP>], #4",
            "LD2  { <Vt>.H, <Vt2>.H }[<index>], [<Xn|SP>], <Xm>",
            "LD2  { <Vt>.S, <Vt2>.S }[<index>], [<Xn|SP>], #8",
            "LD2  { <Vt>.S, <Vt2>.S }[<index>], [<Xn|SP>], <Xm>",
            "LD2  { <Vt>.D, <Vt2>.D }[<index>], [<Xn|SP>], #16",
            "LD2  { <Vt>.D, <Vt2>.D }[<index>], [<Xn|SP>], <Xm>"
          ]
        }
      },
      "LD3R_advsimd": {
        "authored": "Load single 3-element structure and Replicate to all lanes of three registers.\nThis instruction loads a 3-element structure from memory and replicates the\nstructure to all the lanes of the three SIMD&FP registers.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "LD3R",
        "templates": {
          "AS_NO_POST_INDEX": [
            "LD3R  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>]"
          ],
          "AS_POST_INDEX": [
            "LD3R  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>], <imm>",
            "LD3R  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>], <Xm>"
          ]
        }
      },
      "LD3_advsimd_mult": {
        "authored": "Load multiple 3-element structures to three registers. This instruction loads\nmultiple 3-element structures from memory and writes the result to the three\nSIMD&FP registers, with de-interleaving.\n\n\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "LD3 (multiple structures)",
        "templates": {
          "AS_NO_POST_INDEX": [
            "LD3  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>]"
          ],
          "AS_POST_INDEX": [
            "LD3  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>], <imm>",
            "LD3  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>], <Xm>"
          ]
        }
      },
      "LD3_advsimd_sngl": {
        "authored": "Load single 3-element structure to one lane of three registers). This\ninstruction loads a 3-element structure from memory and writes the result to the\ncorresponding elements of the three SIMD&FP registers without affecting the\nother bits of the registers.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "LD3 (single structure)",
        "templates": {
          "AS_NO_POST_INDEX": [
            "LD3  { <Vt>.B, <Vt2>.B, <Vt3>.B }[<index>], [<Xn|SP>]",
            "LD3  { <Vt>.H, <Vt2>.H, <Vt3>.H }[<index>], [<Xn|SP>]",
            "LD3  { <Vt>.S, <Vt2>.S, <Vt3>.S }[<index>], [<Xn|SP>]",
            "LD3  { <Vt>.D, <Vt2>.D, <Vt3>.D }[<index>], [<Xn|SP>]"
          ],
          "AS_POST_INDEX": [
            "LD3  { <Vt>.B, <Vt2>.B, <Vt3>.B }[<index>], [<Xn|SP>], #3",
            "LD3  { <Vt>.B, <Vt2>.B, <Vt3>.B }[<index>], [<Xn|SP>], <Xm>",
            "LD3  { <Vt>.H, <Vt2>.H, <Vt3>.H }[<index>], [<Xn|SP>], #6",
            "LD3  { <Vt>.H, <Vt2>.H, <Vt3>.H }[<index>], [<Xn|SP>], <Xm>",
            "LD3  { <Vt>.S, <Vt2>.S, <Vt3>.S }[<index>], [<Xn|SP>], #12",
            "LD3  { <Vt>.S, <Vt2>.S, <Vt3>.S }[<index>], [<Xn|SP>], <Xm>",
            "LD3  { <Vt>.D, <Vt2>.D, <Vt3>.D }[<index>], [<Xn|SP>], #24",
            "LD3  { <Vt>.D, <Vt2>.D, <Vt3>.D }[<index>], [<Xn|SP>], <Xm>"
          ]
        }
      },
      "LD4R_advsimd": {
        "authored": "Load single 4-element structure and Replicate to all lanes of four registers.\nThis instruction loads a 4-element structure from memory and replicates the\nstructure to all the lanes of the four SIMD&FP registers.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "LD4R",
        "templates": {
          "AS_NO_POST_INDEX": [
            "LD4R  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>]"
          ],
          "AS_POST_INDEX": [
            "LD4R  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>], <imm>",
            "LD4R  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>], <Xm>"
          ]
        }
      },
      "LD4_advsimd_mult": {
        "authored": "Load multiple 4-element structures to four registers. This instruction loads\nmultiple 4-element structures from memory and writes the result to the four\nSIMD&FP registers, with de-interleaving.\n\nFor an example of de-interleaving, see LD3 (multiple structures).\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "LD4 (multiple structures)",
        "templates": {
          "AS_NO_POST_INDEX": [
            "LD4  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>]"
          ],
          "AS_POST_INDEX": [
            "LD4  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>], <imm>",
            "LD4  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>], <Xm>"
          ]
        }
      },
      "LD4_advsimd_sngl": {
        "authored": "Load single 4-element structure to one lane of four registers. This instruction\nloads a 4-element structure from memory and writes the result to the\ncorresponding elements of the four SIMD&FP registers without affecting the other\nbits of the registers.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "LD4 (single structure)",
        "templates": {
          "AS_NO_POST_INDEX": [
            "LD4  { <Vt>.B, <Vt2>.B, <Vt3>.B, <Vt4>.B }[<index>], [<Xn|SP>]",
            "LD4  { <Vt>.H, <Vt2>.H, <Vt3>.H, <Vt4>.H }[<index>], [<Xn|SP>]",
            "LD4  { <Vt>.S, <Vt2>.S, <Vt3>.S, <Vt4>.S }[<index>], [<Xn|SP>]",
            "LD4  { <Vt>.D, <Vt2>.D, <Vt3>.D, <Vt4>.D }[<index>], [<Xn|SP>]"
          ],
          "AS_POST_INDEX": [
            "LD4  { <Vt>.B, <Vt2>.B, <Vt3>.B, <Vt4>.B }[<index>], [<Xn|SP>], #4",
            "LD4  { <Vt>.B, <Vt2>.B, <Vt3>.B, <Vt4>.B }[<index>], [<Xn|SP>], <Xm>",
            "LD4  { <Vt>.H, <Vt2>.H, <Vt3>.H, <Vt4>.H }[<index>], [<Xn|SP>], #8",
            "LD4  { <Vt>.H, <Vt2>.H, <Vt3>.H, <Vt4>.H }[<index>], [<Xn|SP>], <Xm>",
            "LD4  { <Vt>.S, <Vt2>.S, <Vt3>.S, <Vt4>.S }[<index>], [<Xn|SP>], #16",
            "LD4  { <Vt>.S, <Vt2>.S, <Vt3>.S, <Vt4>.S }[<index>], [<Xn|SP>], <Xm>",
            "LD4  { <Vt>.D, <Vt2>.D, <Vt3>.D, <Vt4>.D }[<index>], [<Xn|SP>], #32",
            "LD4  { <Vt>.D, <Vt2>.D, <Vt3>.D, <Vt4>.D }[<index>], [<Xn|SP>], <Xm>"
          ]
        }
      },
      "LDNP_fpsimd": {
        "authored": "Load Pair of SIMD&FP registers, with Non-temporal hint. This instruction loads a\npair of SIMD&FP registers from memory, issuing a hint to the memory system that\nthe access is non-temporal. The address that is used for the load is calculated\nfrom a base register value and an optional immediate offset.\n\nFor information about non-temporal pair instructions, see Load/Store SIMD and\nFloating-point Non-temporal pair.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "LDNP (SIMD&FP)",
        "templates": {
          "SIGNED_SCALED_OFFSET": [
            "LDNP  <St1>, <St2>, [<Xn|SP>{, #<imm>}]",
            "LDNP  <Dt1>, <Dt2>, [<Xn|SP>{, #<imm>}]",
            "LDNP  <Qt1>, <Qt2>, [<Xn|SP>{, #<imm>}]"
          ]
        }
      },
      "LDP_fpsimd": {
        "authored": "Load Pair of SIMD&FP registers. This instruction loads a pair of SIMD&FP\nregisters from memory. The address that is used for the load is calculated from\na base register value and an optional immediate offset.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "LDP (SIMD&FP)",
        "templates": {
          "POST_INDEXED": [
            "LDP  <St1>, <St2>, [<Xn|SP>], #<imm>",
            "LDP  <Dt1>, <Dt2>, [<Xn|SP>], #<imm>",
            "LDP  <Qt1>, <Qt2>, [<Xn|SP>], #<imm>"
          ],
          "PRE_INDEXED": [
            "LDP  <St1>, <St2>, [<Xn|SP>, #<imm>]!",
            "LDP  <Dt1>, <Dt2>, [<Xn|SP>, #<imm>]!",
            "LDP  <Qt1>, <Qt2>, [<Xn|SP>, #<imm>]!"
          ],
          "SIGNED_SCALED_OFFSET": [
            "LDP  <St1>, <St2>, [<Xn|SP>{, #<imm>}]",
            "LDP  <Dt1>, <Dt2>, [<Xn|SP>{, #<imm>}]",
            "LDP  <Qt1>, <Qt2>, [<Xn|SP>{, #<imm>}]"
          ]
        }
      },
      "LDR_imm_fpsimd": {
        "authored": "Load SIMD&FP Register (immediate offset). This instruction loads an element from\nmemory, and writes the result as a scalar to the SIMD&FP register. The address\nthat is used for the load is calculated from a base register value, a signed\nimmediate offset, and an optional offset that is a multiple of the element size.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "LDR (immediate, SIMD&FP)",
        "templates": {
          "POST_INDEXED": [
            "LDR  <Bt>, [<Xn|SP>], #<simm>",
            "LDR  <Ht>, [<Xn|SP>], #<simm>",
            "LDR  <St>, [<Xn|SP>], #<simm>",
            "LDR  <Dt>, [<Xn|SP>], #<simm>",
            "LDR  <Qt>, [<Xn|SP>], #<simm>"
          ],
          "PRE_INDEXED": [
            "LDR  <Bt>, [<Xn|SP>, #<simm>]!",
            "LDR  <Ht>, [<Xn|SP>, #<simm>]!",
            "LDR  <St>, [<Xn|SP>, #<simm>]!",
            "LDR  <Dt>, [<Xn|SP>, #<simm>]!",
            "LDR  <Qt>, [<Xn|SP>, #<simm>]!"
          ],
          "UNSIGNED_SCALED_OFFSET": [
            "LDR  <Bt>, [<Xn|SP>{, #<pimm>}]",
            "LDR  <Ht>, [<Xn|SP>{, #<pimm>}]",
            "LDR  <St>, [<Xn|SP>{, #<pimm>}]",
            "LDR  <Dt>, [<Xn|SP>{, #<pimm>}]",
            "LDR  <Qt>, [<Xn|SP>{, #<pimm>}]"
          ]
        }
      },
      "LDR_lit_fpsimd": {
        "authored": "Load SIMD&FP Register (PC-relative literal). This instruction loads a SIMD&FP\nregister from memory. The address that is used for the load is calculated from\nthe PC value and an immediate offset.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "LDR (literal, SIMD&FP)",
        "templates": {
          "LITERAL": [
            "LDR  <St>, <label>",
            "LDR  <Dt>, <label>",
            "LDR  <Qt>, <label>"
          ]
        }
      },
      "LDR_reg_fpsimd": {
        "authored": "Load SIMD&FP Register (register offset). This instruction loads a SIMD&FP\nregister from memory. The address that is used for the load is calculated from a\nbase register value and an offset register value. The offset can be optionally\nshifted and extended.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "LDR (register, SIMD&FP)",
        "templates": {
          "FPSIMD": [
            "LDR  <Bt>, [<Xn|SP>, (<Wm>|<Xm>), <extend> {<amount>}]",
            "LDR  <Bt>, [<Xn|SP>, <Xm>{, LSL <amount>}]",
            "LDR  <Ht>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]",
            "LDR  <St>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]",
            "LDR  <Dt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]",
            "LDR  <Qt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]"
          ]
        }
      },
      "LDUR_fpsimd": {
        "authored": "Load SIMD&FP Register (unscaled offset). This instruction loads a SIMD&FP\nregister from memory. The address that is used for the load is calculated from a\nbase register value and an optional immediate offset.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "LDUR (SIMD&FP)",
        "templates": {
          "BASE_PLUS_OFFSET": [
            "LDUR  <Bt>, [<Xn|SP>{, #<simm>}]",
            "LDUR  <Ht>, [<Xn|SP>{, #<simm>}]",
            "LDUR  <St>, [<Xn|SP>{, #<simm>}]",
            "LDUR  <Dt>, [<Xn|SP>{, #<simm>}]",
            "LDUR  <Qt>, [<Xn|SP>{, #<simm>}]"
          ]
        }
      },
      "MLA_advsimd_elt": {
        "authored": "Multiply-Add to accumulator (vector, by element). This instruction multiplies\nthe vector elements in the first source SIMD&FP register by the specified value\nin the second source SIMD&FP register, and accumulates the results with the\nvector elements of the destination SIMD&FP register. All the values in this\ninstruction are unsigned integer values.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "MLA (by element)",
        "templates": {
          "2REG_ELEMENT": [
            "MLA  <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]"
          ]
        }
      },
      "MLA_advsimd_vec": {
        "authored": "Multiply-Add to accumulator (vector). This instruction multiplies corresponding\nelements in the vectors of the two source SIMD&FP registers, and accumulates the\nresults with the vector elements of the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "MLA (vector)",
        "templates": {
          "3REG_SAME": [
            "MLA  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ]
        }
      },
      "MLS_advsimd_elt": {
        "authored": "Multiply-Subtract from accumulator (vector, by element). This instruction\nmultiplies the vector elements in the first source SIMD&FP register by the\nspecified value in the second source SIMD&FP register, and subtracts the results\nfrom the vector elements of the destination SIMD&FP register. All the values in\nthis instruction are unsigned integer values.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "MLS (by element)",
        "templates": {
          "2REG_ELEMENT": [
            "MLS  <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]"
          ]
        }
      },
      "MLS_advsimd_vec": {
        "authored": "Multiply-Subtract from accumulator (vector). This instruction multiplies\ncorresponding elements in the vectors of the two source SIMD&FP registers, and\nsubtracts the results from the vector elements of the destination SIMD&FP\nregister.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "MLS (vector)",
        "templates": {
          "3REG_SAME": [
            "MLS  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ]
        }
      },
      "MOVI_advsimd": {
        "authored": "Move Immediate (vector). This instruction places an immediate constant into\nevery vector element of the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "MOVI",
        "templates": {
          "ADVSIMD": [
            "MOVI  <Vd>.<T>, #<imm8>{, LSL #0}",
            "MOVI  <Vd>.<T>, #<imm8>{, LSL #<amount>}",
            "MOVI  <Vd>.<T>, #<imm8>{, LSL #<amount>}",
            "MOVI  <Vd>.<T>, #<imm8>, MSL #<amount>",
            "MOVI  <Dd>, #<imm>",
            "MOVI  <Vd>.2D, #<imm>"
          ]
        }
      },
      "MOV_DUP_advsimd_elt": {
        "authored": "Move vector element to scalar. This instruction duplicates the specified vector\nelement in the SIMD&FP source register into a scalar, and writes the result to\nthe SIMD&FP destination register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "MOV (scalar)",
        "templates": {
          "SCALAR_FROM_ELEMENT": [
            "MOV  <V><d>, <Vn>.<T>[<index>]"
          ]
        }
      },
      "MOV_INS_advsimd_elt": {
        "authored": "Move vector element to another vector element. This instruction copies the\nvector element of the source SIMD&FP register to the specified vector element of\nthe destination SIMD&FP register.\n\nThis instruction can insert data into individual elements within a SIMD&FP\nregister without clearing the remaining bits to zero.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "MOV (element)",
        "templates": {
          "ADVSIMD": [
            "MOV  <Vd>.<Ts>[<index1>], <Vn>.<Ts>[<index2>]"
          ]
        }
      },
      "MOV_INS_advsimd_gen": {
        "authored": "Move general-purpose register to a vector element. This instruction copies the\ncontents of the source general-purpose register to the specified vector element\nin the destination SIMD&FP register.\n\nThis instruction can insert data into individual elements within a SIMD&FP\nregister without clearing the remaining bits to zero.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "MOV (from general)",
        "templates": {
          "ADVSIMD": [
            "MOV  <Vd>.<Ts>[<index>], <R><n>"
          ]
        }
      },
      "MOV_ORR_advsimd_reg": {
        "authored": "Move vector. This instruction copies the vector in the source SIMD&FP register\ninto the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "MOV (vector)",
        "templates": {
          "3REG_SAME": [
            "MOV  <Vd>.<T>, <Vn>.<T>"
          ]
        }
      },
      "MOV_UMOV_advsimd": {
        "authored": "Move vector element to general-purpose register. This instruction reads the\nunsigned integer from the source SIMD&FP register, zero-extends it to form a\n32-bit or 64-bit value, and writes the result to the destination general-purpose\nregister.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "MOV (to general)",
        "templates": {
          "ADVSIMD": [
            "MOV  <Wd>, <Vn>.S[<index>]",
            "MOV  <Xd>, <Vn>.D[<index>]"
          ]
        }
      },
      "MUL_advsimd_elt": {
        "authored": "Multiply (vector, by element). This instruction multiplies the vector elements\nin the first source SIMD&FP register by the specified value in the second source\nSIMD&FP register, places the results in a vector, and writes the vector to the\ndestination SIMD&FP register. All the values in this instruction are unsigned\ninteger values.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "MUL (by element)",
        "templates": {
          "2REG_ELEMENT": [
            "MUL  <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]"
          ]
        }
      },
      "MUL_advsimd_vec": {
        "authored": "Multiply (vector). This instruction multiplies corresponding elements in the\nvectors of the two source SIMD&FP registers, places the results in a vector, and\nwrites the vector to the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "MUL (vector)",
        "templates": {
          "3REG_SAME": [
            "MUL  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ]
        }
      },
      "MVNI_advsimd": {
        "authored": "Move inverted Immediate (vector). This instruction places the inverse of an\nimmediate constant into every vector element of the destination SIMD&FP\nregister.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "MVNI",
        "templates": {
          "ADVSIMD": [
            "MVNI  <Vd>.<T>, #<imm8>{, LSL #<amount>}",
            "MVNI  <Vd>.<T>, #<imm8>{, LSL #<amount>}",
            "MVNI  <Vd>.<T>, #<imm8>, MSL #<amount>"
          ]
        }
      },
      "MVN_NOT_advsimd": {
        "authored": "Bitwise NOT (vector). This instruction reads each vector element from the source\nSIMD&FP register, places the inverse of each value into a vector, and writes the\nvector to the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "MVN",
        "templates": {
          "SIMD": [
            "MVN  <Vd>.<T>, <Vn>.<T>"
          ]
        }
      },
      "NEG_advsimd": {
        "authored": "Negate (vector). This instruction reads each vector element from the source\nSIMD&FP register, negates each value, puts the result into a vector, and writes\nthe vector to the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "NEG (vector)",
        "templates": {
          "SIMD": [
            "NEG  <Vd>.<T>, <Vn>.<T>"
          ],
          "SISD": [
            "NEG  <V><d>, <V><n>"
          ]
        }
      },
      "NOT_advsimd": {
        "authored": "Bitwise NOT (vector). This instruction reads each vector element from the source\nSIMD&FP register, places the inverse of each value into a vector, and writes the\nvector to the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "NOT",
        "templates": {
          "SIMD": [
            "NOT  <Vd>.<T>, <Vn>.<T>"
          ]
        }
      },
      "ORN_advsimd": {
        "authored": "Bitwise inclusive OR NOT (vector). This instruction performs a bitwise OR NOT\nbetween the two source SIMD&FP registers, and writes the result to the\ndestination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "ORN (vector)",
        "templates": {
          "3REG_SAME": [
            "ORN  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ]
        }
      },
      "ORR_advsimd_imm": {
        "authored": "Bitwise inclusive OR (vector, immediate). This instruction reads each vector\nelement from the destination SIMD&FP register, performs a bitwise OR between\neach result and an immediate constant, places the result into a vector, and\nwrites the vector to the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "ORR (vector, immediate)",
        "templates": {
          "SHIFTED_IMMEDIATE": [
            "ORR  <Vd>.<T>, #<imm8>{, LSL #<amount>}",
            "ORR  <Vd>.<T>, #<imm8>{, LSL #<amount>}"
          ]
        }
      },
      "ORR_advsimd_reg": {
        "authored": "Bitwise inclusive OR (vector, register). This instruction performs a bitwise OR\nbetween the two source SIMD&FP registers, and writes the result to the\ndestination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "ORR (vector, register)",
        "templates": {
          "3REG_SAME": [
            "ORR  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ]
        }
      },
      "PMULL_advsimd": {
        "authored": "Polynomial Multiply Long. This instruction multiplies corresponding elements in\nthe lower or upper half of the vectors of the two source SIMD&FP registers,\nplaces the results in a vector, and writes the vector to the destination SIMD&FP\nregister. The destination vector elements are twice as long as the elements that\nare multiplied.\n\nFor information about multiplying polynomials see Polynomial arithmetic over {0,\n1}.\n\nThe PMULL instruction extracts each source vector from the lower half of each\nsource register, while the PMULL2 instruction extracts each source vector from\nthe upper half of each source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "PMULL, PMULL2",
        "templates": {
          "3REG_DIFF": [
            "PMULL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>"
          ]
        }
      },
      "PMUL_advsimd": {
        "authored": "Polynomial Multiply. This instruction multiplies corresponding elements in the\nvectors of the two source SIMD&FP registers, places the results in a vector, and\nwrites the vector to the destination SIMD&FP register.\n\nFor information about multiplying polynomials see Polynomial arithmetic over {0,\n1}.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "PMUL",
        "templates": {
          "3REG_SAME": [
            "PMUL  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ]
        }
      },
      "RADDHN_advsimd": {
        "authored": "Rounding Add returning High Narrow. This instruction adds each vector element in\nthe first source SIMD&FP register to the corresponding vector element in the\nsecond source SIMD&FP register, places the most significant half of the result\ninto a vector, and writes the vector to the lower or upper half of the\ndestination SIMD&FP register.\n\nThe results are rounded. For truncated results, see ADDHN.\n\nThe RADDHN instruction writes the vector to the lower half of the destination\nregister and clears the upper half, while the RADDHN2 instruction writes the\nvector to the upper half of the destination register without affecting the other\nbits of the register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "RADDHN, RADDHN2",
        "templates": {
          "3REG_DIFF": [
            "RADDHN{2}  <Vd>.<Tb>, <Vn>.<Ta>, <Vm>.<Ta>"
          ]
        }
      },
      "RAX1_advsimd": {
        "authored": "Rotate and Exclusive OR rotates each 64-bit element of the 128-bit vector in a\nsource SIMD&FP register left by 1, performs a bitwise exclusive OR of the\nresulting 128-bit vector and the vector in another source SIMD&FP register, and\nwrites the result to the destination SIMD&FP register.\n\nThis instruction is implemented only when FEAT_SHA3 is implemented.",
        "heading": "RAX1",
        "templates": {
          "ADVSIMD": [
            "RAX1  <Vd>.2D, <Vn>.2D, <Vm>.2D"
          ]
        }
      },
      "RBIT_advsimd": {
        "authored": "Reverse Bit order (vector). This instruction reads each vector element from the\nsource SIMD&FP register, reverses the bits of the element, places the results\ninto a vector, and writes the vector to the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "RBIT (vector)",
        "templates": {
          "SIMD": [
            "RBIT  <Vd>.<T>, <Vn>.<T>"
          ]
        }
      },
      "REV16_advsimd": {
        "authored": "Reverse elements in 16-bit halfwords (vector). This instruction reverses the\norder of 8-bit elements in each halfword of the vector in the source SIMD&FP\nregister, places the results into a vector, and writes the vector to the\ndestination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "REV16 (vector)",
        "templates": {
          "SIMD": [
            "REV16  <Vd>.<T>, <Vn>.<T>"
          ]
        }
      },
      "REV32_advsimd": {
        "authored": "Reverse elements in 32-bit words (vector). This instruction reverses the order\nof 8-bit or 16-bit elements in each word of the vector in the source SIMD&FP\nregister, places the results into a vector, and writes the vector to the\ndestination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "REV32 (vector)",
        "templates": {
          "SIMD": [
            "REV32  <Vd>.<T>, <Vn>.<T>"
          ]
        }
      },
      "REV64_advsimd": {
        "authored": "Reverse elements in 64-bit doublewords (vector). This instruction reverses the\norder of 8-bit, 16-bit, or 32-bit elements in each doubleword of the vector in\nthe source SIMD&FP register, places the results into a vector, and writes the\nvector to the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "REV64",
        "templates": {
          "SIMD": [
            "REV64  <Vd>.<T>, <Vn>.<T>"
          ]
        }
      },
      "RSHRN_advsimd": {
        "authored": "Rounding Shift Right Narrow (immediate). This instruction reads each unsigned\ninteger value from the vector in the source SIMD&FP register, right shifts each\nresult by an immediate value, writes the final result to a vector, and writes\nthe vector to the lower or upper half of the destination SIMD&FP register. The\ndestination vector elements are half as long as the source vector elements. The\nresults are rounded. For truncated results, see SHRN.\n\nThe RSHRN instruction writes the vector to the lower half of the destination\nregister and clears the upper half, while the RSHRN2 instruction writes the\nvector to the upper half of the destination register without affecting the other\nbits of the register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "RSHRN, RSHRN2",
        "templates": {
          "SIMD": [
            "RSHRN{2}  <Vd>.<Tb>, <Vn>.<Ta>, #<shift>"
          ]
        }
      },
      "RSUBHN_advsimd": {
        "authored": "Rounding Subtract returning High Narrow. This instruction subtracts each vector\nelement of the second source SIMD&FP register from the corresponding vector\nelement of the first source SIMD&FP register, places the most significant half\nof the result into a vector, and writes the vector to the lower or upper half of\nthe destination SIMD&FP register.\n\nThe results are rounded. For truncated results, see SUBHN.\n\nThe RSUBHN instruction writes the vector to the lower half of the destination\nregister and clears the upper half, while the RSUBHN2 instruction writes the\nvector to the upper half of the destination register without affecting the other\nbits of the register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "RSUBHN, RSUBHN2",
        "templates": {
          "3REG_DIFF": [
            "RSUBHN{2}  <Vd>.<Tb>, <Vn>.<Ta>, <Vm>.<Ta>"
          ]
        }
      },
      "SABAL_advsimd": {
        "authored": "Signed Absolute difference and Accumulate Long. This instruction subtracts the\nvector elements in the lower or upper half of the second source SIMD&FP register\nfrom the corresponding vector elements of the first source SIMD&FP register, and\naccumulates the absolute values of the results into the vector elements of the\ndestination SIMD&FP register. The destination vector elements are twice as long\nas the source vector elements.\n\nThe SABAL instruction extracts each source vector from the lower half of each\nsource register, while the SABAL2 instruction extracts each source vector from\nthe upper half of each source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SABAL, SABAL2",
        "templates": {
          "3REG_DIFF": [
            "SABAL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>"
          ]
        }
      },
      "SABA_advsimd": {
        "authored": "Signed Absolute difference and Accumulate. This instruction subtracts the\nelements of the vector of the second source SIMD&FP register from the\ncorresponding elements of the first source SIMD&FP register, and accumulates the\nabsolute values of the results into the elements of the vector of the\ndestination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SABA",
        "templates": {
          "3REG_SAME": [
            "SABA  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ]
        }
      },
      "SABDL_advsimd": {
        "authored": "Signed Absolute Difference Long. This instruction subtracts the vector elements\nof the second source SIMD&FP register from the corresponding vector elements of\nthe first source SIMD&FP register, places the absolute value of the results into\na vector, and writes the vector to the lower or upper half of the destination\nSIMD&FP register. The destination vector elements are twice as long as the\nsource vector elements.\n\nThe SABDL instruction writes the vector to the lower half of the destination\nregister and clears the upper half, while the SABDL2 instruction writes the\nvector to the upper half of the destination register without affecting the other\nbits of the register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SABDL, SABDL2",
        "templates": {
          "3REG_DIFF": [
            "SABDL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>"
          ]
        }
      },
      "SABD_advsimd": {
        "authored": "Signed Absolute Difference. This instruction subtracts the elements of the\nvector of the second source SIMD&FP register from the corresponding elements of\nthe first source SIMD&FP register, places the the absolute values of the results\ninto a vector, and writes the vector to the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SABD",
        "templates": {
          "3REG_SAME": [
            "SABD  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ]
        }
      },
      "SADALP_advsimd": {
        "authored": "Signed Add and Accumulate Long Pairwise. This instruction adds pairs of adjacent\nsigned integer values from the vector in the source SIMD&FP register and\naccumulates the results into the vector elements of the destination SIMD&FP\nregister. The destination vector elements are twice as long as the source vector\nelements.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SADALP",
        "templates": {
          "SIMD": [
            "SADALP  <Vd>.<Ta>, <Vn>.<Tb>"
          ]
        }
      },
      "SADDLP_advsimd": {
        "authored": "Signed Add Long Pairwise. This instruction adds pairs of adjacent signed integer\nvalues from the vector in the source SIMD&FP register, places the result into a\nvector, and writes the vector to the destination SIMD&FP register. The\ndestination vector elements are twice as long as the source vector elements.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SADDLP",
        "templates": {
          "SIMD": [
            "SADDLP  <Vd>.<Ta>, <Vn>.<Tb>"
          ]
        }
      },
      "SADDLV_advsimd": {
        "authored": "Signed Add Long across Vector. This instruction adds every vector element in the\nsource SIMD&FP register together, and writes the scalar result to the\ndestination SIMD&FP register. The destination scalar is twice as long as the\nsource vector elements. All the values in this instruction are signed integer\nvalues.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SADDLV",
        "templates": {
          "ADVSIMD": [
            "SADDLV  <V><d>, <Vn>.<T>"
          ]
        }
      },
      "SADDL_advsimd": {
        "authored": "Signed Add Long (vector). This instruction adds each vector element in the lower\nor upper half of the first source SIMD&FP register to the corresponding vector\nelement of the second source SIMD&FP register, places the results into a vector,\nand writes the vector to the destination SIMD&FP register.  The destination\nvector elements are twice as long as the source vector elements. All the values\nin this instruction are signed integer values.\n\nThe SADDL instruction extracts each source vector from the lower half of each\nsource register, while the SADDL2 instruction extracts each source vector from\nthe upper half of each source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SADDL, SADDL2",
        "templates": {
          "3REG_DIFF": [
            "SADDL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>"
          ]
        }
      },
      "SADDW_advsimd": {
        "authored": "Signed Add Wide. This instruction adds vector elements of the first source\nSIMD&FP register to the corresponding vector elements in the lower or upper half\nof the second source SIMD&FP register, places the results in a vector, and\nwrites the vector to the SIMD&FP destination register.\n\nThe SADDW instruction extracts the second source vector from the lower half of\nthe second source register, while the SADDW2 instruction extracts the second\nsource vector from the upper half of the second source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SADDW, SADDW2",
        "templates": {
          "3REG_DIFF": [
            "SADDW{2}  <Vd>.<Ta>, <Vn>.<Ta>, <Vm>.<Tb>"
          ]
        }
      },
      "SCVTF_advsimd_fix": {
        "authored": "Signed fixed-point Convert to Floating-point (vector). This instruction converts\neach element in a vector from fixed-point to floating-point using the rounding\nmode that is specified by the FPCR, and writes the result to the SIMD&FP\ndestination register.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the Security state and Exception level in which the instruction is executed,\nan attempt to execute the instruction might be trapped.",
        "heading": "SCVTF (vector, fixed-point)",
        "templates": {
          "SIMD": [
            "SCVTF  <Vd>.<T>, <Vn>.<T>, #<fbits>"
          ],
          "SISD": [
            "SCVTF  <V><d>, <V><n>, #<fbits>"
          ]
        }
      },
      "SCVTF_advsimd_int": {
        "authored": "Signed integer Convert to Floating-point (vector). This instruction converts\neach element in a vector from signed integer to floating-point using the\nrounding mode that is specified by the FPCR, and writes the result to the\nSIMD&FP destination register.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the Security state and Exception level in which the instruction is executed,\nan attempt to execute the instruction might be trapped.",
        "heading": "SCVTF (vector, integer)",
        "templates": {
          "SIMD_HALF": [
            "SCVTF  <Vd>.<T>, <Vn>.<T>"
          ],
          "SIMD_SINGLE_AND_DOUBLE": [
            "SCVTF  <Vd>.<T>, <Vn>.<T>"
          ],
          "SISD_HALF": [
            "SCVTF  <Hd>, <Hn>"
          ],
          "SISD_SINGLE_AND_DOUBLE": [
            "SCVTF  <V><d>, <V><n>"
          ]
        }
      },
      "SCVTF_float_fix": {
        "authored": "Signed fixed-point Convert to Floating-point (scalar). This instruction converts\nthe signed value in the 32-bit or 64-bit general-purpose source register to a\nfloating-point value using the rounding mode that is specified by the FPCR, and\nwrites the result to the SIMD&FP destination register.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the Security state and Exception level in which the instruction is executed,\nan attempt to execute the instruction might be trapped.",
        "heading": "SCVTF (scalar, fixed-point)",
        "templates": {
          "FLOAT": [
            "SCVTF  <Hd>, <Wn>, #<fbits>",
            "SCVTF  <Sd>, <Wn>, #<fbits>",
            "SCVTF  <Dd>, <Wn>, #<fbits>",
            "SCVTF  <Hd>, <Xn>, #<fbits>",
            "SCVTF  <Sd>, <Xn>, #<fbits>",
            "SCVTF  <Dd>, <Xn>, #<fbits>"
          ]
        }
      },
      "SCVTF_float_int": {
        "authored": "Signed integer Convert to Floating-point (scalar). This instruction converts the\nsigned integer value in the general-purpose source register to a floating-point\nvalue using the rounding mode that is specified by the FPCR, and writes the\nresult to the SIMD&FP destination register.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SCVTF (scalar, integer)",
        "templates": {
          "FLOAT": [
            "SCVTF  <Hd>, <Wn>",
            "SCVTF  <Sd>, <Wn>",
            "SCVTF  <Dd>, <Wn>",
            "SCVTF  <Hd>, <Xn>",
            "SCVTF  <Sd>, <Xn>",
            "SCVTF  <Dd>, <Xn>"
          ]
        }
      },
      "SDOT_advsimd_elt": {
        "authored": "Dot Product signed arithmetic (vector, by element). This instruction performs\nthe dot product of the four 8-bit elements in each 32-bit element of the first\nsource register with the four 8-bit elements of an indexed 32-bit element in the\nsecond source register, accumulating the result into the corresponding 32-bit\nelement of the destination register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.\n\nIn Armv8.2 and Armv8.3, this is an optional instruction. From Armv8.4 it is\nmandatory for all implementations to support it.\n\nID_AA64ISAR0_EL1.DP indicates whether this instruction is supported.",
        "heading": "SDOT (by element)",
        "templates": {
          "2REG_ELEMENT": [
            "SDOT  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.4B[<index>]"
          ]
        }
      },
      "SDOT_advsimd_vec": {
        "authored": "Dot Product signed arithmetic (vector). This instruction performs the dot\nproduct of the four signed 8-bit elements in each 32-bit element of the first\nsource register with the four signed 8-bit elements of the corresponding 32-bit\nelement in the second source register, accumulating the result into the\ncorresponding 32-bit element of the destination register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.\n\nIn Armv8.2 and Armv8.3, this is an optional instruction. From Armv8.4 it is\nmandatory for all implementations to support it.\n\nID_AA64ISAR0_EL1.DP indicates whether this instruction is supported.",
        "heading": "SDOT (vector)",
        "templates": {
          "SIMD": [
            "SDOT  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>"
          ]
        }
      },
      "SHA1C_advsimd": {
        "authored": "SHA1 hash update (choose).",
        "heading": "SHA1C",
        "templates": {
          "ADVSIMD": [
            "SHA1C  <Qd>, <Sn>, <Vm>.4S"
          ]
        }
      },
      "SHA1H_advsimd": {
        "authored": "SHA1 fixed rotate.",
        "heading": "SHA1H",
        "templates": {
          "ADVSIMD": [
            "SHA1H  <Sd>, <Sn>"
          ]
        }
      },
      "SHA1M_advsimd": {
        "authored": "SHA1 hash update (majority).",
        "heading": "SHA1M",
        "templates": {
          "ADVSIMD": [
            "SHA1M  <Qd>, <Sn>, <Vm>.4S"
          ]
        }
      },
      "SHA1P_advsimd": {
        "authored": "SHA1 hash update (parity).",
        "heading": "SHA1P",
        "templates": {
          "ADVSIMD": [
            "SHA1P  <Qd>, <Sn>, <Vm>.4S"
          ]
        }
      },
      "SHA1SU0_advsimd": {
        "authored": "SHA1 schedule update 0.",
        "heading": "SHA1SU0",
        "templates": {
          "ADVSIMD": [
            "SHA1SU0  <Vd>.4S, <Vn>.4S, <Vm>.4S"
          ]
        }
      },
      "SHA1SU1_advsimd": {
        "authored": "SHA1 schedule update 1.",
        "heading": "SHA1SU1",
        "templates": {
          "ADVSIMD": [
            "SHA1SU1  <Vd>.4S, <Vn>.4S"
          ]
        }
      },
      "SHA256H2_advsimd": {
        "authored": "SHA256 hash update (part 2).",
        "heading": "SHA256H2",
        "templates": {
          "ADVSIMD": [
            "SHA256H2  <Qd>, <Qn>, <Vm>.4S"
          ]
        }
      },
      "SHA256H_advsimd": {
        "authored": "SHA256 hash update (part 1).",
        "heading": "SHA256H",
        "templates": {
          "ADVSIMD": [
            "SHA256H  <Qd>, <Qn>, <Vm>.4S"
          ]
        }
      },
      "SHA256SU0_advsimd": {
        "authored": "SHA256 schedule update 0.",
        "heading": "SHA256SU0",
        "templates": {
          "ADVSIMD": [
            "SHA256SU0  <Vd>.4S, <Vn>.4S"
          ]
        }
      },
      "SHA256SU1_advsimd": {
        "authored": "SHA256 schedule update 1.",
        "heading": "SHA256SU1",
        "templates": {
          "ADVSIMD": [
            "SHA256SU1  <Vd>.4S, <Vn>.4S, <Vm>.4S"
          ]
        }
      },
      "SHA512H2_advsimd": {
        "authored": "SHA512 Hash update part 2 takes the values from the three 128-bit source SIMD&FP\nregisters and produces a 128-bit output value that combines the sigma0 and\nmajority functions of two iterations of the SHA512 computation. It returns this\nvalue to the destination SIMD&FP register.\n\nThis instruction is implemented only when FEAT_SHA512 is implemented.",
        "heading": "SHA512H2",
        "templates": {
          "ADVSIMD": [
            "SHA512H2  <Qd>, <Qn>, <Vm>.2D"
          ]
        }
      },
      "SHA512H_advsimd": {
        "authored": "SHA512 Hash update part 1 takes the values from the three 128-bit source SIMD&FP\nregisters and produces a 128-bit output value that combines the sigma1 and chi\nfunctions of two iterations of the SHA512 computation. It returns this value to\nthe destination SIMD&FP register.\n\nThis instruction is implemented only when FEAT_SHA512 is implemented.",
        "heading": "SHA512H",
        "templates": {
          "ADVSIMD": [
            "SHA512H  <Qd>, <Qn>, <Vm>.2D"
          ]
        }
      },
      "SHA512SU0_advsimd": {
        "authored": "SHA512 Schedule Update 0 takes the values from the two 128-bit source SIMD&FP\nregisters and produces a 128-bit output value that combines the gamma0 functions\nof two iterations of the SHA512 schedule update that are performed after the\nfirst 16 iterations within a block. It returns this value to the destination\nSIMD&FP register.\n\nThis instruction is implemented only when FEAT_SHA512 is implemented.",
        "heading": "SHA512SU0",
        "templates": {
          "ADVSIMD": [
            "SHA512SU0  <Vd>.2D, <Vn>.2D"
          ]
        }
      },
      "SHA512SU1_advsimd": {
        "authored": "SHA512 Schedule Update 1 takes the values from the three source SIMD&FP\nregisters and produces a 128-bit output value that combines the gamma1 functions\nof two iterations of the SHA512 schedule update that are performed after the\nfirst 16 iterations within a block. It returns this value to the destination\nSIMD&FP register.\n\nThis instruction is implemented only when FEAT_SHA512 is implemented.",
        "heading": "SHA512SU1",
        "templates": {
          "ADVSIMD": [
            "SHA512SU1  <Vd>.2D, <Vn>.2D, <Vm>.2D"
          ]
        }
      },
      "SHADD_advsimd": {
        "authored": "Signed Halving Add. This instruction adds corresponding signed integer values\nfrom the two source SIMD&FP registers, shifts each result right one bit, places\nthe results into a vector, and writes the vector to the destination SIMD&FP\nregister.\n\nThe results are truncated. For rounded results, see SRHADD.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SHADD",
        "templates": {
          "3REG_SAME": [
            "SHADD  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ]
        }
      },
      "SHLL_advsimd": {
        "authored": "Shift Left Long (by element size). This instruction reads each vector element in\nthe lower or upper half of the source SIMD&FP register, left shifts each result\nby the element size, writes the final result to a vector, and writes the vector\nto the destination SIMD&FP register. The destination vector elements are twice\nas long as the source vector elements.\n\nThe SHLL instruction extracts vector elements from the lower half of the source\nregister, while the SHLL2 instruction extracts vector elements from the upper\nhalf of the source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SHLL, SHLL2",
        "templates": {
          "SIMD": [
            "SHLL{2}  <Vd>.<Ta>, <Vn>.<Tb>, #<shift>"
          ]
        }
      },
      "SHL_advsimd": {
        "authored": "Shift Left (immediate). This instruction reads each value from a vector, left\nshifts each result by an immediate value, writes the final result to a vector,\nand writes the vector to the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SHL",
        "templates": {
          "SIMD": [
            "SHL  <Vd>.<T>, <Vn>.<T>, #<shift>"
          ],
          "SISD": [
            "SHL  <V><d>, <V><n>, #<shift>"
          ]
        }
      },
      "SHRN_advsimd": {
        "authored": "Shift Right Narrow (immediate). This instruction reads each unsigned integer\nvalue from the source SIMD&FP register, right shifts each result by an immediate\nvalue, puts the final result into a vector, and writes the vector to the lower\nor upper half of the destination SIMD&FP register. The destination vector\nelements are half as long as the source vector elements. The results are\ntruncated. For rounded results, see RSHRN.\n\nThe RSHRN instruction writes the vector to the lower half of the destination\nregister and clears the upper half, while the RSHRN2 instruction writes the\nvector to the upper half of the destination register without affecting the other\nbits of the register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SHRN, SHRN2",
        "templates": {
          "SIMD": [
            "SHRN{2}  <Vd>.<Tb>, <Vn>.<Ta>, #<shift>"
          ]
        }
      },
      "SHSUB_advsimd": {
        "authored": "Signed Halving Subtract. This instruction subtracts the elements in the vector\nin the second source SIMD&FP register from the corresponding elements in the\nvector in the first source SIMD&FP register, shifts each result right one bit,\nplaces each result into elements of a vector, and writes the vector to the\ndestination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SHSUB",
        "templates": {
          "3REG_SAME": [
            "SHSUB  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ]
        }
      },
      "SLI_advsimd": {
        "authored": "Shift Left and Insert (immediate). This instruction reads each vector element in\nthe source SIMD&FP register, left shifts each vector element by an immediate\nvalue, and inserts the result into the corresponding vector element in the\ndestination SIMD&FP register such that the new zero bits created by the shift\nare not inserted but retain their existing value. Bits shifted out of the left\nof each vector element in the source register are lost.\n\n\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SLI",
        "templates": {
          "SIMD": [
            "SLI  <Vd>.<T>, <Vn>.<T>, #<shift>"
          ],
          "SISD": [
            "SLI  <V><d>, <V><n>, #<shift>"
          ]
        }
      },
      "SM3PARTW1_advsimd": {
        "authored": "SM3PARTW1 takes three 128-bit vectors from the three source SIMD&FP registers\nand returns a 128-bit result in the destination SIMD&FP register. The result is\nobtained by a three-way exclusive OR of the elements within the input vectors\nwith some fixed rotations, see the Operation pseudocode for more information.\n\nThis instruction is implemented only when FEAT_SM3 is implemented.",
        "heading": "SM3PARTW1",
        "templates": {
          "ADVSIMD": [
            "SM3PARTW1  <Vd>.4S, <Vn>.4S, <Vm>.4S"
          ]
        }
      },
      "SM3PARTW2_advsimd": {
        "authored": "SM3PARTW2 takes three 128-bit vectors from three source SIMD&FP registers and\nreturns a 128-bit result in the destination SIMD&FP register. The result is\nobtained by a three-way exclusive OR of the elements within the input vectors\nwith some fixed rotations, see the Operation pseudocode for more information.\n\nThis instruction is implemented only when FEAT_SM3 is implemented.",
        "heading": "SM3PARTW2",
        "templates": {
          "ADVSIMD": [
            "SM3PARTW2  <Vd>.4S, <Vn>.4S, <Vm>.4S"
          ]
        }
      },
      "SM3SS1_advsimd": {
        "authored": "SM3SS1 rotates the top 32 bits of the 128-bit vector in the first source SIMD&FP\nregister by 12, and adds that 32-bit value to the two other 32-bit values held\nin the top 32 bits of each of the 128-bit vectors in the second and third source\nSIMD&FP registers, rotating this result left by 7 and writing the final result\ninto the top 32 bits of the vector in the destination SIMD&FP register, with the\nbottom 96 bits of the vector being written to 0.\n\nThis instruction is implemented only when FEAT_SM3 is implemented.",
        "heading": "SM3SS1",
        "templates": {
          "ADVSIMD": [
            "SM3SS1  <Vd>.4S, <Vn>.4S, <Vm>.4S, <Va>.4S"
          ]
        }
      },
      "SM3TT1A_advsimd": {
        "authored": "SM3TT1A takes three 128-bit vectors from three source SIMD&FP registers and a\n2-bit immediate index value, and returns a 128-bit result in the destination\nSIMD&FP register.  It performs a three-way exclusive OR of the three 32-bit\nfields held in the upper three elements of the first source vector, and adds the\nresulting 32-bit value and the following three other 32-bit values:\n  - The bottom 32-bit element of the first source vector, Vd, that was used for\nthe three-way exclusive OR.\n  - The result of the exclusive OR of the top 32-bit element of the second\nsource vector, Vn, with a rotation left by 12 of the top 32-bit element of the\nfirst source vector.\n  - A 32-bit element indexed out of the third source vector, Vm.\n\nThe result of this addition is returned as the top element of the result. The\nother elements of the result are taken from elements of the first source vector,\nwith the element returned in bits<63:32> being rotated left by 9.\n\nThis instruction is implemented only when FEAT_SM3 is implemented.",
        "heading": "SM3TT1A",
        "templates": {
          "ADVSIMD": [
            "SM3TT1A  <Vd>.4S, <Vn>.4S, <Vm>.S[<imm2>]"
          ]
        }
      },
      "SM3TT1B_advsimd": {
        "authored": "SM3TT1B takes three 128-bit vectors from three source SIMD&FP registers and a\n2-bit immediate index value, and returns a 128-bit result in the destination\nSIMD&FP register. It performs a 32-bit majority function between the three\n32-bit fields held in the upper three elements of the first source vector, and\nadds the resulting 32-bit value and the following three other 32-bit values:\n  - The bottom 32-bit element of the first source vector, Vd, that was used for\nthe 32-bit majority function.\n  - The result of the exclusive OR of the top 32-bit element of the second\nsource vector, Vn, with a rotation left by 12 of the top 32-bit element of the\nfirst source vector.\n  - A 32-bit element indexed out of the third source vector, Vm.\n\nThe result of this addition is returned as the top element of the result. The\nother elements of the result are taken from elements of the first source vector,\nwith the element returned in bits<63:32> being rotated left by 9.\n\nThis instruction is implemented only when FEAT_SM3 is implemented.",
        "heading": "SM3TT1B",
        "templates": {
          "ADVSIMD": [
            "SM3TT1B  <Vd>.4S, <Vn>.4S, <Vm>.S[<imm2>]"
          ]
        }
      },
      "SM3TT2A_advsimd": {
        "authored": "SM3TT2A takes three 128-bit vectors from three source SIMD&FP register and a\n2-bit immediate index value, and returns a 128-bit result in the destination\nSIMD&FP register. It performs a three-way exclusive OR of the three 32-bit\nfields held in the upper three elements of the first source vector, and adds the\nresulting 32-bit value and the following three other 32-bit values:\n  - The bottom 32-bit element of the first source vector, Vd, that was used for\nthe three-way exclusive OR.\n  - The 32-bit element held in the top 32 bits of the second source vector, Vn.\n  - A 32-bit element indexed out of the third source vector, Vm.\n\nA three-way exclusive OR is performed of the result of this addition, the result\nof the addition rotated left by 9, and the result of the addition rotated left\nby 17. The result of this exclusive OR is returned as the top element of the\nreturned result. The other elements of this result are taken from elements of\nthe first source vector, with the element returned in bits<63:32> being rotated\nleft by 19.\n\nThis instruction is implemented only when FEAT_SM3 is implemented.",
        "heading": "SM3TT2A",
        "templates": {
          "ADVSIMD": [
            "SM3TT2A  <Vd>.4S, <Vn>.4S, <Vm>.S[<imm2>]"
          ]
        }
      },
      "SM3TT2B_advsimd": {
        "authored": "SM3TT2B takes three 128-bit vectors from three source SIMD&FP registers, and a\n2-bit immediate index value, and returns a 128-bit result in the destination\nSIMD&FP register. It performs a 32-bit majority function between the three\n32-bit fields held in the upper three elements of the first source vector, and\nadds the resulting 32-bit value and the following three other 32-bit values:\n  - The bottom 32-bit element of the first source vector, Vd, that was used for\nthe 32-bit majority function.\n  - The 32-bit element held in the top 32 bits of the second source vector, Vn.\n  - A 32-bit element indexed out of the third source vector, Vm.\n\nA three-way exclusive OR is performed of the result of this addition, the result\nof the addition rotated left by 9, and the result of the addition rotated left\nby 17. The result of this exclusive OR is returned as the top element of the\nreturned result. The other elements of this result are taken from elements of\nthe first source vector, with the element returned in bits<63:32> being rotated\nleft by 19.\n\nThis instruction is implemented only when FEAT_SM3 is implemented.",
        "heading": "SM3TT2B",
        "templates": {
          "ADVSIMD": [
            "SM3TT2B  <Vd>.4S, <Vn>.4S, <Vm>.S[<imm2>]"
          ]
        }
      },
      "SM4EKEY_advsimd": {
        "authored": "SM4 Key takes an input as a 128-bit vector from the first source SIMD&FP\nregister and a 128-bit constant from the second SIMD&FP register. It derives\nfour iterations of the output key, in accordance with the SM4 standard,\nreturning the 128-bit result to the destination SIMD&FP register.\n\nThis instruction is implemented only when FEAT_SM4 is implemented.",
        "heading": "SM4EKEY",
        "templates": {
          "ADVSIMD": [
            "SM4EKEY  <Vd>.4S, <Vn>.4S, <Vm>.4S"
          ]
        }
      },
      "SM4E_advsimd": {
        "authored": "SM4 Encode takes input data as a 128-bit vector from the first source SIMD&FP\nregister, and four iterations of the round key held as the elements of the\n128-bit vector in the second source SIMD&FP register. It encrypts the data by\nfour rounds, in accordance with the SM4 standard, returning the 128-bit result\nto the destination SIMD&FP register.\n\nThis instruction is implemented only when FEAT_SM4 is implemented.",
        "heading": "SM4E",
        "templates": {
          "ADVSIMD": [
            "SM4E  <Vd>.4S, <Vn>.4S"
          ]
        }
      },
      "SMAXP_advsimd": {
        "authored": "Signed Maximum Pairwise. This instruction creates a vector by concatenating the\nvector elements of the first source SIMD&FP register after the vector elements\nof the second source SIMD&FP register, reads each pair of adjacent vector\nelements in the two source SIMD&FP registers, writes the largest of each pair of\nsigned integer values into a vector, and writes the vector to the destination\nSIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SMAXP",
        "templates": {
          "3REG_SAME": [
            "SMAXP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ]
        }
      },
      "SMAXV_advsimd": {
        "authored": "Signed Maximum across Vector. This instruction compares all the vector elements\nin the source SIMD&FP register, and writes the largest of the values as a scalar\nto the destination SIMD&FP register. All the values in this instruction are\nsigned integer values.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SMAXV",
        "templates": {
          "ADVSIMD": [
            "SMAXV  <V><d>, <Vn>.<T>"
          ]
        }
      },
      "SMAX_advsimd": {
        "authored": "Signed Maximum (vector). This instruction compares corresponding elements in the\nvectors in the two source SIMD&FP registers, places the larger of each pair of\nsigned integer values into a vector, and writes the vector to the destination\nSIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SMAX",
        "templates": {
          "3REG_SAME": [
            "SMAX  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ]
        }
      },
      "SMINP_advsimd": {
        "authored": "Signed Minimum Pairwise. This instruction creates a vector by concatenating the\nvector elements of the first source SIMD&FP register after the vector elements\nof the second source SIMD&FP register, reads each pair of adjacent vector\nelements in the two source SIMD&FP registers, writes the smallest of each pair\nof signed integer values into a vector, and writes the vector to the destination\nSIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SMINP",
        "templates": {
          "3REG_SAME": [
            "SMINP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ]
        }
      },
      "SMINV_advsimd": {
        "authored": "Signed Minimum across Vector. This instruction compares all the vector elements\nin the source SIMD&FP register, and writes the smallest of the values as a\nscalar to the destination SIMD&FP register. All the values in this instruction\nare signed integer values.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SMINV",
        "templates": {
          "ADVSIMD": [
            "SMINV  <V><d>, <Vn>.<T>"
          ]
        }
      },
      "SMIN_advsimd": {
        "authored": "Signed Minimum (vector). This instruction compares corresponding elements in the\nvectors in the two source SIMD&FP registers, places the smaller of each of the\ntwo signed integer values into a vector, and writes the vector to the\ndestination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SMIN",
        "templates": {
          "3REG_SAME": [
            "SMIN  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ]
        }
      },
      "SMLAL_advsimd_elt": {
        "authored": "Signed Multiply-Add Long (vector, by element). This instruction multiplies each\nvector element in the lower or upper half of the first source SIMD&FP register\nby the specified vector element in the second source SIMD&FP register, and\naccumulates the results with the vector elements of the destination SIMD&FP\nregister. The destination vector elements are twice as long as the elements that\nare multiplied. All the values in this instruction are signed integer values.\n\nThe SMLAL instruction extracts vector elements from the lower half of the first\nsource register, while the SMLAL2 instruction extracts vector elements from the\nupper half of the first source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SMLAL, SMLAL2 (by element)",
        "templates": {
          "2REG_ELEMENT": [
            "SMLAL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Ts>[<index>]"
          ]
        }
      },
      "SMLAL_advsimd_vec": {
        "authored": "Signed Multiply-Add Long (vector). This instruction multiplies corresponding\nsigned integer values in the lower or upper half of the vectors of the two\nsource SIMD&FP registers, and accumulates the results with the vector elements\nof the destination SIMD&FP register. The destination vector elements are twice\nas long as the elements that are multiplied.\n\nThe SMLAL instruction extracts each source vector from the lower half of each\nsource register, while the SMLAL2 instruction extracts each source vector from\nthe upper half of each source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SMLAL, SMLAL2 (vector)",
        "templates": {
          "3REG_DIFF": [
            "SMLAL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>"
          ]
        }
      },
      "SMLSL_advsimd_elt": {
        "authored": "Signed Multiply-Subtract Long (vector, by element). This instruction multiplies\neach vector element in the lower or upper half of the first source SIMD&FP\nregister by the specified vector element of the second source SIMD&FP register\nand subtracts the results from the vector elements of the destination SIMD&FP\nregister. The destination vector elements are twice as long as the elements that\nare multiplied.\n\nThe SMLSL instruction extracts vector elements from the lower half of the first\nsource register, while the SMLSL2 instruction extracts vector elements from the\nupper half of the first source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SMLSL, SMLSL2 (by element)",
        "templates": {
          "2REG_ELEMENT": [
            "SMLSL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Ts>[<index>]"
          ]
        }
      },
      "SMLSL_advsimd_vec": {
        "authored": "Signed Multiply-Subtract Long (vector). This instruction multiplies\ncorresponding signed integer values in the lower or upper half of the vectors of\nthe two source SIMD&FP registers, and subtracts the results from the vector\nelements of the destination SIMD&FP register. The destination vector elements\nare twice as long as the elements that are multiplied.\n\nThe SMLSL instruction extracts each source vector from the lower half of each\nsource register, while the SMLSL2 instruction extracts each source vector from\nthe upper half of each source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SMLSL, SMLSL2 (vector)",
        "templates": {
          "3REG_DIFF": [
            "SMLSL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>"
          ]
        }
      },
      "SMMLA_advsimd_vec": {
        "authored": "Signed 8-bit integer matrix multiply-accumulate. This instruction multiplies the\n2x8 matrix of signed 8-bit integer values in the first source vector by the 8x2\nmatrix of signed 8-bit integer values in the second source vector. The resulting\n2x2 32-bit integer matrix product is destructively added to the 32-bit integer\nmatrix accumulator in the destination vector. This is equivalent to performing\nan 8-way dot product per destination element.\n\nFrom Armv8.2 to Armv8.5, this is an optional instruction. From Armv8.6 it is\nmandatory for implementations that include Advanced SIMD to support it.\nID_AA64ISAR1_EL1.I8MM indicates whether this instruction is supported.",
        "heading": "SMMLA (vector)",
        "templates": {
          "SIMD": [
            "SMMLA  <Vd>.4S, <Vn>.16B, <Vm>.16B"
          ]
        }
      },
      "SMOV_advsimd": {
        "authored": "Signed Move vector element to general-purpose register. This instruction reads\nthe signed integer from the source SIMD&FP register, sign-extends it to form a\n32-bit or 64-bit value, and writes the result to destination general-purpose\nregister.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SMOV",
        "templates": {
          "ADVSIMD": [
            "SMOV  <Wd>, <Vn>.<Ts>[<index>]",
            "SMOV  <Xd>, <Vn>.<Ts>[<index>]"
          ]
        }
      },
      "SMULL_advsimd_elt": {
        "authored": "Signed Multiply Long (vector, by element). This instruction multiplies each\nvector element in the lower or upper half of the first source SIMD&FP register\nby the specified vector element of the second source SIMD&FP register, places\nthe result in a vector, and writes the vector to the destination SIMD&FP\nregister. The destination vector elements are twice as long as the elements that\nare multiplied.\n\nThe SMULL instruction extracts vector elements from the lower half of the first\nsource register, while the SMULL2 instruction extracts vector elements from the\nupper half of the first source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SMULL, SMULL2 (by element)",
        "templates": {
          "2REG_ELEMENT": [
            "SMULL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Ts>[<index>]"
          ]
        }
      },
      "SMULL_advsimd_vec": {
        "authored": "Signed Multiply Long (vector). This instruction multiplies corresponding signed\ninteger values in the lower or upper half of the vectors of the two source\nSIMD&FP registers, places the results in a vector, and writes the vector to the\ndestination SIMD&FP register.\n\nThe destination vector elements are twice as long as the elements that are\nmultiplied.\n\nThe SMULL instruction extracts each source vector from the lower half of each\nsource register, while the SMULL2 instruction extracts each source vector from\nthe upper half of each source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SMULL, SMULL2 (vector)",
        "templates": {
          "3REG_DIFF": [
            "SMULL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>"
          ]
        }
      },
      "SQABS_advsimd": {
        "authored": "Signed saturating Absolute value. This instruction reads each vector element\nfrom the source SIMD&FP register, puts the absolute value of the result into a\nvector, and writes the vector to the destination SIMD&FP register. All the\nvalues in this instruction are signed integer values.\n\nIf overflow occurs with any of the results, those results are saturated. If\nsaturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SQABS",
        "templates": {
          "SIMD": [
            "SQABS  <Vd>.<T>, <Vn>.<T>"
          ],
          "SISD": [
            "SQABS  <V><d>, <V><n>"
          ]
        }
      },
      "SQADD_advsimd": {
        "authored": "Signed saturating Add. This instruction adds the values of corresponding\nelements of the two source SIMD&FP registers, places the results into a vector,\nand writes the vector to the destination SIMD&FP register.\n\nIf overflow occurs with any of the results, those results are saturated. If\nsaturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SQADD",
        "templates": {
          "SIMD": [
            "SQADD  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ],
          "SISD": [
            "SQADD  <V><d>, <V><n>, <V><m>"
          ]
        }
      },
      "SQDMLAL_advsimd_elt": {
        "authored": "Signed saturating Doubling Multiply-Add Long (by element). This instruction\nmultiplies each vector element in the lower or upper half of the first source\nSIMD&FP register by the specified vector element of the second source SIMD&FP\nregister, doubles the results, and accumulates the final results with the vector\nelements of the destination SIMD&FP register. The destination vector elements\nare twice as long as the elements that are multiplied.\n\nIf overflow occurs with any of the results, those results are saturated. If\nsaturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nThe SQDMLAL instruction extracts vector elements from the lower half of the\nfirst source register, while the SQDMLAL2 instruction extracts vector elements\nfrom the upper half of the first source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SQDMLAL, SQDMLAL2 (by element)",
        "templates": {
          "2REG_ELEMENT": [
            "SQDMLAL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Ts>[<index>]"
          ],
          "2REG_SCALAR": [
            "SQDMLAL  <Va><d>, <Vb><n>, <Vm>.<Ts>[<index>]"
          ]
        }
      },
      "SQDMLAL_advsimd_vec": {
        "authored": "Signed saturating Doubling Multiply-Add Long. This instruction multiplies\ncorresponding signed integer values in the lower or upper half of the vectors of\nthe two source SIMD&FP registers, doubles the results, and accumulates the final\nresults with the vector elements of the destination SIMD&FP register. The\ndestination vector elements are twice as long as the elements that are\nmultiplied.\n\nIf overflow occurs with any of the results, those results are saturated. If\nsaturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nThe SQDMLAL instruction extracts each source vector from the lower half of each\nsource register, while the SQDMLAL2 instruction extracts each source vector from\nthe upper half of each source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SQDMLAL, SQDMLAL2 (vector)",
        "templates": {
          "SIMD": [
            "SQDMLAL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>"
          ],
          "SISD": [
            "SQDMLAL  <Va><d>, <Vb><n>, <Vb><m>"
          ]
        }
      },
      "SQDMLSL_advsimd_elt": {
        "authored": "Signed saturating Doubling Multiply-Subtract Long (by element). This instruction\nmultiplies each vector element in the lower or upper half of the first source\nSIMD&FP register by the specified vector element of the second source SIMD&FP\nregister, doubles the results, and subtracts the final results from the vector\nelements of the destination SIMD&FP register. The destination vector elements\nare twice as long as the elements that are multiplied. All the values in this\ninstruction are signed integer values.\n\nIf overflow occurs with any of the results, those results are saturated. If\nsaturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nThe SQDMLSL instruction extracts vector elements from the lower half of the\nfirst source register, while the SQDMLSL2 instruction extracts vector elements\nfrom the upper half of the first source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SQDMLSL, SQDMLSL2 (by element)",
        "templates": {
          "2REG_ELEMENT": [
            "SQDMLSL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Ts>[<index>]"
          ],
          "2REG_SCALAR": [
            "SQDMLSL  <Va><d>, <Vb><n>, <Vm>.<Ts>[<index>]"
          ]
        }
      },
      "SQDMLSL_advsimd_vec": {
        "authored": "Signed saturating Doubling Multiply-Subtract Long. This instruction multiplies\ncorresponding signed integer values in the lower or upper half of the vectors of\nthe two source SIMD&FP registers, doubles the results, and subtracts the final\nresults from the vector elements of the destination SIMD&FP register. The\ndestination vector elements are twice as long as the elements that are\nmultiplied.\n\nIf overflow occurs with any of the results, those results are saturated. If\nsaturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nThe SQDMLSL instruction extracts each source vector from the lower half of each\nsource register, while the SQDMLSL2 instruction extracts each source vector from\nthe upper half of each source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SQDMLSL, SQDMLSL2 (vector)",
        "templates": {
          "SIMD": [
            "SQDMLSL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>"
          ],
          "SISD": [
            "SQDMLSL  <Va><d>, <Vb><n>, <Vb><m>"
          ]
        }
      },
      "SQDMULH_advsimd_elt": {
        "authored": "Signed saturating Doubling Multiply returning High half (by element). This\ninstruction multiplies each vector element in the first source SIMD&FP register\nby the specified vector element of the second source SIMD&FP register, doubles\nthe results, places the most significant half of the final results into a\nvector, and writes the vector to the destination SIMD&FP register.\n\nThe results are truncated. For rounded results, see SQRDMULH.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SQDMULH (by element)",
        "templates": {
          "2REG_ELEMENT": [
            "SQDMULH  <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]"
          ],
          "2REG_SCALAR": [
            "SQDMULH  <V><d>, <V><n>, <Vm>.<Ts>[<index>]"
          ]
        }
      },
      "SQDMULH_advsimd_vec": {
        "authored": "Signed saturating Doubling Multiply returning High half. This instruction\nmultiplies the values of corresponding elements of the two source SIMD&FP\nregisters, doubles the results, places the most significant half of the final\nresults into a vector, and writes the vector to the destination SIMD&FP\nregister.\n\nThe results are truncated. For rounded results, see SQRDMULH.\n\nIf overflow occurs with any of the results, those results are saturated. If\nsaturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SQDMULH (vector)",
        "templates": {
          "SIMD": [
            "SQDMULH  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ],
          "SISD": [
            "SQDMULH  <V><d>, <V><n>, <V><m>"
          ]
        }
      },
      "SQDMULL_advsimd_elt": {
        "authored": "Signed saturating Doubling Multiply Long (by element). This instruction\nmultiplies each vector element in the lower or upper half of the first source\nSIMD&FP register by the specified vector element of the second source SIMD&FP\nregister, doubles the results, places the final results in a vector, and writes\nthe vector to the destination SIMD&FP register. All the values in this\ninstruction are signed integer values.\n\nIf overflow occurs with any of the results, those results are saturated. If\nsaturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nThe SQDMULL instruction extracts the first source vector from the lower half of\nthe first source register, while the SQDMULL2 instruction extracts the first\nsource vector from the upper half of the first source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SQDMULL, SQDMULL2 (by element)",
        "templates": {
          "2REG_ELEMENT": [
            "SQDMULL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Ts>[<index>]"
          ],
          "2REG_SCALAR": [
            "SQDMULL  <Va><d>, <Vb><n>, <Vm>.<Ts>[<index>]"
          ]
        }
      },
      "SQDMULL_advsimd_vec": {
        "authored": "Signed saturating Doubling Multiply Long. This instruction multiplies\ncorresponding vector elements in the lower or upper half of the two source\nSIMD&FP registers, doubles the results, places the final results in a vector,\nand writes the vector to the destination SIMD&FP register.\n\nIf overflow occurs with any of the results, those results are saturated. If\nsaturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nThe SQDMULL instruction extracts each source vector from the lower half of each\nsource register, while the SQDMULL2 instruction extracts each source vector from\nthe upper half of each source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SQDMULL, SQDMULL2 (vector)",
        "templates": {
          "SIMD": [
            "SQDMULL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>"
          ],
          "SISD": [
            "SQDMULL  <Va><d>, <Vb><n>, <Vb><m>"
          ]
        }
      },
      "SQNEG_advsimd": {
        "authored": "Signed saturating Negate. This instruction reads each vector element from the\nsource SIMD&FP register, negates each value, places the result into a vector,\nand writes the vector to the destination SIMD&FP register. All the values in\nthis instruction are signed integer values.\n\nIf overflow occurs with any of the results, those results are saturated. If\nsaturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SQNEG",
        "templates": {
          "SIMD": [
            "SQNEG  <Vd>.<T>, <Vn>.<T>"
          ],
          "SISD": [
            "SQNEG  <V><d>, <V><n>"
          ]
        }
      },
      "SQRDMLAH_advsimd_elt": {
        "authored": "Signed Saturating Rounding Doubling Multiply Accumulate returning High Half (by\nelement). This instruction multiplies the vector elements of the first source\nSIMD&FP register with the value of a vector element of the second source SIMD&FP\nregister without saturating the multiply results, doubles the results, and\naccumulates the most significant half of the final results with the vector\nelements of the destination SIMD&FP register. The results are rounded.\n\nIf any of the results overflow, they are saturated. The cumulative saturation\nbit, FPSR.QC, is set if saturation occurs.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SQRDMLAH (by element)",
        "templates": {
          "2REG_ELEMENT": [
            "SQRDMLAH  <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]"
          ],
          "2REG_SCALAR": [
            "SQRDMLAH  <V><d>, <V><n>, <Vm>.<Ts>[<index>]"
          ]
        }
      },
      "SQRDMLAH_advsimd_vec": {
        "authored": "Signed Saturating Rounding Doubling Multiply Accumulate returning High Half\n(vector). This instruction multiplies the vector elements of the first source\nSIMD&FP register with the corresponding vector elements of the second source\nSIMD&FP register without saturating the multiply results, doubles the results,\nand accumulates the most significant half of the final results with the vector\nelements of the destination SIMD&FP register. The results are rounded.\n\nIf any of the results overflow, they are saturated. The cumulative saturation\nbit, FPSR.QC, is set if saturation occurs.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SQRDMLAH (vector)",
        "templates": {
          "SIMD": [
            "SQRDMLAH  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ],
          "SISD": [
            "SQRDMLAH  <V><d>, <V><n>, <V><m>"
          ]
        }
      },
      "SQRDMLSH_advsimd_elt": {
        "authored": "Signed Saturating Rounding Doubling Multiply Subtract returning High Half (by\nelement). This instruction multiplies the vector elements of the first source\nSIMD&FP register with the value of a vector element of the second source SIMD&FP\nregister without saturating the multiply results, doubles the results, and\nsubtracts the most significant half of the final results from the vector\nelements of the destination SIMD&FP register. The results are rounded.\n\nIf any of the results overflow, they are saturated. The cumulative saturation\nbit, FPSR.QC, is set if saturation occurs.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SQRDMLSH (by element)",
        "templates": {
          "2REG_ELEMENT": [
            "SQRDMLSH  <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]"
          ],
          "2REG_SCALAR": [
            "SQRDMLSH  <V><d>, <V><n>, <Vm>.<Ts>[<index>]"
          ]
        }
      },
      "SQRDMLSH_advsimd_vec": {
        "authored": "Signed Saturating Rounding Doubling Multiply Subtract returning High Half\n(vector). This instruction multiplies the vector elements of the first source\nSIMD&FP register with the corresponding vector elements of the second source\nSIMD&FP register without saturating the multiply results, doubles the results,\nand subtracts the most significant half of the final results from the vector\nelements of the destination SIMD&FP register. The results are rounded.\n\nIf any of the results overflow, they are saturated. The cumulative saturation\nbit, FPSR.QC, is set if saturation occurs.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SQRDMLSH (vector)",
        "templates": {
          "SIMD": [
            "SQRDMLSH  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ],
          "SISD": [
            "SQRDMLSH  <V><d>, <V><n>, <V><m>"
          ]
        }
      },
      "SQRDMULH_advsimd_elt": {
        "authored": "Signed saturating Rounding Doubling Multiply returning High half (by element).\nThis instruction multiplies each vector element in the first source SIMD&FP\nregister by the specified vector element of the second source SIMD&FP register,\ndoubles the results, places the most significant half of the final results into\na vector, and writes the vector to the destination SIMD&FP register.\n\nThe results are rounded. For truncated results, see SQDMULH.\n\nIf any of the results overflows, they are saturated. If saturation occurs, the\ncumulative saturation bit FPSR.QC is set.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SQRDMULH (by element)",
        "templates": {
          "2REG_ELEMENT": [
            "SQRDMULH  <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]"
          ],
          "2REG_SCALAR": [
            "SQRDMULH  <V><d>, <V><n>, <Vm>.<Ts>[<index>]"
          ]
        }
      },
      "SQRDMULH_advsimd_vec": {
        "authored": "Signed saturating Rounding Doubling Multiply returning High half. This\ninstruction multiplies the values of corresponding elements of the two source\nSIMD&FP registers, doubles the results, places the most significant half of the\nfinal results into a vector, and writes the vector to the destination SIMD&FP\nregister.\n\nThe results are rounded. For truncated results, see SQDMULH.\n\nIf overflow occurs with any of the results, those results are saturated. If\nsaturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SQRDMULH (vector)",
        "templates": {
          "SIMD": [
            "SQRDMULH  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ],
          "SISD": [
            "SQRDMULH  <V><d>, <V><n>, <V><m>"
          ]
        }
      },
      "SQRSHL_advsimd": {
        "authored": "Signed saturating Rounding Shift Left (register). This instruction takes each\nvector element in the first source SIMD&FP register, shifts it by a value from\nthe least significant byte of the corresponding vector element of the second\nsource SIMD&FP register, places the results into a vector, and writes the vector\nto the destination SIMD&FP register.\n\nIf the shift value is positive, the operation is a left shift. Otherwise, it is\na right shift. The results are rounded. For truncated results, see SQSHL.\n\nIf overflow occurs with any of the results, those results are saturated. If\nsaturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SQRSHL",
        "templates": {
          "SIMD": [
            "SQRSHL  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ],
          "SISD": [
            "SQRSHL  <V><d>, <V><n>, <V><m>"
          ]
        }
      },
      "SQRSHRN_advsimd": {
        "authored": "Signed saturating Rounded Shift Right Narrow (immediate). This instruction reads\neach vector element in the source SIMD&FP register, right shifts each result by\nan immediate value, saturates each shifted result to a value that is half the\noriginal width, puts the final result into a vector, and writes the vector to\nthe lower or upper half of the destination SIMD&FP register. All the values in\nthis instruction are signed integer values. The destination vector elements are\nhalf as long as the source vector elements. The results are rounded. For\ntruncated results, see SQSHRN.\n\nThe SQRSHRN instruction writes the vector to the lower half of the destination\nregister and clears the upper half, while the SQRSHRN2 instruction writes the\nvector to the upper half of the destination register without affecting the other\nbits of the register.\n\nIf saturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SQRSHRN, SQRSHRN2",
        "templates": {
          "SIMD": [
            "SQRSHRN{2}  <Vd>.<Tb>, <Vn>.<Ta>, #<shift>"
          ],
          "SISD": [
            "SQRSHRN  <Vb><d>, <Va><n>, #<shift>"
          ]
        }
      },
      "SQRSHRUN_advsimd": {
        "authored": "Signed saturating Rounded Shift Right Unsigned Narrow (immediate). This\ninstruction reads each signed integer value in the vector of the source SIMD&FP\nregister, right shifts each value by an immediate value, saturates the result to\nan unsigned integer value that is half the original width, places the final\nresult into a vector, and writes the vector to the destination SIMD&FP register.\nThe results are rounded. For truncated results, see SQSHRUN.\n\nThe SQRSHRUN instruction writes the vector to the lower half of the destination\nregister and clears the upper half, while the SQRSHRUN2 instruction writes the\nvector to the upper half of the destination register without affecting the other\nbits of the register.\n\nIf saturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SQRSHRUN, SQRSHRUN2",
        "templates": {
          "SIMD": [
            "SQRSHRUN{2}  <Vd>.<Tb>, <Vn>.<Ta>, #<shift>"
          ],
          "SISD": [
            "SQRSHRUN  <Vb><d>, <Va><n>, #<shift>"
          ]
        }
      },
      "SQSHLU_advsimd": {
        "authored": "Signed saturating Shift Left Unsigned (immediate). This instruction reads each\nsigned integer value in the vector of the source SIMD&FP register, shifts each\nvalue by an immediate value, saturates the shifted result to an unsigned integer\nvalue, places the result in a vector, and writes the vector to the destination\nSIMD&FP register. The results are truncated. For rounded results, see UQRSHL.\n\nIf saturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SQSHLU",
        "templates": {
          "SIMD": [
            "SQSHLU  <Vd>.<T>, <Vn>.<T>, #<shift>"
          ],
          "SISD": [
            "SQSHLU  <V><d>, <V><n>, #<shift>"
          ]
        }
      },
      "SQSHL_advsimd_imm": {
        "authored": "Signed saturating Shift Left (immediate). This instruction reads each vector\nelement in the source SIMD&FP register, shifts each result by an immediate\nvalue, places the final result in a vector, and writes the vector to the\ndestination SIMD&FP register. The results are truncated. For rounded results,\nsee UQRSHL.\n\nIf overflow occurs with any of the results, those results are saturated. If\nsaturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SQSHL (immediate)",
        "templates": {
          "SIMD": [
            "SQSHL  <Vd>.<T>, <Vn>.<T>, #<shift>"
          ],
          "SISD": [
            "SQSHL  <V><d>, <V><n>, #<shift>"
          ]
        }
      },
      "SQSHL_advsimd_reg": {
        "authored": "Signed saturating Shift Left (register). This instruction takes each element in\nthe vector of the first source SIMD&FP register, shifts each element by a value\nfrom the least significant byte of the corresponding element of the second\nsource SIMD&FP register, places the results in a vector, and writes the vector\nto the destination SIMD&FP register.\n\nIf the shift value is positive, the operation is a left shift. Otherwise, it is\na right shift. The results are truncated. For rounded results, see SQRSHL.\n\nIf overflow occurs with any of the results, those results are saturated. If\nsaturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SQSHL (register)",
        "templates": {
          "SIMD": [
            "SQSHL  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ],
          "SISD": [
            "SQSHL  <V><d>, <V><n>, <V><m>"
          ]
        }
      },
      "SQSHRN_advsimd": {
        "authored": "Signed saturating Shift Right Narrow (immediate). This instruction reads each\nvector element in the source SIMD&FP register, right shifts and truncates each\nresult by an immediate value, saturates each shifted result to a value that is\nhalf the original width, puts the final result into a vector, and writes the\nvector to the lower or upper half of the destination SIMD&FP register. All the\nvalues in this instruction are signed integer values. The destination vector\nelements are half as long as the source vector elements. For rounded results,\nsee SQRSHRN.\n\nThe SQSHRN instruction writes the vector to the lower half of the destination\nregister and clears the upper half, while the SQSHRN2 instruction writes the\nvector to the upper half of the destination register without affecting the other\nbits of the register.\n\nIf saturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SQSHRN, SQSHRN2",
        "templates": {
          "SIMD": [
            "SQSHRN{2}  <Vd>.<Tb>, <Vn>.<Ta>, #<shift>"
          ],
          "SISD": [
            "SQSHRN  <Vb><d>, <Va><n>, #<shift>"
          ]
        }
      },
      "SQSHRUN_advsimd": {
        "authored": "Signed saturating Shift Right Unsigned Narrow (immediate). This instruction\nreads each signed integer value in the vector of the source SIMD&FP register,\nright shifts each value by an immediate value, saturates the result to an\nunsigned integer value that is half the original width, places the final result\ninto a vector, and writes the vector to the destination SIMD&FP register. The\nresults are truncated. For rounded results, see SQRSHRUN.\n\nThe SQSHRUN instruction writes the vector to the lower half of the destination\nregister and clears the upper half, while the SQSHRUN2 instruction writes the\nvector to the upper half of the destination register without affecting the other\nbits of the register.\n\nIf saturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SQSHRUN, SQSHRUN2",
        "templates": {
          "SIMD": [
            "SQSHRUN{2}  <Vd>.<Tb>, <Vn>.<Ta>, #<shift>"
          ],
          "SISD": [
            "SQSHRUN  <Vb><d>, <Va><n>, #<shift>"
          ]
        }
      },
      "SQSUB_advsimd": {
        "authored": "Signed saturating Subtract. This instruction subtracts the element values of the\nsecond source SIMD&FP register from the corresponding element values of the\nfirst source SIMD&FP register, places the results into a vector, and writes the\nvector to the destination SIMD&FP register.\n\nIf overflow occurs with any of the results, those results are saturated. If\nsaturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SQSUB",
        "templates": {
          "SIMD": [
            "SQSUB  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ],
          "SISD": [
            "SQSUB  <V><d>, <V><n>, <V><m>"
          ]
        }
      },
      "SQXTN_advsimd": {
        "authored": "Signed saturating extract Narrow. This instruction reads each vector element\nfrom the source SIMD&FP register, saturates the value to half the original\nwidth, places the result into a vector, and writes the vector to the lower or\nupper half of the destination SIMD&FP register. The destination vector elements\nare half as long as the source vector elements. All the values in this\ninstruction are signed integer values.\n\nIf overflow occurs with any of the results, those results are saturated. If\nsaturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nThe SQXTN instruction writes the vector to the lower half of the destination\nregister and clears the upper half, while the SQXTN2 instruction writes the\nvector to the upper half of the destination register without affecting the other\nbits of the register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SQXTN, SQXTN2",
        "templates": {
          "SIMD": [
            "SQXTN{2}  <Vd>.<Tb>, <Vn>.<Ta>"
          ],
          "SISD": [
            "SQXTN  <Vb><d>, <Va><n>"
          ]
        }
      },
      "SQXTUN_advsimd": {
        "authored": "Signed saturating extract Unsigned Narrow. This instruction reads each signed\ninteger value in the vector of the source SIMD&FP register, saturates the value\nto an unsigned integer value that is half the original width, places the result\ninto a vector, and writes the vector to the lower or upper half of the\ndestination SIMD&FP register. The destination vector elements are half as long\nas the source vector elements.\n\nIf saturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nThe SQXTUN instruction writes the vector to the lower half of the destination\nregister and clears the upper half, while the SQXTUN2 instruction writes the\nvector to the upper half of the destination register without affecting the other\nbits of the register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SQXTUN, SQXTUN2",
        "templates": {
          "SIMD": [
            "SQXTUN{2}  <Vd>.<Tb>, <Vn>.<Ta>"
          ],
          "SISD": [
            "SQXTUN  <Vb><d>, <Va><n>"
          ]
        }
      },
      "SRHADD_advsimd": {
        "authored": "Signed Rounding Halving Add. This instruction adds corresponding signed integer\nvalues from the two source SIMD&FP registers, shifts each result right one bit,\nplaces the results into a vector, and writes the vector to the destination\nSIMD&FP register.\n\nThe results are rounded. For truncated results, see SHADD.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SRHADD",
        "templates": {
          "3REG_SAME": [
            "SRHADD  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ]
        }
      },
      "SRI_advsimd": {
        "authored": "Shift Right and Insert (immediate). This instruction reads each vector element\nin the source SIMD&FP register, right shifts each vector element by an immediate\nvalue, and inserts the result into the corresponding vector element in the\ndestination SIMD&FP register such that the new zero bits created by the shift\nare not inserted but retain their existing value. Bits shifted out of the right\nof each vector element of the source register are lost.\n\n\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SRI",
        "templates": {
          "SIMD": [
            "SRI  <Vd>.<T>, <Vn>.<T>, #<shift>"
          ],
          "SISD": [
            "SRI  <V><d>, <V><n>, #<shift>"
          ]
        }
      },
      "SRSHL_advsimd": {
        "authored": "Signed Rounding Shift Left (register). This instruction takes each signed\ninteger value in the vector of the first source SIMD&FP register, shifts it by a\nvalue from the least significant byte of the corresponding element of the second\nsource SIMD&FP register, places the results in a vector, and writes the vector\nto the destination SIMD&FP register.\n\nIf the shift value is positive, the operation is a left shift. If the shift\nvalue is negative, it is a rounding right shift. For a truncating shift, see\nSSHL.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SRSHL",
        "templates": {
          "SIMD": [
            "SRSHL  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ],
          "SISD": [
            "SRSHL  <V><d>, <V><n>, <V><m>"
          ]
        }
      },
      "SRSHR_advsimd": {
        "authored": "Signed Rounding Shift Right (immediate). This instruction reads each vector\nelement in the source SIMD&FP register, right shifts each result by an immediate\nvalue, places the final result into a vector, and writes the vector to the\ndestination SIMD&FP register. All the values in this instruction are signed\ninteger values. The results are rounded. For truncated results, see SSHR.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SRSHR",
        "templates": {
          "SIMD": [
            "SRSHR  <Vd>.<T>, <Vn>.<T>, #<shift>"
          ],
          "SISD": [
            "SRSHR  <V><d>, <V><n>, #<shift>"
          ]
        }
      },
      "SRSRA_advsimd": {
        "authored": "Signed Rounding Shift Right and Accumulate (immediate). This instruction reads\neach vector element in the source SIMD&FP register, right shifts each result by\nan immediate value, and accumulates the final results with the vector elements\nof the destination SIMD&FP register. All the values in this instruction are\nsigned integer values. The results are rounded. For truncated results, see SSRA.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SRSRA",
        "templates": {
          "SIMD": [
            "SRSRA  <Vd>.<T>, <Vn>.<T>, #<shift>"
          ],
          "SISD": [
            "SRSRA  <V><d>, <V><n>, #<shift>"
          ]
        }
      },
      "SSHLL_advsimd": {
        "authored": "Signed Shift Left Long (immediate). This instruction reads each vector element\nfrom the source SIMD&FP register, left shifts each vector element by the\nspecified shift amount, places the result into a vector, and writes the vector\nto the destination SIMD&FP register. The destination vector elements are twice\nas long as the source vector elements. All the values in this instruction are\nsigned integer values.\n\nThe SSHLL instruction extracts vector elements from the lower half of the source\nregister, while the SSHLL2 instruction extracts vector elements from the upper\nhalf of the source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SSHLL, SSHLL2",
        "templates": {
          "SIMD": [
            "SSHLL{2}  <Vd>.<Ta>, <Vn>.<Tb>, #<shift>"
          ]
        }
      },
      "SSHL_advsimd": {
        "authored": "Signed Shift Left (register). This instruction takes each signed integer value\nin the vector of the first source SIMD&FP register, shifts each value by a value\nfrom the least significant byte of the corresponding element of the second\nsource SIMD&FP register, places the results in a vector, and writes the vector\nto the destination SIMD&FP register.\n\nIf the shift value is positive, the operation is a left shift. If the shift\nvalue is negative, it is a truncating right shift. For a rounding shift, see\nSRSHL.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SSHL",
        "templates": {
          "SIMD": [
            "SSHL  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ],
          "SISD": [
            "SSHL  <V><d>, <V><n>, <V><m>"
          ]
        }
      },
      "SSHR_advsimd": {
        "authored": "Signed Shift Right (immediate). This instruction reads each vector element in\nthe source SIMD&FP register, right shifts each result by an immediate value,\nplaces the final result into a vector, and writes the vector to the destination\nSIMD&FP register. All the values in this instruction are signed integer values.\nThe results are truncated. For rounded results, see SRSHR.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SSHR",
        "templates": {
          "SIMD": [
            "SSHR  <Vd>.<T>, <Vn>.<T>, #<shift>"
          ],
          "SISD": [
            "SSHR  <V><d>, <V><n>, #<shift>"
          ]
        }
      },
      "SSRA_advsimd": {
        "authored": "Signed Shift Right and Accumulate (immediate). This instruction reads each\nvector element in the source SIMD&FP register, right shifts each result by an\nimmediate value, and accumulates the final results with the vector elements of\nthe destination SIMD&FP register. All the values in this instruction are signed\ninteger values. The results are truncated. For rounded results, see SRSRA.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SSRA",
        "templates": {
          "SIMD": [
            "SSRA  <Vd>.<T>, <Vn>.<T>, #<shift>"
          ],
          "SISD": [
            "SSRA  <V><d>, <V><n>, #<shift>"
          ]
        }
      },
      "SSUBL_advsimd": {
        "authored": "Signed Subtract Long. This instruction subtracts each vector element in the\nlower or upper half of the second source SIMD&FP register from the corresponding\nvector element of the first source SIMD&FP register, places the results into a\nvector, and writes the vector to the destination SIMD&FP register. All the\nvalues in this instruction are signed integer values. The destination vector\nelements are twice as long as the source vector elements.\n\nThe SSUBL instruction extracts each source vector from the lower half of each\nsource register, while the SSUBL2 instruction extracts each source vector from\nthe upper half of each source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SSUBL, SSUBL2",
        "templates": {
          "3REG_DIFF": [
            "SSUBL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>"
          ]
        }
      },
      "SSUBW_advsimd": {
        "authored": "Signed Subtract Wide. This instruction subtracts each vector element in the\nlower or upper half of the second source SIMD&FP register from the corresponding\nvector element in the first source SIMD&FP register, places the result in a\nvector, and writes the vector to the SIMD&FP destination register. All the\nvalues in this instruction are signed integer values.\n\nThe SSUBW instruction extracts the second source vector from the lower half of\nthe second source register, while the SSUBW2 instruction extracts the second\nsource vector from the upper half of the second source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SSUBW, SSUBW2",
        "templates": {
          "3REG_DIFF": [
            "SSUBW{2}  <Vd>.<Ta>, <Vn>.<Ta>, <Vm>.<Tb>"
          ]
        }
      },
      "ST1_advsimd_mult": {
        "authored": "Store multiple single-element structures from one, two, three, or four\nregisters. This instruction stores elements to memory from one, two, three, or\nfour SIMD&FP registers, without interleaving. Every element of each register is\nstored.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "ST1 (multiple structures)",
        "templates": {
          "AS_NO_POST_INDEX": [
            "ST1  { <Vt>.<T> }, [<Xn|SP>]",
            "ST1  { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>]",
            "ST1  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>]",
            "ST1  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>]"
          ],
          "AS_POST_INDEX": [
            "ST1  { <Vt>.<T> }, [<Xn|SP>], <imm>",
            "ST1  { <Vt>.<T> }, [<Xn|SP>], <Xm>",
            "ST1  { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>], <imm>",
            "ST1  { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>], <Xm>",
            "ST1  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>], <imm>",
            "ST1  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>], <Xm>",
            "ST1  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>], <imm>",
            "ST1  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>], <Xm>"
          ]
        }
      },
      "ST1_advsimd_sngl": {
        "authored": "Store a single-element structure from one lane of one register. This instruction\nstores the specified element of a SIMD&FP register to memory.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "ST1 (single structure)",
        "templates": {
          "AS_NO_POST_INDEX": [
            "ST1  { <Vt>.B }[<index>], [<Xn|SP>]",
            "ST1  { <Vt>.H }[<index>], [<Xn|SP>]",
            "ST1  { <Vt>.S }[<index>], [<Xn|SP>]",
            "ST1  { <Vt>.D }[<index>], [<Xn|SP>]"
          ],
          "AS_POST_INDEX": [
            "ST1  { <Vt>.B }[<index>], [<Xn|SP>], #1",
            "ST1  { <Vt>.B }[<index>], [<Xn|SP>], <Xm>",
            "ST1  { <Vt>.H }[<index>], [<Xn|SP>], #2",
            "ST1  { <Vt>.H }[<index>], [<Xn|SP>], <Xm>",
            "ST1  { <Vt>.S }[<index>], [<Xn|SP>], #4",
            "ST1  { <Vt>.S }[<index>], [<Xn|SP>], <Xm>",
            "ST1  { <Vt>.D }[<index>], [<Xn|SP>], #8",
            "ST1  { <Vt>.D }[<index>], [<Xn|SP>], <Xm>"
          ]
        }
      },
      "ST2_advsimd_mult": {
        "authored": "Store multiple 2-element structures from two registers. This instruction stores\nmultiple 2-element structures from two SIMD&FP registers to memory, with\ninterleaving. Every element of each register is stored.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "ST2 (multiple structures)",
        "templates": {
          "AS_NO_POST_INDEX": [
            "ST2  { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>]"
          ],
          "AS_POST_INDEX": [
            "ST2  { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>], <imm>",
            "ST2  { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>], <Xm>"
          ]
        }
      },
      "ST2_advsimd_sngl": {
        "authored": "Store single 2-element structure from one lane of two registers. This\ninstruction stores a 2-element structure to memory from corresponding elements\nof two SIMD&FP registers.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "ST2 (single structure)",
        "templates": {
          "AS_NO_POST_INDEX": [
            "ST2  { <Vt>.B, <Vt2>.B }[<index>], [<Xn|SP>]",
            "ST2  { <Vt>.H, <Vt2>.H }[<index>], [<Xn|SP>]",
            "ST2  { <Vt>.S, <Vt2>.S }[<index>], [<Xn|SP>]",
            "ST2  { <Vt>.D, <Vt2>.D }[<index>], [<Xn|SP>]"
          ],
          "AS_POST_INDEX": [
            "ST2  { <Vt>.B, <Vt2>.B }[<index>], [<Xn|SP>], #2",
            "ST2  { <Vt>.B, <Vt2>.B }[<index>], [<Xn|SP>], <Xm>",
            "ST2  { <Vt>.H, <Vt2>.H }[<index>], [<Xn|SP>], #4",
            "ST2  { <Vt>.H, <Vt2>.H }[<index>], [<Xn|SP>], <Xm>",
            "ST2  { <Vt>.S, <Vt2>.S }[<index>], [<Xn|SP>], #8",
            "ST2  { <Vt>.S, <Vt2>.S }[<index>], [<Xn|SP>], <Xm>",
            "ST2  { <Vt>.D, <Vt2>.D }[<index>], [<Xn|SP>], #16",
            "ST2  { <Vt>.D, <Vt2>.D }[<index>], [<Xn|SP>], <Xm>"
          ]
        }
      },
      "ST3_advsimd_mult": {
        "authored": "Store multiple 3-element structures from three registers. This instruction\nstores multiple 3-element structures to memory from three SIMD&FP registers,\nwith interleaving. Every element of each register is stored.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "ST3 (multiple structures)",
        "templates": {
          "AS_NO_POST_INDEX": [
            "ST3  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>]"
          ],
          "AS_POST_INDEX": [
            "ST3  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>], <imm>",
            "ST3  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>], <Xm>"
          ]
        }
      },
      "ST3_advsimd_sngl": {
        "authored": "Store single 3-element structure from one lane of three registers. This\ninstruction stores a 3-element structure to memory from corresponding elements\nof three SIMD&FP registers.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "ST3 (single structure)",
        "templates": {
          "AS_NO_POST_INDEX": [
            "ST3  { <Vt>.B, <Vt2>.B, <Vt3>.B }[<index>], [<Xn|SP>]",
            "ST3  { <Vt>.H, <Vt2>.H, <Vt3>.H }[<index>], [<Xn|SP>]",
            "ST3  { <Vt>.S, <Vt2>.S, <Vt3>.S }[<index>], [<Xn|SP>]",
            "ST3  { <Vt>.D, <Vt2>.D, <Vt3>.D }[<index>], [<Xn|SP>]"
          ],
          "AS_POST_INDEX": [
            "ST3  { <Vt>.B, <Vt2>.B, <Vt3>.B }[<index>], [<Xn|SP>], #3",
            "ST3  { <Vt>.B, <Vt2>.B, <Vt3>.B }[<index>], [<Xn|SP>], <Xm>",
            "ST3  { <Vt>.H, <Vt2>.H, <Vt3>.H }[<index>], [<Xn|SP>], #6",
            "ST3  { <Vt>.H, <Vt2>.H, <Vt3>.H }[<index>], [<Xn|SP>], <Xm>",
            "ST3  { <Vt>.S, <Vt2>.S, <Vt3>.S }[<index>], [<Xn|SP>], #12",
            "ST3  { <Vt>.S, <Vt2>.S, <Vt3>.S }[<index>], [<Xn|SP>], <Xm>",
            "ST3  { <Vt>.D, <Vt2>.D, <Vt3>.D }[<index>], [<Xn|SP>], #24",
            "ST3  { <Vt>.D, <Vt2>.D, <Vt3>.D }[<index>], [<Xn|SP>], <Xm>"
          ]
        }
      },
      "ST4_advsimd_mult": {
        "authored": "Store multiple 4-element structures from four registers. This instruction stores\nmultiple 4-element structures to memory from four SIMD&FP registers, with\ninterleaving. Every element of each register is stored.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "ST4 (multiple structures)",
        "templates": {
          "AS_NO_POST_INDEX": [
            "ST4  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>]"
          ],
          "AS_POST_INDEX": [
            "ST4  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>], <imm>",
            "ST4  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>], <Xm>"
          ]
        }
      },
      "ST4_advsimd_sngl": {
        "authored": "Store single 4-element structure from one lane of four registers. This\ninstruction stores a 4-element structure to memory from corresponding elements\nof four SIMD&FP registers.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "ST4 (single structure)",
        "templates": {
          "AS_NO_POST_INDEX": [
            "ST4  { <Vt>.B, <Vt2>.B, <Vt3>.B, <Vt4>.B }[<index>], [<Xn|SP>]",
            "ST4  { <Vt>.H, <Vt2>.H, <Vt3>.H, <Vt4>.H }[<index>], [<Xn|SP>]",
            "ST4  { <Vt>.S, <Vt2>.S, <Vt3>.S, <Vt4>.S }[<index>], [<Xn|SP>]",
            "ST4  { <Vt>.D, <Vt2>.D, <Vt3>.D, <Vt4>.D }[<index>], [<Xn|SP>]"
          ],
          "AS_POST_INDEX": [
            "ST4  { <Vt>.B, <Vt2>.B, <Vt3>.B, <Vt4>.B }[<index>], [<Xn|SP>], #4",
            "ST4  { <Vt>.B, <Vt2>.B, <Vt3>.B, <Vt4>.B }[<index>], [<Xn|SP>], <Xm>",
            "ST4  { <Vt>.H, <Vt2>.H, <Vt3>.H, <Vt4>.H }[<index>], [<Xn|SP>], #8",
            "ST4  { <Vt>.H, <Vt2>.H, <Vt3>.H, <Vt4>.H }[<index>], [<Xn|SP>], <Xm>",
            "ST4  { <Vt>.S, <Vt2>.S, <Vt3>.S, <Vt4>.S }[<index>], [<Xn|SP>], #16",
            "ST4  { <Vt>.S, <Vt2>.S, <Vt3>.S, <Vt4>.S }[<index>], [<Xn|SP>], <Xm>",
            "ST4  { <Vt>.D, <Vt2>.D, <Vt3>.D, <Vt4>.D }[<index>], [<Xn|SP>], #32",
            "ST4  { <Vt>.D, <Vt2>.D, <Vt3>.D, <Vt4>.D }[<index>], [<Xn|SP>], <Xm>"
          ]
        }
      },
      "STNP_fpsimd": {
        "authored": "Store Pair of SIMD&FP registers, with Non-temporal hint. This instruction stores\na pair of SIMD&FP registers to memory, issuing a hint to the memory system that\nthe access is non-temporal. The address used for the store is calculated from an\naddress from a base register value and an immediate offset. For information\nabout non-temporal pair instructions, see Load/Store SIMD and Floating-point\nNon-temporal pair.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "STNP (SIMD&FP)",
        "templates": {
          "SIGNED_SCALED_OFFSET": [
            "STNP  <St1>, <St2>, [<Xn|SP>{, #<imm>}]",
            "STNP  <Dt1>, <Dt2>, [<Xn|SP>{, #<imm>}]",
            "STNP  <Qt1>, <Qt2>, [<Xn|SP>{, #<imm>}]"
          ]
        }
      },
      "STP_fpsimd": {
        "authored": "Store Pair of SIMD&FP registers. This instruction stores a pair of SIMD&FP\nregisters to memory. The address used for the store is calculated from a base\nregister value and an immediate offset.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "STP (SIMD&FP)",
        "templates": {
          "POST_INDEXED": [
            "STP  <St1>, <St2>, [<Xn|SP>], #<imm>",
            "STP  <Dt1>, <Dt2>, [<Xn|SP>], #<imm>",
            "STP  <Qt1>, <Qt2>, [<Xn|SP>], #<imm>"
          ],
          "PRE_INDEXED": [
            "STP  <St1>, <St2>, [<Xn|SP>, #<imm>]!",
            "STP  <Dt1>, <Dt2>, [<Xn|SP>, #<imm>]!",
            "STP  <Qt1>, <Qt2>, [<Xn|SP>, #<imm>]!"
          ],
          "SIGNED_SCALED_OFFSET": [
            "STP  <St1>, <St2>, [<Xn|SP>{, #<imm>}]",
            "STP  <Dt1>, <Dt2>, [<Xn|SP>{, #<imm>}]",
            "STP  <Qt1>, <Qt2>, [<Xn|SP>{, #<imm>}]"
          ]
        }
      },
      "STR_imm_fpsimd": {
        "authored": "Store SIMD&FP register (immediate offset). This instruction stores a single\nSIMD&FP register to memory. The address that is used for the store is calculated\nfrom a base register value and an immediate offset.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "STR (immediate, SIMD&FP)",
        "templates": {
          "POST_INDEXED": [
            "STR  <Bt>, [<Xn|SP>], #<simm>",
            "STR  <Ht>, [<Xn|SP>], #<simm>",
            "STR  <St>, [<Xn|SP>], #<simm>",
            "STR  <Dt>, [<Xn|SP>], #<simm>",
            "STR  <Qt>, [<Xn|SP>], #<simm>"
          ],
          "PRE_INDEXED": [
            "STR  <Bt>, [<Xn|SP>, #<simm>]!",
            "STR  <Ht>, [<Xn|SP>, #<simm>]!",
            "STR  <St>, [<Xn|SP>, #<simm>]!",
            "STR  <Dt>, [<Xn|SP>, #<simm>]!",
            "STR  <Qt>, [<Xn|SP>, #<simm>]!"
          ],
          "UNSIGNED_SCALED_OFFSET": [
            "STR  <Bt>, [<Xn|SP>{, #<pimm>}]",
            "STR  <Ht>, [<Xn|SP>{, #<pimm>}]",
            "STR  <St>, [<Xn|SP>{, #<pimm>}]",
            "STR  <Dt>, [<Xn|SP>{, #<pimm>}]",
            "STR  <Qt>, [<Xn|SP>{, #<pimm>}]"
          ]
        }
      },
      "STR_reg_fpsimd": {
        "authored": "Store SIMD&FP register (register offset). This instruction stores a single\nSIMD&FP register to memory. The address that is used for the store is calculated\nfrom a base register value and an offset register value. The offset can be\noptionally shifted and extended.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "STR (register, SIMD&FP)",
        "templates": {
          "FPSIMD": [
            "STR  <Bt>, [<Xn|SP>, (<Wm>|<Xm>), <extend> {<amount>}]",
            "STR  <Bt>, [<Xn|SP>, <Xm>{, LSL <amount>}]",
            "STR  <Ht>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]",
            "STR  <St>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]",
            "STR  <Dt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]",
            "STR  <Qt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]"
          ]
        }
      },
      "STUR_fpsimd": {
        "authored": "Store SIMD&FP register (unscaled offset). This instruction stores a single\nSIMD&FP register to memory. The address that is used for the store is calculated\nfrom a base register value and an optional immediate offset.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "STUR (SIMD&FP)",
        "templates": {
          "BASE_PLUS_OFFSET": [
            "STUR  <Bt>, [<Xn|SP>{, #<simm>}]",
            "STUR  <Ht>, [<Xn|SP>{, #<simm>}]",
            "STUR  <St>, [<Xn|SP>{, #<simm>}]",
            "STUR  <Dt>, [<Xn|SP>{, #<simm>}]",
            "STUR  <Qt>, [<Xn|SP>{, #<simm>}]"
          ]
        }
      },
      "SUBHN_advsimd": {
        "authored": "Subtract returning High Narrow. This instruction subtracts each vector element\nin the second source SIMD&FP register from the corresponding vector element in\nthe first source SIMD&FP register, places the most significant half of the\nresult into a vector, and writes the vector to the lower or upper half of the\ndestination SIMD&FP register. All the values in this instruction are signed\ninteger values.\n\nThe results are truncated. For rounded results, see RSUBHN.\n\nThe SUBHN instruction writes the vector to the lower half of the destination\nregister and clears the upper half, while the SUBHN2 instruction writes the\nvector to the upper half of the destination register without affecting the other\nbits of the register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SUBHN, SUBHN2",
        "templates": {
          "3REG_DIFF": [
            "SUBHN{2}  <Vd>.<Tb>, <Vn>.<Ta>, <Vm>.<Ta>"
          ]
        }
      },
      "SUB_advsimd": {
        "authored": "Subtract (vector). This instruction subtracts each vector element in the second\nsource SIMD&FP register from the corresponding vector element in the first\nsource SIMD&FP register, places the result into a vector, and writes the vector\nto the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SUB (vector)",
        "templates": {
          "SIMD": [
            "SUB  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ],
          "SISD": [
            "SUB  <V><d>, <V><n>, <V><m>"
          ]
        }
      },
      "SUDOT_advsimd_elt": {
        "authored": "Dot product index form with signed and unsigned integers. This instruction\nperforms the dot product of the four signed 8-bit integer values in each 32-bit\nelement of the first source register with the four unsigned 8-bit integer values\nin an indexed 32-bit element of the second source register, accumulating the\nresult into the corresponding 32-bit element of the destination vector.\n\nFrom Armv8.2 to Armv8.5, this is an optional instruction. From Armv8.6 it is\nmandatory for implementations that include Advanced SIMD to support it.\nID_AA64ISAR1_EL1.I8MM indicates whether this instruction is supported.",
        "heading": "SUDOT (by element)",
        "templates": {
          "2REG_ELEMENT": [
            "SUDOT  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.4B[<index>]"
          ]
        }
      },
      "SUQADD_advsimd": {
        "authored": "Signed saturating Accumulate of Unsigned value. This instruction adds the\nunsigned integer values of the vector elements in the source SIMD&FP register to\ncorresponding signed integer values of the vector elements in the destination\nSIMD&FP register, and writes the resulting signed integer values to the\ndestination SIMD&FP register.\n\nIf overflow occurs with any of the results, those results are saturated. If\nsaturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SUQADD",
        "templates": {
          "SIMD": [
            "SUQADD  <Vd>.<T>, <Vn>.<T>"
          ],
          "SISD": [
            "SUQADD  <V><d>, <V><n>"
          ]
        }
      },
      "SXTL_SSHLL_advsimd": {
        "authored": "Signed extend Long. This instruction duplicates each vector element in the lower\nor upper half of the source SIMD&FP register into a vector, and writes the\nvector to the destination SIMD&FP register. The destination vector elements are\ntwice as long as the source vector elements. All the values in this instruction\nare signed integer values.\n\nThe SXTL instruction extracts the source vector from the lower half of the\nsource register, while the SXTL2 instruction extracts the source vector from the\nupper half of the source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SXTL, SXTL2",
        "templates": {
          "SIMD": [
            "SXTL{2}  <Vd>.<Ta>, <Vn>.<Tb>"
          ]
        }
      },
      "TBL_advsimd": {
        "authored": "Table vector Lookup. This instruction reads each value from the vector elements\nin the index source SIMD&FP register, uses each result as an index to perform a\nlookup in a table of bytes that is described by one to four source table SIMD&FP\nregisters, places the lookup result in a vector, and writes the vector to the\ndestination SIMD&FP register. If an index is out of range for the table, the\nresult for that lookup is 0. If more than one source register is used to\ndescribe the table, the first source register describes the lowest bytes of the\ntable.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "TBL",
        "templates": {
          "ADVSIMD": [
            "TBL  <Vd>.<Ta>, { <Vn>.16B, <Vn+1>.16B }, <Vm>.<Ta>",
            "TBL  <Vd>.<Ta>, { <Vn>.16B, <Vn+1>.16B, <Vn+2>.16B }, <Vm>.<Ta>",
            "TBL  <Vd>.<Ta>, { <Vn>.16B, <Vn+1>.16B, <Vn+2>.16B, <Vn+3>.16B }, <Vm>.<Ta>",
            "TBL  <Vd>.<Ta>, { <Vn>.16B }, <Vm>.<Ta>"
          ]
        }
      },
      "TBX_advsimd": {
        "authored": "Table vector lookup extension. This instruction reads each value from the vector\nelements in the index source SIMD&FP register, uses each result as an index to\nperform a lookup in a table of bytes that is described by one to four source\ntable SIMD&FP registers, places the lookup result in a vector, and writes the\nvector to the destination SIMD&FP register. If an index is out of range for the\ntable, the existing value in the vector element of the destination register is\nleft unchanged. If more than one source register is used to describe the table,\nthe first source register describes the lowest bytes of the table.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "TBX",
        "templates": {
          "ADVSIMD": [
            "TBX  <Vd>.<Ta>, { <Vn>.16B, <Vn+1>.16B }, <Vm>.<Ta>",
            "TBX  <Vd>.<Ta>, { <Vn>.16B, <Vn+1>.16B, <Vn+2>.16B }, <Vm>.<Ta>",
            "TBX  <Vd>.<Ta>, { <Vn>.16B, <Vn+1>.16B, <Vn+2>.16B, <Vn+3>.16B }, <Vm>.<Ta>",
            "TBX  <Vd>.<Ta>, { <Vn>.16B }, <Vm>.<Ta>"
          ]
        }
      },
      "TRN1_advsimd": {
        "authored": "Transpose vectors (primary). This instruction reads corresponding even-numbered\nvector elements from the two source SIMD&FP registers, starting at zero, places\neach result into consecutive elements of a vector, and writes the vector to the\ndestination SIMD&FP register. Vector elements from the first source register are\nplaced into even-numbered elements of the destination vector, starting at zero,\nwhile vector elements from the second source register are placed into odd-\nnumbered elements of the destination vector.\n\nBy using this instruction with TRN2, a 2 x 2 matrix can be transposed.\n\n\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "TRN1",
        "templates": {
          "ADVSIMD": [
            "TRN1  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ]
        }
      },
      "TRN2_advsimd": {
        "authored": "Transpose vectors (secondary). This instruction reads corresponding odd-numbered\nvector elements from the two source SIMD&FP registers, places each result into\nconsecutive elements of a vector, and writes the vector to the destination\nSIMD&FP register. Vector elements from the first source register are placed into\neven-numbered elements of the destination vector, starting at zero, while vector\nelements from the second source register are placed into odd-numbered elements\nof the destination vector.\n\nBy using this instruction with TRN1, a 2 x 2 matrix can be transposed.\n\n\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "TRN2",
        "templates": {
          "ADVSIMD": [
            "TRN2  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ]
        }
      },
      "UABAL_advsimd": {
        "authored": "Unsigned Absolute difference and Accumulate Long. This instruction subtracts the\nvector elements in the lower or upper half of the second source SIMD&FP register\nfrom the corresponding vector elements of the first source SIMD&FP register, and\naccumulates the absolute values of the results into the vector elements of the\ndestination SIMD&FP register. The destination vector elements are twice as long\nas the source vector elements. All the values in this instruction are unsigned\ninteger values.\n\nThe UABAL instruction extracts each source vector from the lower half of each\nsource register, while the UABAL2 instruction extracts each source vector from\nthe upper half of each source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "UABAL, UABAL2",
        "templates": {
          "3REG_DIFF": [
            "UABAL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>"
          ]
        }
      },
      "UABA_advsimd": {
        "authored": "Unsigned Absolute difference and Accumulate. This instruction subtracts the\nelements of the vector of the second source SIMD&FP register from the\ncorresponding elements of the first source SIMD&FP register, and accumulates the\nabsolute values of the results into the elements of the vector of the\ndestination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "UABA",
        "templates": {
          "3REG_SAME": [
            "UABA  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ]
        }
      },
      "UABDL_advsimd": {
        "authored": "Unsigned Absolute Difference Long. This instruction subtracts the vector\nelements in the lower or upper half of the second source SIMD&FP register from\nthe corresponding vector elements of the first source SIMD&FP register, places\nthe absolute value of the result into a vector, and writes the vector to the\ndestination SIMD&FP register. The destination vector elements are twice as long\nas the source vector elements. All the values in this instruction are unsigned\ninteger values.\n\nThe UABDL instruction extracts each source vector from the lower half of each\nsource register, while the UABDL2 instruction extracts each source vector from\nthe upper half of each source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "UABDL, UABDL2",
        "templates": {
          "3REG_DIFF": [
            "UABDL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>"
          ]
        }
      },
      "UABD_advsimd": {
        "authored": "Unsigned Absolute Difference (vector). This instruction subtracts the elements\nof the vector of the second source SIMD&FP register from the corresponding\nelements of the first source SIMD&FP register, places the the absolute values of\nthe results into a vector, and writes the vector to the destination SIMD&FP\nregister.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "UABD",
        "templates": {
          "3REG_SAME": [
            "UABD  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ]
        }
      },
      "UADALP_advsimd": {
        "authored": "Unsigned Add and Accumulate Long Pairwise. This instruction adds pairs of\nadjacent unsigned integer values from the vector in the source SIMD&FP register\nand accumulates the results with the vector elements of the destination SIMD&FP\nregister. The destination vector elements are twice as long as the source vector\nelements.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "UADALP",
        "templates": {
          "SIMD": [
            "UADALP  <Vd>.<Ta>, <Vn>.<Tb>"
          ]
        }
      },
      "UADDLP_advsimd": {
        "authored": "Unsigned Add Long Pairwise. This instruction adds pairs of adjacent unsigned\ninteger values from the vector in the source SIMD&FP register, places the result\ninto a vector, and writes the vector to the destination SIMD&FP register. The\ndestination vector elements are twice as long as the source vector elements.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "UADDLP",
        "templates": {
          "SIMD": [
            "UADDLP  <Vd>.<Ta>, <Vn>.<Tb>"
          ]
        }
      },
      "UADDLV_advsimd": {
        "authored": "Unsigned sum Long across Vector. This instruction adds every vector element in\nthe source SIMD&FP register together, and writes the scalar result to the\ndestination SIMD&FP register. The destination scalar is twice as long as the\nsource vector elements. All the values in this instruction are unsigned integer\nvalues.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "UADDLV",
        "templates": {
          "ADVSIMD": [
            "UADDLV  <V><d>, <Vn>.<T>"
          ]
        }
      },
      "UADDL_advsimd": {
        "authored": "Unsigned Add Long (vector). This instruction adds each vector element in the\nlower or upper half of the first source SIMD&FP register to the corresponding\nvector element of the second source SIMD&FP register, places the result into a\nvector, and writes the vector to the destination SIMD&FP register. The\ndestination vector elements are twice as long as the source vector elements. All\nthe values in this instruction are unsigned integer values.\n\nThe UADDL instruction extracts each source vector from the lower half of each\nsource register, while the UADDL2 instruction extracts each source vector from\nthe upper half of each source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "UADDL, UADDL2",
        "templates": {
          "3REG_DIFF": [
            "UADDL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>"
          ]
        }
      },
      "UADDW_advsimd": {
        "authored": "Unsigned Add Wide. This instruction adds the vector elements of the first source\nSIMD&FP register to the corresponding vector elements in the lower or upper half\nof the second source SIMD&FP register, places the result in a vector, and writes\nthe vector to the SIMD&FP destination register. The vector elements of the\ndestination register and the first source register are twice as long as the\nvector elements of the second source register. All the values in this\ninstruction are unsigned integer values.\n\nThe UADDW instruction extracts vector elements from the lower half of the second\nsource register, while the UADDW2 instruction extracts vector elements from the\nupper half of the second source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "UADDW, UADDW2",
        "templates": {
          "3REG_DIFF": [
            "UADDW{2}  <Vd>.<Ta>, <Vn>.<Ta>, <Vm>.<Tb>"
          ]
        }
      },
      "UCVTF_advsimd_fix": {
        "authored": "Unsigned fixed-point Convert to Floating-point (vector). This instruction\nconverts each element in a vector from fixed-point to floating-point using the\nrounding mode that is specified by the FPCR, and writes the result to the\nSIMD&FP destination register.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the Security state and Exception level in which the instruction is executed,\nan attempt to execute the instruction might be trapped.",
        "heading": "UCVTF (vector, fixed-point)",
        "templates": {
          "SIMD": [
            "UCVTF  <Vd>.<T>, <Vn>.<T>, #<fbits>"
          ],
          "SISD": [
            "UCVTF  <V><d>, <V><n>, #<fbits>"
          ]
        }
      },
      "UCVTF_advsimd_int": {
        "authored": "Unsigned integer Convert to Floating-point (vector). This instruction converts\neach element in a vector from an unsigned integer value to a floating-point\nvalue using the rounding mode that is specified by the FPCR, and writes the\nresult to the SIMD&FP destination register.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the Security state and Exception level in which the instruction is executed,\nan attempt to execute the instruction might be trapped.",
        "heading": "UCVTF (vector, integer)",
        "templates": {
          "SIMD_HALF": [
            "UCVTF  <Vd>.<T>, <Vn>.<T>"
          ],
          "SIMD_SINGLE_AND_DOUBLE": [
            "UCVTF  <Vd>.<T>, <Vn>.<T>"
          ],
          "SISD_HALF": [
            "UCVTF  <Hd>, <Hn>"
          ],
          "SISD_SINGLE_AND_DOUBLE": [
            "UCVTF  <V><d>, <V><n>"
          ]
        }
      },
      "UCVTF_float_fix": {
        "authored": "Unsigned fixed-point Convert to Floating-point (scalar). This instruction\nconverts the unsigned value in the 32-bit or 64-bit general-purpose source\nregister to a floating-point value using the rounding mode that is specified by\nthe FPCR, and writes the result to the SIMD&FP destination register.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the Security state and Exception level in which the instruction is executed,\nan attempt to execute the instruction might be trapped.",
        "heading": "UCVTF (scalar, fixed-point)",
        "templates": {
          "FLOAT": [
            "UCVTF  <Hd>, <Wn>, #<fbits>",
            "UCVTF  <Sd>, <Wn>, #<fbits>",
            "UCVTF  <Dd>, <Wn>, #<fbits>",
            "UCVTF  <Hd>, <Xn>, #<fbits>",
            "UCVTF  <Sd>, <Xn>, #<fbits>",
            "UCVTF  <Dd>, <Xn>, #<fbits>"
          ]
        }
      },
      "UCVTF_float_int": {
        "authored": "Unsigned integer Convert to Floating-point (scalar). This instruction converts\nthe unsigned integer value in the general-purpose source register to a floating-\npoint value using the rounding mode that is specified by the FPCR, and writes\nthe result to the SIMD&FP destination register.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "UCVTF (scalar, integer)",
        "templates": {
          "FLOAT": [
            "UCVTF  <Hd>, <Wn>",
            "UCVTF  <Sd>, <Wn>",
            "UCVTF  <Dd>, <Wn>",
            "UCVTF  <Hd>, <Xn>",
            "UCVTF  <Sd>, <Xn>",
            "UCVTF  <Dd>, <Xn>"
          ]
        }
      },
      "UDOT_advsimd_elt": {
        "authored": "Dot Product unsigned arithmetic (vector, by element). This instruction performs\nthe dot product of the four 8-bit elements in each 32-bit element of the first\nsource register with the four 8-bit elements of an indexed 32-bit element in the\nsecond source register, accumulating the result into the corresponding 32-bit\nelement of the destination register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.\n\nIn Armv8.2 and Armv8.3, this is an optional instruction. From Armv8.4 it is\nmandatory for all implementations to support it.\n\nID_AA64ISAR0_EL1.DP indicates whether this instruction is supported.",
        "heading": "UDOT (by element)",
        "templates": {
          "2REG_ELEMENT": [
            "UDOT  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.4B[<index>]"
          ]
        }
      },
      "UDOT_advsimd_vec": {
        "authored": "Dot Product unsigned arithmetic (vector). This instruction performs the dot\nproduct of the four unsigned 8-bit elements in each 32-bit element of the first\nsource register with the four unsigned 8-bit elements of the corresponding\n32-bit element in the second source register, accumulating the result into the\ncorresponding 32-bit element of the destination register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.\n\nIn Armv8.2 and Armv8.3, this is an optional instruction. From Armv8.4 it is\nmandatory for all implementations to support it.\n\nID_AA64ISAR0_EL1.DP indicates whether this instruction is supported.",
        "heading": "UDOT (vector)",
        "templates": {
          "SIMD": [
            "UDOT  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>"
          ]
        }
      },
      "UHADD_advsimd": {
        "authored": "Unsigned Halving Add. This instruction adds corresponding unsigned integer\nvalues from the two source SIMD&FP registers, shifts each result right one bit,\nplaces the results into a vector, and writes the vector to the destination\nSIMD&FP register.\n\nThe results are truncated. For rounded results, see URHADD.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "UHADD",
        "templates": {
          "3REG_SAME": [
            "UHADD  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ]
        }
      },
      "UHSUB_advsimd": {
        "authored": "Unsigned Halving Subtract. This instruction subtracts the vector elements in the\nsecond source SIMD&FP register from the corresponding vector elements in the\nfirst source SIMD&FP register, shifts each result right one bit, places each\nresult into a vector, and writes the vector to the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "UHSUB",
        "templates": {
          "3REG_SAME": [
            "UHSUB  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ]
        }
      },
      "UMAXP_advsimd": {
        "authored": "Unsigned Maximum Pairwise. This instruction creates a vector by concatenating\nthe vector elements of the first source SIMD&FP register after the vector\nelements of the second source SIMD&FP register, reads each pair of adjacent\nvector elements in the two source SIMD&FP registers, writes the largest of each\npair of unsigned integer values into a vector, and writes the vector to the\ndestination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "UMAXP",
        "templates": {
          "3REG_SAME": [
            "UMAXP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ]
        }
      },
      "UMAXV_advsimd": {
        "authored": "Unsigned Maximum across Vector. This instruction compares all the vector\nelements in the source SIMD&FP register, and writes the largest of the values as\na scalar to the destination SIMD&FP register. All the values in this instruction\nare unsigned integer values.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "UMAXV",
        "templates": {
          "ADVSIMD": [
            "UMAXV  <V><d>, <Vn>.<T>"
          ]
        }
      },
      "UMAX_advsimd": {
        "authored": "Unsigned Maximum (vector). This instruction compares corresponding elements in\nthe vectors in the two source SIMD&FP registers, places the larger of each pair\nof unsigned integer values into a vector, and writes the vector to the\ndestination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "UMAX",
        "templates": {
          "3REG_SAME": [
            "UMAX  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ]
        }
      },
      "UMINP_advsimd": {
        "authored": "Unsigned Minimum Pairwise. This instruction creates a vector by concatenating\nthe vector elements of the first source SIMD&FP register after the vector\nelements of the second source SIMD&FP register, reads each pair of adjacent\nvector elements in the two source SIMD&FP registers, writes the smallest of each\npair of unsigned integer values into a vector, and writes the vector to the\ndestination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "UMINP",
        "templates": {
          "3REG_SAME": [
            "UMINP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ]
        }
      },
      "UMINV_advsimd": {
        "authored": "Unsigned Minimum across Vector. This instruction compares all the vector\nelements in the source SIMD&FP register, and writes the smallest of the values\nas a scalar to the destination SIMD&FP register. All the values in this\ninstruction are unsigned integer values.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "UMINV",
        "templates": {
          "ADVSIMD": [
            "UMINV  <V><d>, <Vn>.<T>"
          ]
        }
      },
      "UMIN_advsimd": {
        "authored": "Unsigned Minimum (vector). This instruction compares corresponding vector\nelements in the two source SIMD&FP registers, places the smaller of each of the\ntwo unsigned integer values into a vector, and writes the vector to the\ndestination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "UMIN",
        "templates": {
          "3REG_SAME": [
            "UMIN  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ]
        }
      },
      "UMLAL_advsimd_elt": {
        "authored": "Unsigned Multiply-Add Long (vector, by element). This instruction multiplies\neach vector element in the lower or upper half of the first source SIMD&FP\nregister by the specified vector element of the second source SIMD&FP register\nand accumulates the results with the vector elements of the destination SIMD&FP\nregister. The destination vector elements are twice as long as the elements that\nare multiplied.\n\nThe UMLAL instruction extracts vector elements from the lower half of the first\nsource register, while the UMLAL2 instruction extracts vector elements from the\nupper half of the first source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "UMLAL, UMLAL2 (by element)",
        "templates": {
          "2REG_ELEMENT": [
            "UMLAL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Ts>[<index>]"
          ]
        }
      },
      "UMLAL_advsimd_vec": {
        "authored": "Unsigned Multiply-Add Long (vector). This instruction multiplies the vector\nelements in the lower or upper half of the first source SIMD&FP register by the\ncorresponding vector elements of the second source SIMD&FP register, and\naccumulates the results with the vector elements of the destination SIMD&FP\nregister. The destination vector elements are twice as long as the elements that\nare multiplied.\n\nThe UMLAL instruction extracts vector elements from the lower half of the first\nsource register, while the UMLAL2 instruction extracts vector elements from the\nupper half of the first source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "UMLAL, UMLAL2 (vector)",
        "templates": {
          "3REG_DIFF": [
            "UMLAL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>"
          ]
        }
      },
      "UMLSL_advsimd_elt": {
        "authored": "Unsigned Multiply-Subtract Long (vector, by element). This instruction\nmultiplies each vector element in the lower or upper half of the first source\nSIMD&FP register by the specified vector element of the second source SIMD&FP\nregister and subtracts the results from the vector elements of the destination\nSIMD&FP register. The destination vector elements are twice as long as the\nelements that are multiplied.\n\nThe UMLSL instruction extracts vector elements from the lower half of the first\nsource register, while the UMLSL2 instruction extracts vector elements from the\nupper half of the first source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "UMLSL, UMLSL2 (by element)",
        "templates": {
          "2REG_ELEMENT": [
            "UMLSL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Ts>[<index>]"
          ]
        }
      },
      "UMLSL_advsimd_vec": {
        "authored": "Unsigned Multiply-Subtract Long (vector). This instruction multiplies\ncorresponding vector elements in the lower or upper half of the two source\nSIMD&FP registers, and subtracts the results from the vector elements of the\ndestination SIMD&FP register. The destination vector elements are twice as long\nas the elements that are multiplied. All the values in this instruction are\nunsigned integer values.\n\nThe UMLSL instruction extracts each source vector from the lower half of each\nsource register, while the UMLSL2 instruction extracts each source vector from\nthe upper half of each source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "UMLSL, UMLSL2 (vector)",
        "templates": {
          "3REG_DIFF": [
            "UMLSL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>"
          ]
        }
      },
      "UMMLA_advsimd_vec": {
        "authored": "Unsigned 8-bit integer matrix multiply-accumulate. This instruction multiplies\nthe 2x8 matrix of unsigned 8-bit integer values in the first source vector by\nthe 8x2 matrix of unsigned 8-bit integer values in the second source vector. The\nresulting 2x2 32-bit integer matrix product is destructively added to the 32-bit\ninteger matrix accumulator in the destination vector. This is equivalent to\nperforming an 8-way dot product per destination element.\n\nFrom Armv8.2 to Armv8.5, this is an optional instruction. From Armv8.6 it is\nmandatory for implementations that include Advanced SIMD to support it.\nID_AA64ISAR1_EL1.I8MM indicates whether this instruction is supported.",
        "heading": "UMMLA (vector)",
        "templates": {
          "SIMD": [
            "UMMLA  <Vd>.4S, <Vn>.16B, <Vm>.16B"
          ]
        }
      },
      "UMOV_advsimd": {
        "authored": "Unsigned Move vector element to general-purpose register. This instruction reads\nthe unsigned integer from the source SIMD&FP register, zero-extends it to form a\n32-bit or 64-bit value, and writes the result to the destination general-purpose\nregister.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "UMOV",
        "templates": {
          "ADVSIMD": [
            "UMOV  <Wd>, <Vn>.<Ts>[<index>]",
            "UMOV  <Xd>, <Vn>.<Ts>[<index>]"
          ]
        }
      },
      "UMULL_advsimd_elt": {
        "authored": "Unsigned Multiply Long (vector, by element). This instruction multiplies each\nvector element in the lower or upper half of the first source SIMD&FP register\nby the specified vector element of the second source SIMD&FP register, places\nthe results in a vector, and writes the vector to the destination SIMD&FP\nregister. The destination vector elements are twice as long as the elements that\nare multiplied.\n\nThe UMULL instruction extracts vector elements from the lower half of the first\nsource register, while the UMULL2 instruction extracts vector elements from the\nupper half of the first source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "UMULL, UMULL2 (by element)",
        "templates": {
          "2REG_ELEMENT": [
            "UMULL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Ts>[<index>]"
          ]
        }
      },
      "UMULL_advsimd_vec": {
        "authored": "Unsigned Multiply long (vector). This instruction multiplies corresponding\nvector elements in the lower or upper half of the two source SIMD&FP registers,\nplaces the result in a vector, and writes the vector to the destination SIMD&FP\nregister. The destination vector elements are twice as long as the elements that\nare multiplied. All the values in this instruction are unsigned integer values.\n\nThe UMULL instruction extracts each source vector from the lower half of each\nsource register, while the UMULL2 instruction extracts each source vector from\nthe upper half of each source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "UMULL, UMULL2 (vector)",
        "templates": {
          "3REG_DIFF": [
            "UMULL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>"
          ]
        }
      },
      "UQADD_advsimd": {
        "authored": "Unsigned saturating Add. This instruction adds the values of corresponding\nelements of the two source SIMD&FP registers, places the results into a vector,\nand writes the vector to the destination SIMD&FP register.\n\nIf overflow occurs with any of the results, those results are saturated. If\nsaturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "UQADD",
        "templates": {
          "SIMD": [
            "UQADD  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ],
          "SISD": [
            "UQADD  <V><d>, <V><n>, <V><m>"
          ]
        }
      },
      "UQRSHL_advsimd": {
        "authored": "Unsigned saturating Rounding Shift Left (register). This instruction takes each\nvector element of the first source SIMD&FP register, shifts the vector element\nby a value from the least significant byte of the corresponding vector element\nof the second source SIMD&FP register, places the results into a vector, and\nwrites the vector to the destination SIMD&FP register.\n\nIf the shift value is positive, the operation is a left shift. Otherwise, it is\na right shift. The results are rounded. For truncated results, see UQSHL.\n\nIf overflow occurs with any of the results, those results are saturated. If\nsaturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "UQRSHL",
        "templates": {
          "SIMD": [
            "UQRSHL  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ],
          "SISD": [
            "UQRSHL  <V><d>, <V><n>, <V><m>"
          ]
        }
      },
      "UQRSHRN_advsimd": {
        "authored": "Unsigned saturating Rounded Shift Right Narrow (immediate). This instruction\nreads each vector element in the source SIMD&FP register, right shifts each\nresult by an immediate value, puts the final result into a vector, and writes\nthe vector to the lower or upper half of the destination SIMD&FP register. All\nthe values in this instruction are unsigned integer values. The results are\nrounded. For truncated results, see UQSHRN.\n\nThe UQRSHRN instruction writes the vector to the lower half of the destination\nregister and clears the upper half, while the UQRSHRN2 instruction writes the\nvector to the upper half of the destination register without affecting the other\nbits of the register.\n\nIf overflow occurs with any of the results, those results are saturated. If\nsaturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "UQRSHRN, UQRSHRN2",
        "templates": {
          "SIMD": [
            "UQRSHRN{2}  <Vd>.<Tb>, <Vn>.<Ta>, #<shift>"
          ],
          "SISD": [
            "UQRSHRN  <Vb><d>, <Va><n>, #<shift>"
          ]
        }
      },
      "UQSHL_advsimd_imm": {
        "authored": "Unsigned saturating Shift Left (immediate). This instruction takes each vector\nelement in the source SIMD&FP register, shifts it by an immediate value, places\nthe results in a vector, and writes the vector to the destination SIMD&FP\nregister. The results are truncated. For rounded results, see UQRSHL.\n\nIf overflow occurs with any of the results, those results are saturated. If\nsaturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "UQSHL (immediate)",
        "templates": {
          "SIMD": [
            "UQSHL  <Vd>.<T>, <Vn>.<T>, #<shift>"
          ],
          "SISD": [
            "UQSHL  <V><d>, <V><n>, #<shift>"
          ]
        }
      },
      "UQSHL_advsimd_reg": {
        "authored": "Unsigned saturating Shift Left (register). This instruction takes each element\nin the vector of the first source SIMD&FP register, shifts the element by a\nvalue from the least significant byte of the corresponding element of the second\nsource SIMD&FP register, places the results in a vector, and writes the vector\nto the destination SIMD&FP register.\n\nIf the shift value is positive, the operation is a left shift. Otherwise, it is\na right shift. The results are truncated. For rounded results, see UQRSHL.\n\nIf overflow occurs with any of the results, those results are saturated. If\nsaturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "UQSHL (register)",
        "templates": {
          "SIMD": [
            "UQSHL  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ],
          "SISD": [
            "UQSHL  <V><d>, <V><n>, <V><m>"
          ]
        }
      },
      "UQSHRN_advsimd": {
        "authored": "Unsigned saturating Shift Right Narrow (immediate). This instruction reads each\nvector element in the source SIMD&FP register, right shifts each result by an\nimmediate value, saturates each shifted result to a value that is half the\noriginal width, puts the final result into a vector, and writes the vector to\nthe lower or upper half of the destination SIMD&FP register. All the values in\nthis instruction are unsigned integer values. The results are truncated. For\nrounded results, see UQRSHRN.\n\nThe UQSHRN instruction writes the vector to the lower half of the destination\nregister and clears the upper half, while the UQSHRN2 instruction writes the\nvector to the upper half of the destination register without affecting the other\nbits of the register.\n\nIf overflow occurs with any of the results, those results are saturated. If\nsaturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "UQSHRN, UQSHRN2",
        "templates": {
          "SIMD": [
            "UQSHRN{2}  <Vd>.<Tb>, <Vn>.<Ta>, #<shift>"
          ],
          "SISD": [
            "UQSHRN  <Vb><d>, <Va><n>, #<shift>"
          ]
        }
      },
      "UQSUB_advsimd": {
        "authored": "Unsigned saturating Subtract. This instruction subtracts the element values of\nthe second source SIMD&FP register from the corresponding element values of the\nfirst source SIMD&FP register, places the results into a vector, and writes the\nvector to the destination SIMD&FP register.\n\nIf overflow occurs with any of the results, those results are saturated. If\nsaturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "UQSUB",
        "templates": {
          "SIMD": [
            "UQSUB  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ],
          "SISD": [
            "UQSUB  <V><d>, <V><n>, <V><m>"
          ]
        }
      },
      "UQXTN_advsimd": {
        "authored": "Unsigned saturating extract Narrow. This instruction reads each vector element\nfrom the source SIMD&FP register, saturates each value to half the original\nwidth, places the result into a vector, and writes the vector to the destination\nSIMD&FP register. All the values in this instruction are unsigned integer\nvalues.\n\nIf saturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nThe UQXTN instruction writes the vector to the lower half of the destination\nregister and clears the upper half, while the UQXTN2 instruction writes the\nvector to the upper half of the destination register without affecting the other\nbits of the register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "UQXTN, UQXTN2",
        "templates": {
          "SIMD": [
            "UQXTN{2}  <Vd>.<Tb>, <Vn>.<Ta>"
          ],
          "SISD": [
            "UQXTN  <Vb><d>, <Va><n>"
          ]
        }
      },
      "URECPE_advsimd": {
        "authored": "Unsigned Reciprocal Estimate. This instruction reads each vector element from\nthe source SIMD&FP register, calculates an approximate inverse for the unsigned\ninteger value, places the result into a vector, and writes the vector to the\ndestination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "URECPE",
        "templates": {
          "SIMD": [
            "URECPE  <Vd>.<T>, <Vn>.<T>"
          ]
        }
      },
      "URHADD_advsimd": {
        "authored": "Unsigned Rounding Halving Add. This instruction adds corresponding unsigned\ninteger values from the two source SIMD&FP registers, shifts each result right\none bit, places the results into a vector, and writes the vector to the\ndestination SIMD&FP register.\n\nThe results are rounded. For truncated results, see UHADD.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "URHADD",
        "templates": {
          "3REG_SAME": [
            "URHADD  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ]
        }
      },
      "URSHL_advsimd": {
        "authored": "Unsigned Rounding Shift Left (register). This instruction takes each element in\nthe vector of the first source SIMD&FP register, shifts the vector element by a\nvalue from the least significant byte of the corresponding element of the second\nsource SIMD&FP register, places the results in a vector, and writes the vector\nto the destination SIMD&FP register.\n\nIf the shift value is positive, the operation is a left shift. If the shift\nvalue is negative, it is a rounding right shift.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "URSHL",
        "templates": {
          "SIMD": [
            "URSHL  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ],
          "SISD": [
            "URSHL  <V><d>, <V><n>, <V><m>"
          ]
        }
      },
      "URSHR_advsimd": {
        "authored": "Unsigned Rounding Shift Right (immediate). This instruction reads each vector\nelement in the source SIMD&FP register, right shifts each result by an immediate\nvalue, writes the final result to a vector, and writes the vector to the\ndestination SIMD&FP register. All the values in this instruction are unsigned\ninteger values. The results are rounded. For truncated results, see USHR.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "URSHR",
        "templates": {
          "SIMD": [
            "URSHR  <Vd>.<T>, <Vn>.<T>, #<shift>"
          ],
          "SISD": [
            "URSHR  <V><d>, <V><n>, #<shift>"
          ]
        }
      },
      "URSQRTE_advsimd": {
        "authored": "Unsigned Reciprocal Square Root Estimate. This instruction reads each vector\nelement from the source SIMD&FP register, calculates an approximate inverse\nsquare root for each value, places the result into a vector, and writes the\nvector to the destination SIMD&FP register. All the values in this instruction\nare unsigned integer values.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "URSQRTE",
        "templates": {
          "SIMD": [
            "URSQRTE  <Vd>.<T>, <Vn>.<T>"
          ]
        }
      },
      "URSRA_advsimd": {
        "authored": "Unsigned Rounding Shift Right and Accumulate (immediate). This instruction reads\neach vector element in the source SIMD&FP register, right shifts each result by\nan immediate value, and accumulates the final results with the vector elements\nof the destination SIMD&FP register. All the values in this instruction are\nunsigned integer values. The results are rounded. For truncated results, see\nUSRA.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "URSRA",
        "templates": {
          "SIMD": [
            "URSRA  <Vd>.<T>, <Vn>.<T>, #<shift>"
          ],
          "SISD": [
            "URSRA  <V><d>, <V><n>, #<shift>"
          ]
        }
      },
      "USDOT_advsimd_elt": {
        "authored": "Dot Product index form with unsigned and signed integers. This instruction\nperforms the dot product of the four unsigned 8-bit integer values in each\n32-bit element of the first source register with the four signed 8-bit integer\nvalues in an indexed 32-bit element of the second source register, accumulating\nthe result into the corresponding 32-bit element of the destination register.\n\nFrom Armv8.2 to Armv8.5, this is an optional instruction. From Armv8.6 it is\nmandatory for implementations that include Advanced SIMD to support it.\nID_AA64ISAR1_EL1.I8MM indicates whether this instruction is supported.",
        "heading": "USDOT (by element)",
        "templates": {
          "2REG_ELEMENT": [
            "USDOT  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.4B[<index>]"
          ]
        }
      },
      "USDOT_advsimd_vec": {
        "authored": "Dot Product vector form with unsigned and signed integers. This instruction\nperforms the dot product of the four unsigned 8-bit integer values in each\n32-bit element of the first source register with the four signed 8-bit integer\nvalues in the corresponding 32-bit element of the second source register,\naccumulating the result into the corresponding 32-bit element of the destination\nregister.\n\nFrom Armv8.2 to Armv8.5, this is an optional instruction. From Armv8.6 it is\nmandatory for implementations that include Advanced SIMD to support it.\nID_AA64ISAR1_EL1.I8MM indicates whether this instruction is supported.",
        "heading": "USDOT (vector)",
        "templates": {
          "SIMD": [
            "USDOT  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>"
          ]
        }
      },
      "USHLL_advsimd": {
        "authored": "Unsigned Shift Left Long (immediate). This instruction reads each vector element\nin the lower or upper half of the source SIMD&FP register, shifts the unsigned\ninteger value left by the specified number of bits, places the result into a\nvector, and writes the vector to the destination SIMD&FP register. The\ndestination vector elements are twice as long as the source vector elements.\n\nThe USHLL instruction extracts vector elements from the lower half of the source\nregister, while the USHLL2 instruction extracts vector elements from the upper\nhalf of the source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "USHLL, USHLL2",
        "templates": {
          "SIMD": [
            "USHLL{2}  <Vd>.<Ta>, <Vn>.<Tb>, #<shift>"
          ]
        }
      },
      "USHL_advsimd": {
        "authored": "Unsigned Shift Left (register). This instruction takes each element in the\nvector of the first source SIMD&FP register, shifts each element by a value from\nthe least significant byte of the corresponding element of the second source\nSIMD&FP register, places the results in a vector, and writes the vector to the\ndestination SIMD&FP register.\n\nIf the shift value is positive, the operation is a left shift. If the shift\nvalue is negative, it is a truncating right shift. For a rounding shift, see\nURSHL.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "USHL",
        "templates": {
          "SIMD": [
            "USHL  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ],
          "SISD": [
            "USHL  <V><d>, <V><n>, <V><m>"
          ]
        }
      },
      "USHR_advsimd": {
        "authored": "Unsigned Shift Right (immediate). This instruction reads each vector element in\nthe source SIMD&FP register, right shifts each result by an immediate value,\nwrites the final result to a vector, and writes the vector to the destination\nSIMD&FP register. All the values in this instruction are unsigned integer\nvalues. The results are truncated. For rounded results, see URSHR.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "USHR",
        "templates": {
          "SIMD": [
            "USHR  <Vd>.<T>, <Vn>.<T>, #<shift>"
          ],
          "SISD": [
            "USHR  <V><d>, <V><n>, #<shift>"
          ]
        }
      },
      "USMMLA_advsimd_vec": {
        "authored": "Unsigned and signed 8-bit integer matrix multiply-accumulate. This instruction\nmultiplies the 2x8 matrix of unsigned 8-bit integer values in the first source\nvector by the 8x2 matrix of signed 8-bit integer values in the second source\nvector. The resulting 2x2 32-bit integer matrix product is destructively added\nto the 32-bit integer matrix accumulator in the destination vector. This is\nequivalent to performing an 8-way dot product per destination element.\n\nFrom Armv8.2 to Armv8.5, this is an optional instruction. From Armv8.6 it is\nmandatory for implementations that include Advanced SIMD to support it.\nID_AA64ISAR1_EL1.I8MM indicates whether this instruction is supported.",
        "heading": "USMMLA (vector)",
        "templates": {
          "SIMD": [
            "USMMLA  <Vd>.4S, <Vn>.16B, <Vm>.16B"
          ]
        }
      },
      "USQADD_advsimd": {
        "authored": "Unsigned saturating Accumulate of Signed value. This instruction adds the signed\ninteger values of the vector elements in the source SIMD&FP register to\ncorresponding unsigned integer values of the vector elements in the destination\nSIMD&FP register, and accumulates the resulting unsigned integer values with the\nvector elements of the destination SIMD&FP register.\n\nIf overflow occurs with any of the results, those results are saturated. If\nsaturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "USQADD",
        "templates": {
          "SIMD": [
            "USQADD  <Vd>.<T>, <Vn>.<T>"
          ],
          "SISD": [
            "USQADD  <V><d>, <V><n>"
          ]
        }
      },
      "USRA_advsimd": {
        "authored": "Unsigned Shift Right and Accumulate (immediate). This instruction reads each\nvector element in the source SIMD&FP register, right shifts each result by an\nimmediate value, and accumulates the final results with the vector elements of\nthe destination SIMD&FP register. All the values in this instruction are\nunsigned integer values. The results are truncated. For rounded results, see\nURSRA.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "USRA",
        "templates": {
          "SIMD": [
            "USRA  <Vd>.<T>, <Vn>.<T>, #<shift>"
          ],
          "SISD": [
            "USRA  <V><d>, <V><n>, #<shift>"
          ]
        }
      },
      "USUBL_advsimd": {
        "authored": "Unsigned Subtract Long. This instruction subtracts each vector element in the\nlower or upper half of the second source SIMD&FP register from the corresponding\nvector element of the first source SIMD&FP register, places the result into a\nvector, and writes the vector to the destination SIMD&FP register. All the\nvalues in this instruction are unsigned integer values. The destination vector\nelements are twice as long as the source vector elements.\n\nThe USUBL instruction extracts each source vector from the lower half of each\nsource register, while the USUBL2 instruction extracts each source vector from\nthe upper half of each source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "USUBL, USUBL2",
        "templates": {
          "3REG_DIFF": [
            "USUBL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>"
          ]
        }
      },
      "USUBW_advsimd": {
        "authored": "Unsigned Subtract Wide. This instruction subtracts each vector element of the\nsecond source SIMD&FP register from the corresponding vector element in the\nlower or upper half of the first source SIMD&FP register, places the result in a\nvector, and writes the vector to the SIMD&FP destination register. All the\nvalues in this instruction are signed integer values.\n\nThe vector elements of the destination register and the first source register\nare twice as long as the vector elements of the second source register.\n\nThe USUBW instruction extracts vector elements from the lower half of the first\nsource register, while the USUBW2 instruction extracts vector elements from the\nupper half of the first source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "USUBW, USUBW2",
        "templates": {
          "3REG_DIFF": [
            "USUBW{2}  <Vd>.<Ta>, <Vn>.<Ta>, <Vm>.<Tb>"
          ]
        }
      },
      "UXTL_USHLL_advsimd": {
        "authored": "Unsigned extend Long. This instruction copies each vector element from the lower\nor upper half of the source SIMD&FP register into a vector, and writes the\nvector to the destination SIMD&FP register. The destination vector elements are\ntwice as long as the source vector elements.\n\nThe UXTL instruction extracts vector elements from the lower half of the source\nregister, while the UXTL2 instruction extracts vector elements from the upper\nhalf of the source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "UXTL, UXTL2",
        "templates": {
          "SIMD": [
            "UXTL{2}  <Vd>.<Ta>, <Vn>.<Tb>"
          ]
        }
      },
      "UZP1_advsimd": {
        "authored": "Unzip vectors (primary). This instruction reads corresponding even-numbered\nvector elements from the two source SIMD&FP registers, starting at zero, places\nthe result from the first source register into consecutive elements in the lower\nhalf of a vector, and the result from the second source register into\nconsecutive elements in the upper half of a vector, and writes the vector to the\ndestination SIMD&FP register.\n\nThis instruction can be used with UZP2 to de-interleave two vectors.\n\n\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "UZP1",
        "templates": {
          "ADVSIMD": [
            "UZP1  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ]
        }
      },
      "UZP2_advsimd": {
        "authored": "Unzip vectors (secondary). This instruction reads corresponding odd-numbered\nvector elements from the two source SIMD&FP registers, places the result from\nthe first source register into consecutive elements in the lower half of a\nvector, and the result from the second source register into consecutive elements\nin the upper half of a vector, and writes the vector to the destination SIMD&FP\nregister.\n\nThis instruction can be used with UZP1 to de-interleave two vectors.\n\n\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "UZP2",
        "templates": {
          "ADVSIMD": [
            "UZP2  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ]
        }
      },
      "XAR_advsimd": {
        "authored": "Exclusive OR and Rotate performs a bitwise exclusive OR of the 128-bit vectors\nin the two source SIMD&FP registers, rotates each 64-bit element of the\nresulting 128-bit vector right by the value specified by a 6-bit immediate\nvalue, and writes the result to the destination SIMD&FP register.\n\nThis instruction is implemented only when FEAT_SHA3 is implemented.",
        "heading": "XAR",
        "templates": {
          "ADVSIMD": [
            "XAR  <Vd>.2D, <Vn>.2D, <Vm>.2D, #<imm6>"
          ]
        }
      },
      "XTN_advsimd": {
        "authored": "Extract Narrow. This instruction reads each vector element from the source\nSIMD&FP register, narrows each value to half the original width, places the\nresult into a vector, and writes the vector to the lower or upper half of the\ndestination SIMD&FP register. The destination vector elements are half as long\nas the source vector elements.\n\nThe XTN instruction writes the vector to the lower half of the destination\nregister and clears the upper half, while the XTN2 instruction writes the vector\nto the upper half of the destination register without affecting the other bits\nof the register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "XTN, XTN2",
        "templates": {
          "SIMD": [
            "XTN{2}  <Vd>.<Tb>, <Vn>.<Ta>"
          ]
        }
      },
      "ZIP1_advsimd": {
        "authored": "Zip vectors (primary). This instruction reads adjacent vector elements from the\nlower half of two source SIMD&FP registers as pairs, interleaves the pairs and\nplaces them into a vector, and writes the vector to the destination SIMD&FP\nregister. The first pair from the first source register is placed into the two\nlowest vector elements, with subsequent pairs taken alternately from each source\nregister.\n\nThis instruction can be used with ZIP2 to interleave two vectors.\n\n\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "ZIP1",
        "templates": {
          "ADVSIMD": [
            "ZIP1  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ]
        }
      },
      "ZIP2_advsimd": {
        "authored": "Zip vectors (secondary). This instruction reads adjacent vector elements from\nthe upper half of two source SIMD&FP registers as pairs, interleaves the pairs\nand places them into a vector, and writes the vector to the destination SIMD&FP\nregister. The first pair from the first source register is placed into the two\nlowest vector elements, with subsequent pairs taken alternately from each source\nregister.\n\nThis instruction can be used with ZIP1 to interleave two vectors.\n\n\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "ZIP2",
        "templates": {
          "ADVSIMD": [
            "ZIP2  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ]
        }
      }
    }
  },
  "keywords": {
    "DA": "Decrement After. The consecutive memory addresses end at the address in the base\nregister.",
    "DB": "Decrement Before. The consecutive memory addresses end one word below the\naddress in the base register.",
    "EA": "Empty Ascending.",
    "ED": "Empty Descending.",
    "FA": "Full Ascending.",
    "FD": "Full Descending.",
    "IA": "Increment After. The consecutive memory addresses start at the address in the\nbase register.",
    "IB": "Increment Before. The consecutive memory addresses start one word above the\naddress in the base register.",
    "ISH": "Inner Shareable is the required shareability domain, reads and writes are the\nrequired access types, both before and after the barrier instruction.",
    "ISHLD": "Inner Shareable is the required shareability domain, reads are the required\naccess type before the barrier instruction, and reads and writes are the\nrequired access types after the barrier instruction.",
    "ISHST": "Inner Shareable is the required shareability domain, writes are the required\naccess type, both before and after the barrier instruction.",
    "LD": "Full system is the required shareability domain, reads are the required access\ntype before the barrier instruction, and reads and writes are the required\naccess types after the barrier instruction.",
    "NSH": "Non-shareable is the required shareability domain, reads and writes are the\nrequired access, both before and after the barrier instruction.",
    "NSHLD": "Non-shareable is the required shareability domain, reads are the required access\ntype before the barrier instruction, and reads and writes are the required\naccess types after the barrier instruction.",
    "NSHST": "Non-shareable is the required shareability domain, writes are the required\naccess type both before and after the barrier instruction.",
    "OSH": "Outer Shareable is the required shareability domain, reads and writes are the\nrequired access types, both before and after the barrier instruction.",
    "OSHLD": "Outer Shareable is the required shareability domain, reads are the required\naccess type before the barrier instruction, and reads and writes are the\nrequired access types after the barrier instruction.",
    "OSHST": "Outer Shareable is the required shareability domain, writes are the required\naccess type, both before and after the barrier instruction.",
    "ST": "Full system is the required shareability domain, writes are the required access\ntype, both before and after the barrier instruction. SYST is a synonym for ST.\nEncoded as option = 0b1110.",
    "SY": "Full system barrier operation, encoded as option = 0b1111. Can be omitted."
  },
  "registers": {
    "base": {
      "D0": {
        "long_name": "64-bit SIMD and VFP Register",
        "purpose": "Registers S0-S15 (D0-D7, Q0-Q3) do not need to be preserved (and can be used for\npassing arguments or returning results in standard procedure-call variants)."
      },
      "D1": {
        "long_name": "64-bit SIMD and VFP Register",
        "purpose": "Registers S0-S15 (D0-D7, Q0-Q3) do not need to be preserved (and can be used for\npassing arguments or returning results in standard procedure-call variants)."
      },
      "D10": {
        "long_name": "64-bit SIMD and VFP Register",
        "purpose": "Registers S16-S31 (D8-D15, Q4-Q7) must be preserved across subroutine calls."
      },
      "D11": {
        "long_name": "64-bit SIMD and VFP Register",
        "purpose": "Registers S16-S31 (D8-D15, Q4-Q7) must be preserved across subroutine calls."
      },
      "D12": {
        "long_name": "64-bit SIMD and VFP Register",
        "purpose": "Registers S16-S31 (D8-D15, Q4-Q7) must be preserved across subroutine calls."
      },
      "D13": {
        "long_name": "64-bit SIMD and VFP Register",
        "purpose": "Registers S16-S31 (D8-D15, Q4-Q7) must be preserved across subroutine calls."
      },
      "D14": {
        "long_name": "64-bit SIMD and VFP Register",
        "purpose": "Registers S16-S31 (D8-D15, Q4-Q7) must be preserved across subroutine calls."
      },
      "D15": {
        "long_name": "64-bit SIMD and VFP Register",
        "purpose": "Registers S16-S31 (D8-D15, Q4-Q7) must be preserved across subroutine calls."
      },
      "D16": {
        "long_name": "64-bit SIMD and VFP Register",
        "purpose": "Registers D16-D31 (Q8-Q15) do not need to be preserved."
      },
      "D17": {
        "long_name": "64-bit SIMD and VFP Register",
        "purpose": "Registers D16-D31 (Q8-Q15) do not need to be preserved."
      },
      "D18": {
        "long_name": "64-bit SIMD and VFP Register",
        "purpose": "Registers D16-D31 (Q8-Q15) do not need to be preserved."
      },
      "D19": {
        "long_name": "64-bit SIMD and VFP Register",
        "purpose": "Registers D16-D31 (Q8-Q15) do not need to be preserved."
      },
      "D2": {
        "long_name": "64-bit SIMD and VFP Register",
        "purpose": "Registers S0-S15 (D0-D7, Q0-Q3) do not need to be preserved (and can be used for\npassing arguments or returning results in standard procedure-call variants)."
      },
      "D20": {
        "long_name": "64-bit SIMD and VFP Register",
        "purpose": "Registers D16-D31 (Q8-Q15) do not need to be preserved."
      },
      "D21": {
        "long_name": "64-bit SIMD and VFP Register",
        "purpose": "Registers D16-D31 (Q8-Q15) do not need to be preserved."
      },
      "D22": {
        "long_name": "64-bit SIMD and VFP Register",
        "purpose": "Registers D16-D31 (Q8-Q15) do not need to be preserved."
      },
      "D23": {
        "long_name": "64-bit SIMD and VFP Register",
        "purpose": "Registers D16-D31 (Q8-Q15) do not need to be preserved."
      },
      "D24": {
        "long_name": "64-bit SIMD and VFP Register",
        "purpose": "Registers D16-D31 (Q8-Q15) do not need to be preserved."
      },
      "D25": {
        "long_name": "64-bit SIMD and VFP Register",
        "purpose": "Registers D16-D31 (Q8-Q15) do not need to be preserved."
      },
      "D26": {
        "long_name": "64-bit SIMD and VFP Register",
        "purpose": "Registers D16-D31 (Q8-Q15) do not need to be preserved."
      },
      "D27": {
        "long_name": "64-bit SIMD and VFP Register",
        "purpose": "Registers D16-D31 (Q8-Q15) do not need to be preserved."
      },
      "D28": {
        "long_name": "64-bit SIMD and VFP Register",
        "purpose": "Registers D16-D31 (Q8-Q15) do not need to be preserved."
      },
      "D29": {
        "long_name": "64-bit SIMD and VFP Register",
        "purpose": "Registers D16-D31 (Q8-Q15) do not need to be preserved."
      },
      "D3": {
        "long_name": "64-bit SIMD and VFP Register",
        "purpose": "Registers S0-S15 (D0-D7, Q0-Q3) do not need to be preserved (and can be used for\npassing arguments or returning results in standard procedure-call variants)."
      },
      "D30": {
        "long_name": "64-bit SIMD and VFP Register",
        "purpose": "Registers D16-D31 (Q8-Q15) do not need to be preserved."
      },
      "D31": {
        "long_name": "64-bit SIMD and VFP Register",
        "purpose": ""
      },
      "D4": {
        "long_name": "64-bit SIMD and VFP Register",
        "purpose": "Registers S0-S15 (D0-D7, Q0-Q3) do not need to be preserved (and can be used for\npassing arguments or returning results in standard procedure-call variants)."
      },
      "D5": {
        "long_name": "64-bit SIMD and VFP Register",
        "purpose": "Registers S0-S15 (D0-D7, Q0-Q3) do not need to be preserved (and can be used for\npassing arguments or returning results in standard procedure-call variants)."
      },
      "D6": {
        "long_name": "64-bit SIMD and VFP Register",
        "purpose": "Registers S0-S15 (D0-D7, Q0-Q3) do not need to be preserved (and can be used for\npassing arguments or returning results in standard procedure-call variants)."
      },
      "D7": {
        "long_name": "64-bit SIMD and VFP Register",
        "purpose": "Registers S0-S15 (D0-D7, Q0-Q3) do not need to be preserved (and can be used for\npassing arguments or returning results in standard procedure-call variants)."
      },
      "D8": {
        "long_name": "64-bit SIMD and VFP Register",
        "purpose": "Registers S16-S31 (D8-D15, Q4-Q7) must be preserved across subroutine calls."
      },
      "D9": {
        "long_name": "64-bit SIMD and VFP Register",
        "purpose": "Registers S16-S31 (D8-D15, Q4-Q7) must be preserved across subroutine calls."
      },
      "LR": {
        "long_name": "32-bit Link Register",
        "purpose": "The link register is a special register that can hold return link information."
      },
      "PC": {
        "long_name": "32-bit Program Counter",
        "purpose": "  - When executing an A32 instruction, PC reads as the address of the current\n    instruction plus 8.\n  - When executing a T32 instruction, PC reads as the address of the current\n    instruction plus 4.\n  - Writing an address to PC causes a branch to that address."
      },
      "Q0": {
        "long_name": "128-bit SIMD and VFP Register",
        "purpose": "Registers S0-S15 (D0-D7, Q0-Q3) do not need to be preserved (and can be used for\npassing arguments or returning results in standard procedure-call variants)."
      },
      "Q1": {
        "long_name": "128-bit SIMD and VFP Register",
        "purpose": "Registers S0-S15 (D0-D7, Q0-Q3) do not need to be preserved (and can be used for\npassing arguments or returning results in standard procedure-call variants)."
      },
      "Q10": {
        "long_name": "128-bit SIMD and VFP Register",
        "purpose": "Registers D16-D31 (Q8-Q15) do not need to be preserved."
      },
      "Q11": {
        "long_name": "128-bit SIMD and VFP Register",
        "purpose": "Registers D16-D31 (Q8-Q15) do not need to be preserved."
      },
      "Q12": {
        "long_name": "128-bit SIMD and VFP Register",
        "purpose": "Registers D16-D31 (Q8-Q15) do not need to be preserved."
      },
      "Q13": {
        "long_name": "128-bit SIMD and VFP Register",
        "purpose": "Registers D16-D31 (Q8-Q15) do not need to be preserved."
      },
      "Q14": {
        "long_name": "128-bit SIMD and VFP Register",
        "purpose": "Registers D16-D31 (Q8-Q15) do not need to be preserved."
      },
      "Q15": {
        "long_name": "128-bit SIMD and VFP Register",
        "purpose": "Registers D16-D31 (Q8-Q15) do not need to be preserved."
      },
      "Q2": {
        "long_name": "128-bit SIMD and VFP Register",
        "purpose": "Registers S0-S15 (D0-D7, Q0-Q3) do not need to be preserved (and can be used for\npassing arguments or returning results in standard procedure-call variants)."
      },
      "Q3": {
        "long_name": "128-bit SIMD and VFP Register",
        "purpose": "Registers S0-S15 (D0-D7, Q0-Q3) do not need to be preserved (and can be used for\npassing arguments or returning results in standard procedure-call variants)."
      },
      "Q4": {
        "long_name": "128-bit SIMD and VFP Register",
        "purpose": "Registers S16-S31 (D8-D15, Q4-Q7) must be preserved across subroutine calls."
      },
      "Q5": {
        "long_name": "128-bit SIMD and VFP Register",
        "purpose": "Registers S16-S31 (D8-D15, Q4-Q7) must be preserved across subroutine calls."
      },
      "Q6": {
        "long_name": "128-bit SIMD and VFP Register",
        "purpose": "Registers S16-S31 (D8-D15, Q4-Q7) must be preserved across subroutine calls."
      },
      "Q7": {
        "long_name": "128-bit SIMD and VFP Register",
        "purpose": "Registers S16-S31 (D8-D15, Q4-Q7) must be preserved across subroutine calls."
      },
      "Q8": {
        "long_name": "128-bit SIMD and VFP Register",
        "purpose": "Registers D16-D31 (Q8-Q15) do not need to be preserved."
      },
      "Q9": {
        "long_name": "128-bit SIMD and VFP Register",
        "purpose": "Registers D16-D31 (Q8-Q15) do not need to be preserved."
      },
      "R0": {
        "long_name": "32-bit General Purpose Register",
        "purpose": "Argument / result / scratch register 1.\n\nThe first four registers R0-R3 are used to pass argument values into a\nsubroutine and to return a result value from a function. They may also be used\nto hold intermediate values within a routine (but, in general, only between\nsubroutine calls)."
      },
      "R1": {
        "long_name": "32-bit General Purpose Register",
        "purpose": "Argument / result / scratch register 2.\n\nThe first four registers R0-R3 are used to pass argument values into a\nsubroutine and to return a result value from a function. They may also be used\nto hold intermediate values within a routine (but, in general, only between\nsubroutine calls)."
      },
      "R10": {
        "long_name": "32-bit General Purpose Register",
        "purpose": "Variable register 7.\n\nTypically, the registers R4-R8, R10 and R11 are used to hold the values of a\nroutine's local variables."
      },
      "R11": {
        "long_name": "32-bit General Purpose Register",
        "purpose": "Variable register 8.\n\nTypically, the registers R4-R8, R10 and R11 are used to hold the values of a\nroutine's local variables."
      },
      "R12": {
        "long_name": "32-bit General Purpose Register",
        "purpose": "Intra-Procedure-call scratch register.\n\nRegister R12 (IP) may be used by a linker as a scratch register between a\nroutine and any subroutine it calls. It can also be used within a routine to\nhold intermediate values between subroutine calls."
      },
      "R2": {
        "long_name": "32-bit General Purpose Register",
        "purpose": "Argument / scratch register 3.\n\nThe first four registers R0-R3 are used to pass argument values into a\nsubroutine and to return a result value from a function. They may also be used\nto hold intermediate values within a routine (but, in general, only between\nsubroutine calls)."
      },
      "R3": {
        "long_name": "32-bit General Purpose Register",
        "purpose": "Argument / scratch register 4.\n\nThe first four registers R0-R3 are used to pass argument values into a\nsubroutine and to return a result value from a function. They may also be used\nto hold intermediate values within a routine (but, in general, only between\nsubroutine calls)."
      },
      "R4": {
        "long_name": "32-bit General Purpose Register",
        "purpose": "Variable register 1.\n\nTypically, the registers R4-R8, R10 and R11 are used to hold the values of a\nroutine's local variables."
      },
      "R5": {
        "long_name": "32-bit General Purpose Register",
        "purpose": "Variable register 2.\n\nTypically, the registers R4-R8, R10 and R11 are used to hold the values of a\nroutine's local variables."
      },
      "R6": {
        "long_name": "32-bit General Purpose Register",
        "purpose": "Variable register 3.\n\nTypically, the registers R4-R8, R10 and R11 are used to hold the values of a\nroutine's local variables."
      },
      "R7": {
        "long_name": "32-bit General Purpose Register",
        "purpose": "Variable register 4.\n\nTypically, the registers R4-R8, R10 and R11 are used to hold the values of a\nroutine's local variables."
      },
      "R8": {
        "long_name": "32-bit General Purpose Register",
        "purpose": "Variable register 5.\n\nTypically, the registers R4-R8, R10 and R11 are used to hold the values of a\nroutine's local variables."
      },
      "R9": {
        "long_name": "32-bit General Purpose Register",
        "purpose": "Platform register.\n\nThe role of register R9 is platform specific. A virtual platform may assign any\nrole to this register and must document this usage. For example, it may\ndesignate it as the static base  in a position-independent data model, or it may\ndesignate it as the thread register in an environment with thread-local storage.\nThe usage of this register may require that the value held is persistent across\nall calls. A virtual platform that has no need for such a special register may\ndesignate R9 as an additional callee-saved variable register."
      },
      "S0": {
        "long_name": "32-bit SIMD and VFP Register",
        "purpose": "Registers S0-S15 (D0-D7, Q0-Q3) do not need to be preserved (and can be used for\npassing arguments or returning results in standard procedure-call variants)."
      },
      "S1": {
        "long_name": "32-bit SIMD and VFP Register",
        "purpose": "Registers S0-S15 (D0-D7, Q0-Q3) do not need to be preserved (and can be used for\npassing arguments or returning results in standard procedure-call variants)."
      },
      "S10": {
        "long_name": "32-bit SIMD and VFP Register",
        "purpose": "Registers S0-S15 (D0-D7, Q0-Q3) do not need to be preserved (and can be used for\npassing arguments or returning results in standard procedure-call variants)."
      },
      "S11": {
        "long_name": "32-bit SIMD and VFP Register",
        "purpose": "Registers S0-S15 (D0-D7, Q0-Q3) do not need to be preserved (and can be used for\npassing arguments or returning results in standard procedure-call variants)."
      },
      "S12": {
        "long_name": "32-bit SIMD and VFP Register",
        "purpose": "Registers S0-S15 (D0-D7, Q0-Q3) do not need to be preserved (and can be used for\npassing arguments or returning results in standard procedure-call variants)."
      },
      "S13": {
        "long_name": "32-bit SIMD and VFP Register",
        "purpose": "Registers S0-S15 (D0-D7, Q0-Q3) do not need to be preserved (and can be used for\npassing arguments or returning results in standard procedure-call variants)."
      },
      "S14": {
        "long_name": "32-bit SIMD and VFP Register",
        "purpose": "Registers S0-S15 (D0-D7, Q0-Q3) do not need to be preserved (and can be used for\npassing arguments or returning results in standard procedure-call variants)."
      },
      "S15": {
        "long_name": "32-bit SIMD and VFP Register",
        "purpose": "Registers S0-S15 (D0-D7, Q0-Q3) do not need to be preserved (and can be used for\npassing arguments or returning results in standard procedure-call variants)."
      },
      "S16": {
        "long_name": "32-bit SIMD and VFP Register",
        "purpose": "Registers S16-S31 (D8-D15, Q4-Q7) must be preserved across subroutine calls."
      },
      "S17": {
        "long_name": "32-bit SIMD and VFP Register",
        "purpose": "Registers S16-S31 (D8-D15, Q4-Q7) must be preserved across subroutine calls."
      },
      "S18": {
        "long_name": "32-bit SIMD and VFP Register",
        "purpose": "Registers S16-S31 (D8-D15, Q4-Q7) must be preserved across subroutine calls."
      },
      "S19": {
        "long_name": "32-bit SIMD and VFP Register",
        "purpose": "Registers S16-S31 (D8-D15, Q4-Q7) must be preserved across subroutine calls."
      },
      "S2": {
        "long_name": "32-bit SIMD and VFP Register",
        "purpose": "Registers S0-S15 (D0-D7, Q0-Q3) do not need to be preserved (and can be used for\npassing arguments or returning results in standard procedure-call variants)."
      },
      "S20": {
        "long_name": "32-bit SIMD and VFP Register",
        "purpose": "Registers S16-S31 (D8-D15, Q4-Q7) must be preserved across subroutine calls."
      },
      "S21": {
        "long_name": "32-bit SIMD and VFP Register",
        "purpose": "Registers S16-S31 (D8-D15, Q4-Q7) must be preserved across subroutine calls."
      },
      "S22": {
        "long_name": "32-bit SIMD and VFP Register",
        "purpose": "Registers S16-S31 (D8-D15, Q4-Q7) must be preserved across subroutine calls."
      },
      "S23": {
        "long_name": "32-bit SIMD and VFP Register",
        "purpose": "Registers S16-S31 (D8-D15, Q4-Q7) must be preserved across subroutine calls."
      },
      "S24": {
        "long_name": "32-bit SIMD and VFP Register",
        "purpose": "Registers S16-S31 (D8-D15, Q4-Q7) must be preserved across subroutine calls."
      },
      "S25": {
        "long_name": "32-bit SIMD and VFP Register",
        "purpose": "Registers S16-S31 (D8-D15, Q4-Q7) must be preserved across subroutine calls."
      },
      "S26": {
        "long_name": "32-bit SIMD and VFP Register",
        "purpose": "Registers S16-S31 (D8-D15, Q4-Q7) must be preserved across subroutine calls."
      },
      "S27": {
        "long_name": "32-bit SIMD and VFP Register",
        "purpose": "Registers S16-S31 (D8-D15, Q4-Q7) must be preserved across subroutine calls."
      },
      "S28": {
        "long_name": "32-bit SIMD and VFP Register",
        "purpose": "Registers S16-S31 (D8-D15, Q4-Q7) must be preserved across subroutine calls."
      },
      "S29": {
        "long_name": "32-bit SIMD and VFP Register",
        "purpose": "Registers S16-S31 (D8-D15, Q4-Q7) must be preserved across subroutine calls."
      },
      "S3": {
        "long_name": "32-bit SIMD and VFP Register",
        "purpose": "Registers S0-S15 (D0-D7, Q0-Q3) do not need to be preserved (and can be used for\npassing arguments or returning results in standard procedure-call variants)."
      },
      "S30": {
        "long_name": "32-bit SIMD and VFP Register",
        "purpose": "Registers S16-S31 (D8-D15, Q4-Q7) must be preserved across subroutine calls."
      },
      "S31": {
        "long_name": "32-bit SIMD and VFP Register",
        "purpose": "Registers S16-S31 (D8-D15, Q4-Q7) must be preserved across subroutine calls."
      },
      "S4": {
        "long_name": "32-bit SIMD and VFP Register",
        "purpose": "Registers S0-S15 (D0-D7, Q0-Q3) do not need to be preserved (and can be used for\npassing arguments or returning results in standard procedure-call variants)."
      },
      "S5": {
        "long_name": "32-bit SIMD and VFP Register",
        "purpose": "Registers S0-S15 (D0-D7, Q0-Q3) do not need to be preserved (and can be used for\npassing arguments or returning results in standard procedure-call variants)."
      },
      "S6": {
        "long_name": "32-bit SIMD and VFP Register",
        "purpose": "Registers S0-S15 (D0-D7, Q0-Q3) do not need to be preserved (and can be used for\npassing arguments or returning results in standard procedure-call variants)."
      },
      "S7": {
        "long_name": "32-bit SIMD and VFP Register",
        "purpose": "Registers S0-S15 (D0-D7, Q0-Q3) do not need to be preserved (and can be used for\npassing arguments or returning results in standard procedure-call variants)."
      },
      "S8": {
        "long_name": "32-bit SIMD and VFP Register",
        "purpose": "Registers S0-S15 (D0-D7, Q0-Q3) do not need to be preserved (and can be used for\npassing arguments or returning results in standard procedure-call variants)."
      },
      "S9": {
        "long_name": "32-bit SIMD and VFP Register",
        "purpose": "Registers S0-S15 (D0-D7, Q0-Q3) do not need to be preserved (and can be used for\npassing arguments or returning results in standard procedure-call variants)."
      },
      "SP": {
        "long_name": "32-bit Stack Pointer",
        "purpose": "The processor uses SP as a pointer to the active stack."
      }
    },
    "encodings": {
      "MCRR|MRRC": {
        "AMEVCNTR0<n>": ["1111", "0xxx", "000x"],
        "AMEVCNTR1<n>": ["1111", "0xxx", "010x"],
        "CNTHPS_CVAL": ["1111", "0010", "1110"],
        "CNTHP_CVAL": ["1111", "0110", "1110"],
        "CNTHVS_CVAL": ["1111", "0011", "1110"],
        "CNTHV_CVAL": ["1111", "0011", "1110"],
        "CNTPCT": ["1111", "0000", "1110"],
        "CNTPCTSS": ["1111", "1000", "1110"],
        "CNTP_CVAL": ["1111", "0010", "1110"],
        "CNTVCT": ["1111", "0001", "1110"],
        "CNTVCTSS": ["1111", "1001", "1110"],
        "CNTVOFF": ["1111", "0100", "1110"],
        "CNTV_CVAL": ["1111", "0011", "1110"],
        "DBGDRAR": ["1110", "0000", "0001"],
        "DBGDSAR": ["1110", "0000", "0010"],
        "HTTBR": ["1111", "0100", "0010"],
        "ICC_ASGI1R": ["1111", "0001", "1100"],
        "ICC_SGI0R": ["1111", "0010", "1100"],
        "ICC_SGI1R": ["1111", "0000", "1100"],
        "PAR": ["1111", "0000", "0111"],
        "PMCCNTR": ["1111", "0000", "1001"],
        "TTBR0": ["1111", "0000", "0010"],
        "TTBR1": ["1111", "0001", "0010"],
        "VTTBR": ["1111", "0110", "0010"]
      },
      "MCR|MRC": {
        "ACTLR": ["1111", "000", "0001", "0000", "001"],
        "ACTLR2": ["1111", "000", "0001", "0000", "011"],
        "ADFSR": ["1111", "000", "0101", "0001", "000"],
        "AIDR": ["1111", "001", "0000", "0000", "111"],
        "AIFSR": ["1111", "000", "0101", "0001", "001"],
        "AMAIR0": ["1111", "000", "1010", "0011", "000"],
        "AMAIR1": ["1111", "000", "1010", "0011", "001"],
        "AMCFGR": ["1111", "000", "1101", "0010", "001"],
        "AMCGCR": ["1111", "000", "1101", "0010", "010"],
        "AMCNTENCLR0": ["1111", "000", "1101", "0010", "100"],
        "AMCNTENCLR1": ["1111", "000", "1101", "0011", "000"],
        "AMCNTENSET0": ["1111", "000", "1101", "0010", "101"],
        "AMCNTENSET1": ["1111", "000", "1101", "0011", "001"],
        "AMCR": ["1111", "000", "1101", "0010", "000"],
        "AMEVTYPER0<n>": ["1111", "000", "1101", "011x", "xxx"],
        "AMEVTYPER1<n>": ["1111", "000", "1101", "111x", "xxx"],
        "AMUSERENR": ["1111", "000", "1101", "0010", "011"],
        "ATS12NSOPR": ["1111", "000", "0111", "1000", "100"],
        "ATS12NSOPW": ["1111", "000", "0111", "1000", "101"],
        "ATS12NSOUR": ["1111", "000", "0111", "1000", "110"],
        "ATS12NSOUW": ["1111", "000", "0111", "1000", "111"],
        "ATS1CPR": ["1111", "000", "0111", "1000", "000"],
        "ATS1CPRP": ["1111", "000", "0111", "1001", "000"],
        "ATS1CPW": ["1111", "000", "0111", "1000", "001"],
        "ATS1CPWP": ["1111", "000", "0111", "1001", "001"],
        "ATS1CUR": ["1111", "000", "0111", "1000", "010"],
        "ATS1CUW": ["1111", "000", "0111", "1000", "011"],
        "ATS1HR": ["1111", "100", "0111", "1000", "000"],
        "ATS1HW": ["1111", "100", "0111", "1000", "001"],
        "BPIALL": ["1111", "000", "0111", "0101", "110"],
        "BPIALLIS": ["1111", "000", "0111", "0001", "110"],
        "BPIMVA": ["1111", "000", "0111", "0101", "111"],
        "CCSIDR": ["1111", "001", "0000", "0000", "000"],
        "CCSIDR2": ["1111", "001", "0000", "0000", "010"],
        "CFPRCTX": ["1111", "000", "0111", "0011", "100"],
        "CLIDR": ["1111", "001", "0000", "0000", "001"],
        "CNTFRQ": ["1111", "000", "1110", "0000", "000"],
        "CNTHCTL": ["1111", "100", "1110", "0001", "000"],
        "CNTHPS_CTL": ["1111", "000", "1110", "0010", "001"],
        "CNTHPS_TVAL": ["1111", "000", "1110", "0010", "000"],
        "CNTHP_CTL": ["1111", "100", "1110", "0010", "001"],
        "CNTHP_TVAL": ["1111", "100", "1110", "0010", "000"],
        "CNTHVS_CTL": ["1111", "000", "1110", "0011", "001"],
        "CNTHVS_TVAL": ["1111", "000", "1110", "0011", "000"],
        "CNTHV_CTL": ["1111", "000", "1110", "0011", "001"],
        "CNTHV_TVAL": ["1111", "000", "1110", "0011", "000"],
        "CNTKCTL": ["1111", "000", "1110", "0001", "000"],
        "CNTP_CTL": ["1111", "000", "1110", "0010", "001"],
        "CNTP_TVAL": ["1111", "000", "1110", "0010", "000"],
        "CNTV_CTL": ["1111", "000", "1110", "0011", "001"],
        "CNTV_TVAL": ["1111", "000", "1110", "0011", "000"],
        "CONTEXTIDR": ["1111", "000", "1101", "0000", "001"],
        "CP15DMB": ["1111", "000", "0111", "1010", "101"],
        "CP15DSB": ["1111", "000", "0111", "1010", "100"],
        "CP15ISB": ["1111", "000", "0111", "0101", "100"],
        "CPACR": ["1111", "000", "0001", "0000", "010"],
        "CPPRCTX": ["1111", "000", "0111", "0011", "111"],
        "CSSELR": ["1111", "010", "0000", "0000", "000"],
        "CTR": ["1111", "000", "0000", "0000", "001"],
        "DACR": ["1111", "000", "0011", "0000", "000"],
        "DBGAUTHSTATUS": ["1110", "000", "0111", "1110", "110"],
        "DBGBCR<n>": ["1110", "000", "0000", "xxxx", "101"],
        "DBGBVR<n>": ["1110", "000", "0000", "xxxx", "100"],
        "DBGBXVR<n>": ["1110", "000", "0001", "xxxx", "001"],
        "DBGCLAIMCLR": ["1110", "000", "0111", "1001", "110"],
        "DBGCLAIMSET": ["1110", "000", "0111", "1000", "110"],
        "DBGDCCINT": ["1110", "000", "0000", "0010", "000"],
        "DBGDEVID": ["1110", "000", "0111", "0010", "111"],
        "DBGDEVID1": ["1110", "000", "0111", "0001", "111"],
        "DBGDEVID2": ["1110", "000", "0111", "0000", "111"],
        "DBGDIDR": ["1110", "000", "0000", "0000", "000"],
        "DBGDRAR": ["1110", "000", "0001", "0000", "000"],
        "DBGDSAR": ["1110", "000", "0010", "0000", "000"],
        "DBGDSCRext": ["1110", "000", "0000", "0010", "010"],
        "DBGDSCRint": ["1110", "000", "0000", "0001", "000"],
        "DBGDTRRXext": ["1110", "000", "0000", "0000", "010"],
        "DBGDTRRXint": ["1110", "000", "0000", "0101", "000"],
        "DBGDTRTXext": ["1110", "000", "0000", "0011", "010"],
        "DBGDTRTXint": ["1110", "000", "0000", "0101", "000"],
        "DBGOSDLR": ["1110", "000", "0001", "0011", "100"],
        "DBGOSECCR": ["1110", "000", "0000", "0110", "010"],
        "DBGOSLAR": ["1110", "000", "0001", "0000", "100"],
        "DBGOSLSR": ["1110", "000", "0001", "0001", "100"],
        "DBGPRCR": ["1110", "000", "0001", "0100", "100"],
        "DBGVCR": ["1110", "000", "0000", "0111", "000"],
        "DBGWCR<n>": ["1110", "000", "0000", "xxxx", "111"],
        "DBGWFAR": ["1110", "000", "0000", "0110", "000"],
        "DBGWVR<n>": ["1110", "000", "0000", "xxxx", "110"],
        "DCCIMVAC": ["1111", "000", "0111", "1110", "001"],
        "DCCISW": ["1111", "000", "0111", "1110", "010"],
        "DCCMVAC": ["1111", "000", "0111", "1010", "001"],
        "DCCMVAU": ["1111", "000", "0111", "1011", "001"],
        "DCCSW": ["1111", "000", "0111", "1010", "010"],
        "DCIMVAC": ["1111", "000", "0111", "0110", "001"],
        "DCISW": ["1111", "000", "0111", "0110", "010"],
        "DFAR": ["1111", "000", "0110", "0000", "000"],
        "DFSR": ["1111", "000", "0101", "0000", "000"],
        "DISR": ["1111", "000", "1100", "0001", "001"],
        "DLR": ["1111", "011", "0100", "0101", "001"],
        "DSPSR": ["1111", "011", "0100", "0101", "000"],
        "DTLBIALL": ["1111", "000", "1000", "0110", "000"],
        "DTLBIASID": ["1111", "000", "1000", "0110", "010"],
        "DTLBIMVA": ["1111", "000", "1000", "0110", "001"],
        "DVPRCTX": ["1111", "000", "0111", "0011", "101"],
        "ERRIDR": ["1111", "000", "0101", "0011", "000"],
        "ERRSELR": ["1111", "000", "0101", "0011", "001"],
        "ERXADDR": ["1111", "000", "0101", "0100", "011"],
        "ERXADDR2": ["1111", "000", "0101", "0100", "111"],
        "ERXCTLR": ["1111", "000", "0101", "0100", "001"],
        "ERXCTLR2": ["1111", "000", "0101", "0100", "101"],
        "ERXFR": ["1111", "000", "0101", "0100", "000"],
        "ERXFR2": ["1111", "000", "0101", "0100", "100"],
        "ERXMISC0": ["1111", "000", "0101", "0101", "000"],
        "ERXMISC1": ["1111", "000", "0101", "0101", "001"],
        "ERXMISC2": ["1111", "000", "0101", "0101", "100"],
        "ERXMISC3": ["1111", "000", "0101", "0101", "101"],
        "ERXMISC4": ["1111", "000", "0101", "0101", "010"],
        "ERXMISC5": ["1111", "000", "0101", "0101", "011"],
        "ERXMISC6": ["1111", "000", "0101", "0101", "110"],
        "ERXMISC7": ["1111", "000", "0101", "0101", "111"],
        "ERXSTATUS": ["1111", "000", "0101", "0100", "010"],
        "FCSEIDR": ["1111", "000", "1101", "0000", "000"],
        "HACR": ["1111", "100", "0001", "0001", "111"],
        "HACTLR": ["1111", "100", "0001", "0000", "001"],
        "HACTLR2": ["1111", "100", "0001", "0000", "011"],
        "HADFSR": ["1111", "100", "0101", "0001", "000"],
        "HAIFSR": ["1111", "100", "0101", "0001", "001"],
        "HAMAIR0": ["1111", "100", "1010", "0011", "000"],
        "HAMAIR1": ["1111", "100", "1010", "0011", "001"],
        "HCPTR": ["1111", "100", "0001", "0001", "010"],
        "HCR": ["1111", "100", "0001", "0001", "000"],
        "HCR2": ["1111", "100", "0001", "0001", "100"],
        "HDCR": ["1111", "100", "0001", "0001", "001"],
        "HDFAR": ["1111", "100", "0110", "0000", "000"],
        "HIFAR": ["1111", "100", "0110", "0000", "010"],
        "HMAIR0": ["1111", "100", "1010", "0010", "000"],
        "HMAIR1": ["1111", "100", "1010", "0010", "001"],
        "HPFAR": ["1111", "100", "0110", "0000", "100"],
        "HRMR": ["1111", "100", "1100", "0000", "010"],
        "HSCTLR": ["1111", "100", "0001", "0000", "000"],
        "HSR": ["1111", "100", "0101", "0010", "000"],
        "HSTR": ["1111", "100", "0001", "0001", "011"],
        "HTCR": ["1111", "100", "0010", "0000", "010"],
        "HTPIDR": ["1111", "100", "1101", "0000", "010"],
        "HTRFCR": ["1111", "100", "0001", "0010", "001"],
        "HVBAR": ["1111", "100", "1100", "0000", "000"],
        "ICC_AP0R<n>": ["1111", "000", "1100", "1000", "1xx"],
        "ICC_AP1R<n>": ["1111", "000", "1100", "1001", "0xx"],
        "ICC_BPR0": ["1111", "000", "1100", "1000", "011"],
        "ICC_BPR1": ["1111", "000", "1100", "1100", "011"],
        "ICC_CTLR": ["1111", "000", "1100", "1100", "100"],
        "ICC_DIR": ["1111", "000", "1100", "1011", "001"],
        "ICC_EOIR0": ["1111", "000", "1100", "1000", "001"],
        "ICC_EOIR1": ["1111", "000", "1100", "1100", "001"],
        "ICC_HPPIR0": ["1111", "000", "1100", "1000", "010"],
        "ICC_HPPIR1": ["1111", "000", "1100", "1100", "010"],
        "ICC_HSRE": ["1111", "100", "1100", "1001", "101"],
        "ICC_IAR0": ["1111", "000", "1100", "1000", "000"],
        "ICC_IAR1": ["1111", "000", "1100", "1100", "000"],
        "ICC_IGRPEN0": ["1111", "000", "1100", "1100", "110"],
        "ICC_IGRPEN1": ["1111", "000", "1100", "1100", "111"],
        "ICC_MCTLR": ["1111", "110", "1100", "1100", "100"],
        "ICC_MGRPEN1": ["1111", "110", "1100", "1100", "111"],
        "ICC_MSRE": ["1111", "110", "1100", "1100", "101"],
        "ICC_PMR": ["1111", "000", "0100", "0110", "000"],
        "ICC_RPR": ["1111", "000", "1100", "1011", "011"],
        "ICC_SRE": ["1111", "000", "1100", "1100", "101"],
        "ICH_AP0R<n>": ["1111", "100", "1100", "1000", "0xx"],
        "ICH_AP1R<n>": ["1111", "100", "1100", "1001", "0xx"],
        "ICH_EISR": ["1111", "100", "1100", "1011", "011"],
        "ICH_ELRSR": ["1111", "100", "1100", "1011", "101"],
        "ICH_HCR": ["1111", "100", "1100", "1011", "000"],
        "ICH_LR<n>": ["1111", "100", "1100", "110x", "xxx"],
        "ICH_LRC<n>": ["1111", "100", "1100", "111x", "xxx"],
        "ICH_MISR": ["1111", "100", "1100", "1011", "010"],
        "ICH_VMCR": ["1111", "100", "1100", "1011", "111"],
        "ICH_VTR": ["1111", "100", "1100", "1011", "001"],
        "ICIALLU": ["1111", "000", "0111", "0101", "000"],
        "ICIALLUIS": ["1111", "000", "0111", "0001", "000"],
        "ICIMVAU": ["1111", "000", "0111", "0101", "001"],
        "ICV_AP0R<n>": ["1111", "000", "1100", "1000", "1xx"],
        "ICV_AP1R<n>": ["1111", "000", "1100", "1001", "0xx"],
        "ICV_BPR0": ["1111", "000", "1100", "1000", "011"],
        "ICV_BPR1": ["1111", "000", "1100", "1100", "011"],
        "ICV_CTLR": ["1111", "000", "1100", "1100", "100"],
        "ICV_DIR": ["1111", "000", "1100", "1011", "001"],
        "ICV_EOIR0": ["1111", "000", "1100", "1000", "001"],
        "ICV_EOIR1": ["1111", "000", "1100", "1100", "001"],
        "ICV_HPPIR0": ["1111", "000", "1100", "1000", "010"],
        "ICV_HPPIR1": ["1111", "000", "1100", "1100", "010"],
        "ICV_IAR0": ["1111", "000", "1100", "1000", "000"],
        "ICV_IAR1": ["1111", "000", "1100", "1100", "000"],
        "ICV_IGRPEN0": ["1111", "000", "1100", "1100", "110"],
        "ICV_IGRPEN1": ["1111", "000", "1100", "1100", "111"],
        "ICV_PMR": ["1111", "000", "0100", "0110", "000"],
        "ICV_RPR": ["1111", "000", "1100", "1011", "011"],
        "ID_AFR0": ["1111", "000", "0000", "0001", "011"],
        "ID_DFR0": ["1111", "000", "0000", "0001", "010"],
        "ID_DFR1": ["1111", "000", "0000", "0011", "101"],
        "ID_ISAR0": ["1111", "000", "0000", "0010", "000"],
        "ID_ISAR1": ["1111", "000", "0000", "0010", "001"],
        "ID_ISAR2": ["1111", "000", "0000", "0010", "010"],
        "ID_ISAR3": ["1111", "000", "0000", "0010", "011"],
        "ID_ISAR4": ["1111", "000", "0000", "0010", "100"],
        "ID_ISAR5": ["1111", "000", "0000", "0010", "101"],
        "ID_ISAR6": ["1111", "000", "0000", "0010", "111"],
        "ID_MMFR0": ["1111", "000", "0000", "0001", "100"],
        "ID_MMFR1": ["1111", "000", "0000", "0001", "101"],
        "ID_MMFR2": ["1111", "000", "0000", "0001", "110"],
        "ID_MMFR3": ["1111", "000", "0000", "0001", "111"],
        "ID_MMFR4": ["1111", "000", "0000", "0010", "110"],
        "ID_MMFR5": ["1111", "000", "0000", "0011", "110"],
        "ID_PFR0": ["1111", "000", "0000", "0001", "000"],
        "ID_PFR1": ["1111", "000", "0000", "0001", "001"],
        "ID_PFR2": ["1111", "000", "0000", "0011", "100"],
        "IFAR": ["1111", "000", "0110", "0000", "010"],
        "IFSR": ["1111", "000", "0101", "0000", "001"],
        "ISR": ["1111", "000", "1100", "0001", "000"],
        "ITLBIALL": ["1111", "000", "1000", "0101", "000"],
        "ITLBIASID": ["1111", "000", "1000", "0101", "010"],
        "ITLBIMVA": ["1111", "000", "1000", "0101", "001"],
        "JIDR": ["1110", "111", "0000", "0000", "000"],
        "JMCR": ["1110", "111", "0010", "0000", "000"],
        "JOSCR": ["1110", "111", "0001", "0000", "000"],
        "MAIR0": ["1111", "000", "1010", "0010", "000"],
        "MAIR1": ["1111", "000", "1010", "0010", "001"],
        "MIDR": ["1111", "000", "0000", "0000", "000"],
        "MPIDR": ["1111", "000", "0000", "0000", "101"],
        "MVBAR": ["1111", "000", "1100", "0000", "001"],
        "NMRR": ["1111", "000", "1010", "0010", "001"],
        "NSACR": ["1111", "000", "0001", "0001", "010"],
        "PAR": ["1111", "000", "0111", "0100", "000"],
        "PMCCFILTR": ["1111", "000", "1110", "1111", "111"],
        "PMCCNTR": ["1111", "000", "1001", "1101", "000"],
        "PMCEID0": ["1111", "000", "1001", "1100", "110"],
        "PMCEID1": ["1111", "000", "1001", "1100", "111"],
        "PMCEID2": ["1111", "000", "1001", "1110", "100"],
        "PMCEID3": ["1111", "000", "1001", "1110", "101"],
        "PMCNTENCLR": ["1111", "000", "1001", "1100", "010"],
        "PMCNTENSET": ["1111", "000", "1001", "1100", "001"],
        "PMCR": ["1111", "000", "1001", "1100", "000"],
        "PMEVCNTR<n>": ["1111", "000", "1110", "10xx", "xxx"],
        "PMEVTYPER<n>": ["1111", "000", "1110", "11xx", "xxx"],
        "PMINTENCLR": ["1111", "000", "1001", "1110", "010"],
        "PMINTENSET": ["1111", "000", "1001", "1110", "001"],
        "PMMIR": ["1111", "000", "1001", "1110", "110"],
        "PMOVSR": ["1111", "000", "1001", "1100", "011"],
        "PMOVSSET": ["1111", "000", "1001", "1110", "011"],
        "PMSELR": ["1111", "000", "1001", "1100", "101"],
        "PMSWINC": ["1111", "000", "1001", "1100", "100"],
        "PMUSERENR": ["1111", "000", "1001", "1110", "000"],
        "PMXEVCNTR": ["1111", "000", "1001", "1101", "010"],
        "PMXEVTYPER": ["1111", "000", "1001", "1101", "001"],
        "PRRR": ["1111", "000", "1010", "0010", "000"],
        "REVIDR": ["1111", "000", "0000", "0000", "110"],
        "RMR": ["1111", "000", "1100", "0000", "010"],
        "RVBAR": ["1111", "000", "1100", "0000", "001"],
        "SCR": ["1111", "000", "0001", "0001", "000"],
        "SCTLR": ["1111", "000", "0001", "0000", "000"],
        "SDCR": ["1111", "000", "0001", "0011", "001"],
        "SDER": ["1111", "000", "0001", "0001", "001"],
        "TCMTR": ["1111", "000", "0000", "0000", "010"],
        "TLBIALL": ["1111", "000", "1000", "0111", "000"],
        "TLBIALLH": ["1111", "100", "1000", "0111", "000"],
        "TLBIALLHIS": ["1111", "100", "1000", "0011", "000"],
        "TLBIALLIS": ["1111", "000", "1000", "0011", "000"],
        "TLBIALLNSNH": ["1111", "100", "1000", "0111", "100"],
        "TLBIALLNSNHIS": ["1111", "100", "1000", "0011", "100"],
        "TLBIASID": ["1111", "000", "1000", "0111", "010"],
        "TLBIASIDIS": ["1111", "000", "1000", "0011", "010"],
        "TLBIIPAS2": ["1111", "100", "1000", "0100", "001"],
        "TLBIIPAS2IS": ["1111", "100", "1000", "0000", "001"],
        "TLBIIPAS2L": ["1111", "100", "1000", "0100", "101"],
        "TLBIIPAS2LIS": ["1111", "100", "1000", "0000", "101"],
        "TLBIMVA": ["1111", "000", "1000", "0111", "001"],
        "TLBIMVAA": ["1111", "000", "1000", "0111", "011"],
        "TLBIMVAAIS": ["1111", "000", "1000", "0011", "011"],
        "TLBIMVAAL": ["1111", "000", "1000", "0111", "111"],
        "TLBIMVAALIS": ["1111", "000", "1000", "0011", "111"],
        "TLBIMVAH": ["1111", "100", "1000", "0111", "001"],
        "TLBIMVAHIS": ["1111", "100", "1000", "0011", "001"],
        "TLBIMVAIS": ["1111", "000", "1000", "0011", "001"],
        "TLBIMVAL": ["1111", "000", "1000", "0111", "101"],
        "TLBIMVALH": ["1111", "100", "1000", "0111", "101"],
        "TLBIMVALHIS": ["1111", "100", "1000", "0011", "101"],
        "TLBIMVALIS": ["1111", "000", "1000", "0011", "101"],
        "TLBTR": ["1111", "000", "0000", "0000", "011"],
        "TPIDRPRW": ["1111", "000", "1101", "0000", "100"],
        "TPIDRURO": ["1111", "000", "1101", "0000", "011"],
        "TPIDRURW": ["1111", "000", "1101", "0000", "010"],
        "TRFCR": ["1111", "000", "0001", "0010", "001"],
        "TTBCR": ["1111", "000", "0010", "0000", "010"],
        "TTBCR2": ["1111", "000", "0010", "0000", "011"],
        "TTBR0": ["1111", "000", "0010", "0000", "000"],
        "TTBR1": ["1111", "000", "0010", "0000", "001"],
        "VBAR": ["1111", "000", "1100", "0000", "000"],
        "VDFSR": ["1111", "100", "0101", "0010", "011"],
        "VDISR": ["1111", "100", "1100", "0001", "001"],
        "VMPIDR": ["1111", "100", "0000", "0000", "101"],
        "VPIDR": ["1111", "100", "0000", "0000", "000"],
        "VTCR": ["1111", "100", "0010", "0001", "010"]
      },
      "VMRS|VMSR": {
        "FPEXC": ["1000"],
        "FPSCR": ["0001"],
        "FPSID": ["0000"],
        "MVFR0": ["0111"],
        "MVFR1": ["0110"],
        "MVFR2": ["0101"]
      }
    },
    "instructions": {
      "ATS12NSOPR": {
        "long_name": "Address Translate Stages 1 and 2 Non-secure Only PL1 Read",
        "purpose": "Performs stage 1 and 2 address translations as defined for PL1 and the Non-\nsecure state, with permissions as if reading from the given virtual address.\n\nbits [0:31] - Input address for translation. The resulting address can be read\n              from the PAR. This System instruction takes a VA as input. The\n              resulting address is the PA that is the output address of the\n              stage 2 translation."
      },
      "ATS12NSOPW": {
        "long_name": "Address Translate Stages 1 and 2 Non-secure Only PL1 Write",
        "purpose": "Performs stage 1 and 2 address translations as defined for PL1 and the Non-\nsecure state, with permissions as if writing to the given virtual address.\n\nbits [0:31] - Input address for translation. The resulting address can be read\n              from the PAR. This System instruction takes a VA as input. The\n              resulting address is the PA that is the output address of the\n              stage 2 translation."
      },
      "ATS12NSOUR": {
        "long_name": "Address Translate Stages 1 and 2 Non-secure Only Unprivileged Read",
        "purpose": "Performs stage 1 and 2 address translations as defined for PL0 and the Non-\nsecure state, with permissions as if reading from the given virtual address.\n\nbits [0:31] - Input address for translation. The resulting address can be read\n              from the PAR. This System instruction takes a VA as input. The\n              resulting address is the PA that is the output address of the\n              stage 2 translation."
      },
      "ATS12NSOUW": {
        "long_name": "Address Translate Stages 1 and 2 Non-secure Only Unprivileged Write",
        "purpose": "Performs stage 1 and 2 address translations as defined for PL0 and the Non-\nsecure state, with permissions as if writing to the given virtual address.\n\nbits [0:31] - Input address for translation. The resulting address can be read\n              from the PAR. This System instruction takes a VA as input. The\n              resulting address is the PA that is the output address of the\n              stage 2 translation."
      },
      "ATS1CPR": {
        "long_name": "Address Translate Stage 1 Current state PL1 Read",
        "purpose": "Performs stage 1 address translation as defined for PL1 and the current Security\nstate, with permissions as if reading from the given virtual address.\n\nbits [0:31] - Input address for translation. The resulting address can be read\n              from the PAR. This System instruction takes a VA as input. If EL2\n              is implemented and enabled in the current Security state, the\n              resulting address is the IPA that is the output address of the\n              stage 1 translation. Otherwise, the resulting address is a PA."
      },
      "ATS1CPRP": {
        "long_name": "Address Translate Stage 1 Current state PL1 Read PAN",
        "purpose": "Performs a stage 1 address translation at PL1 and in the current Security state,\nwhere the value of PSTATE.PAN determines if a read from a location will generate\na permission fault for a privileged access.\n\nbits [0:31] - Input address for translation. The resulting address can be read\n              from the PAR. This System instruction takes a VA as input. If EL2\n              is implemented and enabled in the current Security state, the\n              resulting address is the IPA that is the output address of the\n              stage 1 translation. Otherwise, the resulting address is a PA."
      },
      "ATS1CPW": {
        "long_name": "Address Translate Stage 1 Current state PL1 Write",
        "purpose": "Performs stage 1 address translation as defined for PL1 and the current Security\nstate, with permissions as if writing to the given virtual address.\n\nbits [0:31] - Input address for translation. The resulting address can be read\n              from the PAR. This System instruction takes a VA as input. If EL2\n              is implemented and enabled in the current Security state, the\n              resulting address is the IPA that is the output address of the\n              stage 1 translation. Otherwise, the resulting address is a PA."
      },
      "ATS1CPWP": {
        "long_name": "Address Translate Stage 1 Current state PL1 Write PAN",
        "purpose": "Performs a stage 1 address translation at PL1 and in the current Security state,\nwhere the value of PSTATE.PAN determines if a write to the location will\ngenerate a permission fault for a privileged access.\n\nbits [0:31] - Input address for translation. The resulting address can be read\n              from the PAR. This System instruction takes a VA as input. If EL2\n              is implemented and enabled in the current Security state, the\n              resulting address is the IPA that is the output address of the\n              stage 1 translation. Otherwise, the resulting address is a PA."
      },
      "ATS1CUR": {
        "long_name": "Address Translate Stage 1 Current state Unprivileged Read",
        "purpose": "Performs stage 1 address translation as defined for PL0 and the current Security\nstate, with permissions as if reading from the given virtual address.\n\nbits [0:31] - Input address for translation. The resulting address can be read\n              from the PAR. This System instruction takes a VA as input. If EL2\n              is implemented and enabled in the current Security state, the\n              resulting address is the IPA that is the output address of the\n              stage 1 translation. Otherwise, the resulting address is a PA."
      },
      "ATS1CUW": {
        "long_name": "Address Translate Stage 1 Current state Unprivileged Write",
        "purpose": "Performs stage 1 address translation as defined for PL0 and the current Security\nstate, with permissions as if writing to the given virtual address.\n\nbits [0:31] - Input address for translation. The resulting address can be read\n              from the PAR. This System instruction takes a VA as input. If EL2\n              is implemented and enabled in the current Security state, the\n              resulting address is the IPA that is the output address of the\n              stage 1 translation. Otherwise, the resulting address is a PA."
      },
      "ATS1HR": {
        "long_name": "Address Translate Stage 1 Hyp mode Read",
        "purpose": "Performs stage 1 address translation as defined for PL2 and the Non-secure\nstate, with permissions as if reading from the given virtual address.\n\nbits [0:31] - Input address for translation. The resulting address can be read\n              from the PAR. This System instruction takes a VA as input. The\n              resulting address is the PA that is the output address of the\n              translation."
      },
      "ATS1HW": {
        "long_name": "Address Translate Stage 1 Hyp mode Write",
        "purpose": "Performs stage 1 address translation as defined for PL2 and the Non-secure\nstate, with permissions as if writing to the given virtual address.\n\nbits [0:31] - Input address for translation. The resulting address can be read\n              from the PAR. This System instruction takes a VA as input. The\n              resulting address is the PA that is the output address of the\n              translation."
      },
      "BPIALL": {
        "long_name": "Branch Predictor Invalidate All",
        "purpose": "Invalidate all entries from branch predictors."
      },
      "BPIALLIS": {
        "long_name": "Branch Predictor Invalidate All, Inner Shareable",
        "purpose": "Invalidate all entries from branch predictors Inner Shareable."
      },
      "BPIMVA": {
        "long_name": "Branch Predictor Invalidate by VA",
        "purpose": "Invalidate virtual address from branch predictors.\n\nbits [0:31] - Virtual address to use."
      },
      "CFPRCTX": {
        "long_name": "Control Flow Prediction Restriction by Context",
        "purpose": "Control Flow Prediction Restriction by Context applies to all Control Flow\nPrediction Resources that predict execution based on information gathered within\nthe target execution context or contexts.\n\nWhen this instruction is complete and synchronized, control flow prediction does\nnot permit later speculative execution within the target execution context to be\nobservable through side channels.\n\nThis  instruction is guaranteed to be complete following a DSB that covers both\nread and write behavior on the same PE as executed the original restriction\ninstruction, and a subsequent context synchronization event is required to\nensure that the effect of the completion of the instructions is synchronized to\nthe current execution.\n\nThis instruction does not require the invalidation of prediction structures so\nlong as the behavior described for completion of this instruction is met by the\nimplementation.On some implementations the instruction is likely to take a\nsignificant number of cycles to execute. This instruction is expected to be used\nvery rarely, such as on the roll-over of an ASID or VMID, but should not be used\non every context switch.\n\nGVMID, bit [27]    - Execution of this instruction applies to all VMIDs or a\n                     specified VMID.\nNS, bit [26]       - Security State.\nEL, bits [24:25]   - Exception Level.\nVMID, bits [16:23] - Only applies when bit[27] is 0 and the target execution\n                     context is either.\nGASID, bit [8]     - Execution of this instruction applies to all ASIDs or a\n                     specified ASID.\nASID, bits [0:7]   - Only applies for an EL0 target execution context and when\n                     bit[8] is 0."
      },
      "CP15DMB": {
        "long_name": "Data Memory Barrier System instruction",
        "purpose": "Performs a Data Memory Barrier.\n\nArm deprecates any use of this System instruction, and strongly recommends that\nsoftware use the DMB instruction instead."
      },
      "CP15DSB": {
        "long_name": "Data Synchronization Barrier System instruction",
        "purpose": "Performs a Data Synchronization Barrier.\n\nArm deprecates any use of this System instruction, and strongly recommends that\nsoftware use the DSB instruction instead."
      },
      "CP15ISB": {
        "long_name": "Instruction Synchronization Barrier System instruction",
        "purpose": "Performs an Instruction Synchronization Barrier.\n\nArm deprecates any use of this System instruction, and strongly recommends that\nsoftware use the ISB instruction instead."
      },
      "CPPRCTX": {
        "long_name": "Cache Prefetch Prediction Restriction by Context",
        "purpose": "Cache Prefetch Prediction Restriction by Context applies to all Cache Allocation\nResources that predict cache allocations based on information gathered within\nthe target execution context or contexts.\n\nWhen this instruction is complete and synchronized, cache prefetch prediction\ndoes not permit later speculative execution within the target execution context\nto be observable through side channels.\n\nThis instruction applies to all:\n\n  - Instruction caches.\n  - Data caches.\n  - TLB prefetching hardware used by the executing PE that applies to the\nsupplied context or contexts.\n\nThis  instruction is guaranteed to be complete following a DSB that covers both\nread and write behavior on the same PE as executed the original restriction\ninstruction, and a subsequent context synchronization event is required to\nensure that the effect of the completion of the instructions is synchronized to\nthe current execution.\n\nThis instruction does not require the invalidation of Cache Allocation Resources\nso long as the behavior described for completion of this instruction is met by\nthe implementation.On some implementations the instruction is likely to take a\nsignificant number of cycles to execute. This instruction is expected to be used\nvery rarely, such as on the roll-over of an ASID or VMID, but should not be used\non every context switch.\n\nGVMID, bit [27]    - Execution of this instruction applies to all VMIDs or a\n                     specified VMID.\nNS, bit [26]       - Security State.\nEL, bits [24:25]   - Exception Level.\nVMID, bits [16:23] - Only applies when bit[27] is 0 and the target execution\n                     context is either.\nGASID, bit [8]     - Execution of this instruction applies to all ASIDs or a\n                     specified ASID.\nASID, bits [0:7]   - Only applies for an EL0 target execution context and when\n                     bit[8] is 0."
      },
      "DCCIMVAC": {
        "long_name": "Data Cache line Clean and Invalidate by VA to PoC",
        "purpose": "Clean and Invalidate data or unified cache line by virtual address to PoC.\n\nbits [0:31] - Virtual address to use. No alignment restrictions apply to this\n              VA."
      },
      "DCCISW": {
        "long_name": "Data Cache line Clean and Invalidate by Set/Way",
        "purpose": "Clean and Invalidate data or unified cache line by set/way.\n\nSetWay, bits [4:31] - Contains two fields:\n                        - Way, bits[31:32-A], the number of the way to operate\n                      on.\n                        - Set, bits[B-1:L], the number of the set to operate on.\n                      Bits[L-1:4] are res0. A = Log_2(ASSOCIATIVITY), L =\n                      Log_2(LINELEN), B = (L + S), S = Log_2(NSETS).\n                      ASSOCIATIVITY, LINELEN (line length, in bytes), and NSETS\n                      (number of sets) have their usual meanings and are the\n                      values for the cache level being operated on. The values\n                      of A and S are rounded up to the next integer.\nLevel, bits [1:3]   - Cache level to operate on, minus 1. For example, this\n                      field is 0 for operations on L1 cache, or 1 for operations\n                      on L2 cache."
      },
      "DCCMVAC": {
        "long_name": "Data Cache line Clean by VA to PoC",
        "purpose": "Clean data or unified cache line by virtual address to PoC.\n\nbits [0:31] - Virtual address to use. No alignment restrictions apply to this\n              VA."
      },
      "DCCMVAU": {
        "long_name": "Data Cache line Clean by VA to PoU",
        "purpose": "Clean data or unified cache line by virtual address to PoU.\n\nbits [0:31] - Virtual address to use. No alignment restrictions apply to this\n              VA."
      },
      "DCCSW": {
        "long_name": "Data Cache line Clean by Set/Way",
        "purpose": "Clean data or unified cache line by set/way.\n\nSetWay, bits [4:31] - Contains two fields:\n                        - Way, bits[31:32-A], the number of the way to operate\n                      on.\n                        - Set, bits[B-1:L], the number of the set to operate on.\n                      Bits[L-1:4] are res0. A = Log_2(ASSOCIATIVITY), L =\n                      Log_2(LINELEN), B = (L + S), S = Log_2(NSETS).\n                      ASSOCIATIVITY, LINELEN (line length, in bytes), and NSETS\n                      (number of sets) have their usual meanings and are the\n                      values for the cache level being operated on. The values\n                      of A and S are rounded up to the next integer.\nLevel, bits [1:3]   - Cache level to operate on, minus 1. For example, this\n                      field is 0 for operations on L1 cache, or 1 for operations\n                      on L2 cache."
      },
      "DCIMVAC": {
        "long_name": "Data Cache line Invalidate by VA to PoC",
        "purpose": "Invalidate data or unified cache line by virtual address to PoC.\n\nbits [0:31] - Virtual address to use. No alignment restrictions apply to this\n              VA."
      },
      "DCISW": {
        "long_name": "Data Cache line Invalidate by Set/Way",
        "purpose": "Invalidate data or unified cache line by set/way.\n\nSetWay, bits [4:31] - Contains two fields:\n                        - Way, bits[31:32-A], the number of the way to operate\n                      on.\n                        - Set, bits[B-1:L], the number of the set to operate on.\n                      Bits[L-1:4] are res0. A = Log_2(ASSOCIATIVITY), L =\n                      Log_2(LINELEN), B = (L + S), S = Log_2(NSETS).\n                      ASSOCIATIVITY, LINELEN (line length, in bytes), and NSETS\n                      (number of sets) have their usual meanings and are the\n                      values for the cache level being operated on. The values\n                      of A and S are rounded up to the next integer.\nLevel, bits [1:3]   - Cache level to operate on, minus 1. For example, this\n                      field is 0 for operations on L1 cache, or 1 for operations\n                      on L2 cache."
      },
      "DTLBIALL": {
        "long_name": "Data TLB Invalidate All",
        "purpose": "Invalidate all cached copies of translation table entries from data TLBs that\nare from any level of the translation table walk. The entries that are\ninvalidated are as follows:\n\n  - If executed at EL1, all entries that:\n    - Would be required for the EL1&0 translation regime.\n    - Match the current VMID, if EL2 is implemented and enabled in the current\nSecurity state.\n  - If executed in Secure state when EL3 is using AArch32, all entries that\nwould be required for the Secure PL1&0 translation regime.\n  - If executed at EL2, and if EL2 is enabled in the current Security state, the\nstage 1 or stage 2 translation table entries that would be required for the Non-\nsecure PL1&0 translation regime and matches the current VMID.\n\nThe invalidation only applies to the PE that executes this System instruction.\n\nArm deprecates the use of this System instruction. It is only provided for\nbackwards compatibility with earlier versions of the Arm architecture."
      },
      "DTLBIASID": {
        "long_name": "Data TLB Invalidate by ASID match",
        "purpose": "Invalidate all cached copies of translation table entries from data TLBs that\nmeet the following requirements:\n\n  - The entry is a stage 1 translation table entry.\n  - The entry would be used for the specified ASID, and either:\n    - Is from a level of lookup above the final level.\n    - Is a non-global entry from the final level of lookup.\n  - If EL2 is implemented and enabled in the current Security state, the entry\nwould be used with the current VMID.\n\nFrom the entries that match these requirements, the entries that are invalidated\nare required for the following translation regime:\n\n  - If executed at Secure EL1 when EL3 is using AArch64, the Secure EL1&0\ntranslation regime.\n  - If executed in Secure state when EL3 is using AArch32, the Secure PL1&0\ntranslation regime.\n  - If executed in Non-secure state, the Non-secure PL1&0 translation regime.\n\nThe invalidation only applies to the PE that executes this System instruction.\n\nArm deprecates the use of this System instruction. It is only provided for\nbackwards compatibility with earlier versions of the Arm architecture.\n\nASID, bits [0:7] - ASID value to match. Any TLB entries for non-global pages\n                   that match the ASID values will be affected by this System\n                   instruction."
      },
      "DTLBIMVA": {
        "long_name": "Data TLB Invalidate by VA",
        "purpose": "Invalidate all cached copies of translation table entries from data TLBs that\nmeet the following requirements:\n\n  - The entry is a stage 1 translation table entry.\n  - The entry would be used to translate the specified address, and one of the\nfollowing applies:\n    - The entry is from a level of lookup above the final level and matches the\nspecified ASID.\n    - The entry is a global entry from the final level of lookup.\n    - The entry is a non-global entry from the final level of lookup that\nmatches the specified ASID.\n  - If EL2 is implemented and enabled in the current Security state, the entry\nwould be used with the current VMID.\n\nFrom the entries that match these requirements, the entries that are invalidated\nare required for the following translation regime:\n\n  - If executed at Secure EL1 when EL3 is using AArch64, the Secure EL1&0\ntranslation regime.\n  - If executed in Secure state when EL3 is using AArch32, the Secure PL1&0\ntranslation regime.\n  - If executed in Non-secure state, the Non-secure PL1&0 translation regime.\n\nThe invalidation only applies to the PE that executes this System instruction.\n\nArm deprecates the use of this System instruction. It is only provided for\nbackwards compatibility with earlier versions of the Arm architecture.\n\nVA, bits [12:31] - Virtual address to match.\nASID, bits [0:7] - ASID value to match."
      },
      "DVPRCTX": {
        "long_name": "Data Value Prediction Restriction by Context",
        "purpose": "Data Value Prediction Restriction by Context applies to all Data Value\nPrediction Resources that predict execution based on information gathered within\nthe target execution context or contexts.\n\nWhen this instruction is complete and synchronized, data value prediction does\nnot permit later speculative execution within the target execution context to be\nobservable through side channels.\n\nThis  instruction is guaranteed to be complete following a DSB that covers both\nread and write behavior on the same PE as executed the original restriction\ninstruction, and a subsequent context synchronization event is required to\nensure that the effect of the completion of the instructions is synchronized to\nthe current execution.\n\nThis instruction does not require the invalidation of prediction structures so\nlong as the behavior described for completion of this instruction is met by the\nimplementation.On some implementations the instruction is likely to take a\nsignificant number of cycles to execute. This instruction is expected to be used\nvery rarely, such as on the roll-over of an ASID or VMID, but should not be used\non every context switch.\n\nGVMID, bit [27]    - Execution of this instruction applies to all VMIDs or a\n                     specified VMID.\nNS, bit [26]       - Security State.\nEL, bits [24:25]   - Exception Level.\nVMID, bits [16:23] - Only applies when bit[27] is 0 and the target execution\n                     context is either.\nGASID, bit [8]     - Execution of this instruction applies to all ASIDs or a\n                     specified ASID.\nASID, bits [0:7]   - Only applies for an EL0 target execution context and when\n                     bit[8] is 0."
      },
      "ICIALLU": {
        "long_name": "Instruction Cache Invalidate All to PoU",
        "purpose": "Invalidate all instruction caches to PoU. If branch predictors are\narchitecturally visible, also flush branch predictors."
      },
      "ICIALLUIS": {
        "long_name": "Instruction Cache Invalidate All to PoU, Inner Shareable",
        "purpose": "Invalidate all instruction caches Inner Shareable to PoU. If branch predictors\nare architecturally visible, also flush branch predictors."
      },
      "ICIMVAU": {
        "long_name": "Instruction Cache line Invalidate by VA to PoU",
        "purpose": "Invalidate instruction cache line by virtual address to PoU.\n\nbits [0:31] - Virtual address to use. No alignment restrictions apply to this\n              VA."
      },
      "ITLBIALL": {
        "long_name": "Instruction TLB Invalidate All",
        "purpose": "Invalidate all cached copies of translation table entries from instruction TLBs\nthat are from any level of the translation table walk. The entries that are\ninvalidated are as follows:\n\n  - If executed at EL1, all entries that:\n    - Would be required for the EL1&0 translation regime.\n    - Match the current VMID, if EL2 is implemented and enabled in the current\nSecurity state.\n  - If executed in Secure state when EL3 is using AArch32, all entries that\nwould be required for the Secure PL1&0 translation regime.\n  - If executed at EL2, and if EL2 is enabled in the current Security state, the\nstage 1 or stage 2 translation table entries that would be required for the Non-\nsecure PL1&0 translation regime and matches the current VMID.\n\nThe invalidation only applies to the PE that executes this System instruction.\n\nArm deprecates the use of this System instruction. It is only provided for\nbackwards compatibility with earlier versions of the Arm architecture."
      },
      "ITLBIASID": {
        "long_name": "Instruction TLB Invalidate by ASID match",
        "purpose": "Invalidate all cached copies of translation table entries from instruction TLBs\nthat meet the following requirements:\n\n  - The entry is a stage 1 translation table entry.\n  - The entry would be used for the specified ASID, and either:\n    - Is from a level of lookup above the final level.\n    - Is a non-global entry from the final level of lookup.\n  - If EL2 is implemented and enabled in the current Security state, the entry\nwould be used with the current VMID.\n\nFrom the entries that match these requirements, the entries that are invalidated\nare required for the following translation regime:\n\n  - If executed at Secure EL1 when EL3 is using AArch64, the Secure EL1&0\ntranslation regime.\n  - If executed in Secure state when EL3 is using AArch32, the Secure PL1&0\ntranslation regime.\n  - If executed in Non-secure state, the Non-secure PL1&0 translation regime.\n\nThe invalidation only applies to the PE that executes this System instruction.\n\nArm deprecates the use of this System instruction. It is only provided for\nbackwards compatibility with earlier versions of the Arm architecture.\n\nASID, bits [0:7] - ASID value to match. Any TLB entries for non-global pages\n                   that match the ASID values will be affected by this System\n                   instruction."
      },
      "ITLBIMVA": {
        "long_name": "Instruction TLB Invalidate by VA",
        "purpose": "Invalidate all cached copies of translation table entries from instruction TLBs\nthat meet the following requirements:\n\n  - The entry is a stage 1 translation table entry.\n  - The entry would be used to translate the specified address, and one of the\nfollowing applies:\n    - The entry is from a level of lookup above the final level and matches the\nspecified ASID.\n    - The entry is a global entry from the final level of lookup.\n    - The entry is a non-global entry from the final level of lookup that\nmatches the specified ASID.\n  - If EL2 is implemented and enabled in the current Security state, the entry\nwould be used with the current VMID.\n\nFrom the entries that match these requirements, the entries that are invalidated\nare required for the following translation regime:\n\n  - If executed at Secure EL1 when EL3 is using AArch64, the Secure EL1&0\ntranslation regime.\n  - If executed in Secure state when EL3 is using AArch32, the Secure PL1&0\ntranslation regime.\n  - If executed in Non-secure state, the Non-secure PL1&0 translation regime.\n\nThe invalidation only applies to the PE that executes this System instruction.\n\nArm deprecates the use of this System instruction. It is only provided for\nbackwards compatibility with earlier versions of the Arm architecture.\n\nVA, bits [12:31] - Virtual address to match.\nASID, bits [0:7] - ASID value to match."
      },
      "TLBIALL": {
        "long_name": "TLB Invalidate All",
        "purpose": "Invalidate all cached copies of translation table entries from TLBs that are\nfrom any level of the translation table walk. The entries that are invalidated\nare as follows:\n\n  - If executed at EL1, all entries that:\n    - Would be required for the EL1&0 translation regime.\n    - Match the current VMID, if EL2 is implemented and enabled in the current\nSecurity state.\n  - If executed in Secure state when EL3 is using AArch32, all entries that\nwould be required for the Secure PL1&0 translation regime.\n  - If executed at EL2, and if EL2 is enabled in the current Security state, the\nstage 1 or stage 2 translation table entries that would be required for the\nPL1&0 translation regime and matches the current VMID.\n\nThe invalidation only applies to the PE that executes this System instruction."
      },
      "TLBIALLH": {
        "long_name": "TLB Invalidate All, Hyp mode",
        "purpose": "If EL2 is implemented, invalidate all cached copies of translation table entries\nfrom TLBs that are from any level of the translation table walk that would be\nrequired for the Non-secure EL2 translation regime.\n\nThe invalidation only applies to the PE that executes this System instruction."
      },
      "TLBIALLHIS": {
        "long_name": "TLB Invalidate All, Hyp mode, Inner Shareable",
        "purpose": "If EL2 is implemented, invalidate all cached copies of translation table entries\nfrom TLBs that are from any level of the translation table walk that would be\nrequired for the Non-secure EL2 translation regime.\n\nThe invalidation applies to all PEs in the same Inner Shareable shareability\ndomain as the PE that executes this System instruction."
      },
      "TLBIALLIS": {
        "long_name": "TLB Invalidate All, Inner Shareable",
        "purpose": "Invalidate all cached copies of translation table entries from TLBs that are\nfrom any level of the translation table walk. The entries that are invalidated\nare as follows:\n\n  - If executed at EL1, all entries that:\n    - Would be required for the EL1&0 translation regime.\n    - Match the current VMID, if EL2 is implemented and enabled in the current\nSecurity state.\n  - If executed in Secure state when EL3 is using AArch32, all entries that\nwould be required for the Secure PL1&0 translation regime.\n  - If executed at EL2 and if EL2 is enabled in the current Security state, the\nstage 1 or stage 2 translation table entries that would be required for the\nPL1&0 translation regime and matches the current VMID.\n\nThe invalidation applies to all PEs in the same Inner Shareable shareability\ndomain as the PE that executes this System instruction."
      },
      "TLBIALLNSNH": {
        "long_name": "TLB Invalidate All, Non-Secure Non-Hyp",
        "purpose": "If EL2 is implemented, invalidate all cached copies of translation table entries\nfrom TLBs that are from any level of the translation table walk that would be\nrequired for stage 1 or stage 2 of the Non-secure PL1&0 translation regime,\nregardless of the associated VMID.\n\nThe invalidation only applies to the PE that executes this System instruction."
      },
      "TLBIALLNSNHIS": {
        "long_name": "TLB Invalidate All, Non-Secure Non-Hyp, Inner Shareable",
        "purpose": "If EL2 is implemented, invalidate all cached copies of translation table entries\nfrom TLBs that are from any level of the translation table walk that would be\nrequired for stage 1 or stage 2 of the Non-secure PL1&0 translation regime,\nregardless of the associated VMID.\n\nThe invalidation applies to all PEs in the same Inner Shareable shareability\ndomain as the PE that executes this System instruction."
      },
      "TLBIASID": {
        "long_name": "TLB Invalidate by ASID match",
        "purpose": "Invalidate all cached copies of translation table entries from TLBs that meet\nthe following requirements:\n\n  - The entry is a stage 1 translation table entry.\n  - The entry would be used for the specified ASID, and either:\n    - Is from a level of lookup above the final level.\n    - Is a non-global entry from the final level of lookup.\n  - If EL2 is implemented and enabled in the current Security state, the entry\nwould be used with the current VMID.\n\nFrom the entries that match these requirements, the entries that are invalidated\nare required for the following translation regime:\n\n  - If executed at Secure EL1 when EL3 is using AArch64, the Secure EL1&0\ntranslation regime.\n  - If executed in Secure state when EL3 is using AArch32, the Secure PL1&0\ntranslation regime.\n  - If executed in Non-secure state, the Non-secure PL1&0 translation regime.\n\nThe invalidation only applies to the PE that executes this System instruction.\n\nASID, bits [0:7] - ASID value to match. Any TLB entries for non-global pages\n                   that match the ASID values will be affected by this System\n                   instruction."
      },
      "TLBIASIDIS": {
        "long_name": "TLB Invalidate by ASID match, Inner Shareable",
        "purpose": "Invalidate all cached copies of translation table entries from TLBs that meet\nthe following requirements:\n\n  - The entry is a stage 1 translation table entry.\n  - The entry would be used for the specified ASID, and either:\n    - Is from a level of lookup above the final level.\n    - Is a non-global entry from the final level of lookup.\n  - If EL2 is implemented and enabled in the current Security state, the entry\nwould be used with the current VMID.\n\nFrom the entries that match these requirements, the entries that are invalidated\nare required for the following translation regime:\n\n  - If executed at Secure EL1 when EL3 is using AArch64, the Secure EL1&0\ntranslation regime.\n  - If executed in Secure state when EL3 is using AArch32, the Secure PL1&0\ntranslation regime.\n  - If executed in Non-secure state, the Non-secure PL1&0 translation regime.\n\nThe invalidation applies to all PEs in the same Inner Shareable shareability\ndomain as the PE that executes this System instruction.\n\nASID, bits [0:7] - ASID value to match. Any TLB entries for non-global pages\n                   that match the ASID values will be affected by this System\n                   instruction."
      },
      "TLBIIPAS2": {
        "long_name": "TLB Invalidate by Intermediate Physical Address, Stage 2",
        "purpose": "If EL2 is implemented, invalidate all cached copies of translation table entries\nfrom TLBs that meet the following requirements:\n\n  - The entry is a stage 2 only translation table entry, from any level of the\ntranslation table walk.\n  - SCR.NS is 1.\n  - The entry would be used for the specified IPA.\n  - The entry would be used with the current VMID.\n  - The entry would be required for the PL1&0 translation regime.\n\nThe invalidation is not required to apply to caching structures that combine\nstage 1 and stage 2 translation table entries.\n\nThe invalidation only applies to the PE that executes this System instruction.\n\nIPA[39:12], bits [0:27] - Bits[39:12] of the intermediate physical address to\n                          match."
      },
      "TLBIIPAS2IS": {
        "long_name": "TLB Invalidate by Intermediate Physical Address, Stage 2, Inner Shareable",
        "purpose": "If EL2 is implemented, invalidate all cached copies of translation table entries\nfrom TLBs that meet the following requirements:\n\n  - The entry is a stage 2 only translation table entry, from any level of the\ntranslation table walk.\n  - SCR.NS is 1.\n  - The entry would be used for the specified IPA.\n  - The entry would be used with the current VMID.\n  - The entry would be required for the PL1&0 translation regime.\n\nThe invalidation is not required to apply to caching structures that combine\nstage 1 and stage 2 translation table entries.\n\nThe invalidation applies to all PEs in the same Inner Shareable shareability\ndomain as the PE that executes this System instruction.\n\nIPA[39:12], bits [0:27] - Bits[39:12] of the intermediate physical address to\n                          match."
      },
      "TLBIIPAS2L": {
        "long_name": "TLB Invalidate by Intermediate Physical Address, Stage 2, Last level",
        "purpose": "If EL2 is implemented, invalidate all cached copies of translation table entries\nfrom TLBs that meet the following requirements:\n\n  - The entry is a stage 2 only translation table entry, from the final level of\nthe translation table walk.\n  - SCR.NS is 1.\n  - The entry would be used for the specified IPA.\n  - The entry would be used with the current VMID.\n  - The entry would be required for the PL1&0 translation regime.\n\nThe invalidation is not required to apply to caching structures that combine\nstage 1 and stage 2 translation table entries.\n\nThe invalidation only applies to the PE that executes this System instruction.\n\nIPA[39:12], bits [0:27] - Bits[39:12] of the intermediate physical address to\n                          match."
      },
      "TLBIIPAS2LIS": {
        "long_name": "TLB Invalidate by Intermediate Physical Address, Stage 2, Last level, Inner Shareable",
        "purpose": "If EL2 is implemented, invalidate all cached copies of translation table entries\nfrom TLBs that meet the following requirements:\n\n  - The entry is a stage 2 only translation table entry, from the final level of\nthe translation table walk.\n  - SCR.NS is 1.\n  - The entry would be used for the specified IPA.\n  - The entry would be used with the current VMID.\n  - The entry would be required for the PL1&0 translation regime.\n\nThe invalidation is not required to apply to caching structures that combine\nstage 1 and stage 2 translation table entries.\n\nThe invalidation applies to all PEs in the same Inner Shareable shareability\ndomain as the PE that executes this System instruction.\n\nIPA[39:12], bits [0:27] - Bits[39:12] of the intermediate physical address to\n                          match."
      },
      "TLBIMVA": {
        "long_name": "TLB Invalidate by VA",
        "purpose": "Invalidate all cached copies of translation table entries from TLBs that meet\nthe following requirements:\n\n  - The entry is a stage 1 translation table entry.\n  - The entry would be used to translate the specified address, and one of the\nfollowing applies:\n    - The entry is from a level of lookup above the final level and matches the\nspecified ASID.\n    - The entry is a global entry from the final level of lookup.\n    - The entry is a non-global entry from the final level of lookup that\nmatches the specified ASID.\n  - If EL2 is implemented and enabled in the current Security state, the entry\nwould be used with the current VMID.\n\nFrom the entries that match these requirements, the entries that are invalidated\nare required for the following translation regime:\n\n  - If executed at Secure EL1 when EL3 is using AArch64, the Secure EL1&0\ntranslation regime.\n  - If executed in Secure state when EL3 is using AArch32, the Secure PL1&0\ntranslation regime.\n  - If executed in Non-secure state, the Non-secure PL1&0 translation regime.\n\nThe invalidation only applies to the PE that executes this System instruction.\n\nVA, bits [12:31] - Virtual address to match.\nASID, bits [0:7] - ASID value to match."
      },
      "TLBIMVAA": {
        "long_name": "TLB Invalidate by VA, All ASID",
        "purpose": "Invalidate all cached copies of translation table entries from TLBs that meet\nthe following requirements:\n\n  - The entry is a stage 1 translation table entry, from any level of the\ntranslation table walk.\n  - The entry would be used to translate the specified address.\n  - If EL2 is implemented and enabled in the current Security state, the entry\nwould be used with the current VMID.\n\nFrom the entries that match these requirements, the entries that are invalidated\nare required for the following translation regime:\n\n  - If executed at Secure EL1 when EL3 is using AArch64, the Secure EL1&0\ntranslation regime.\n  - If executed in Secure state when EL3 is using AArch32, the Secure PL1&0\ntranslation regime.\n  - If executed in Non-secure state, the Non-secure PL1&0 translation regime.\n\nThe invalidation only applies to the PE that executes this System instruction.\n\nVA, bits [12:31] - Virtual address to match. Any unlocked TLB entries that match\n                   the VA will be affected by this System instruction,\n                   regardless of the ASID."
      },
      "TLBIMVAAIS": {
        "long_name": "TLB Invalidate by VA, All ASID, Inner Shareable",
        "purpose": "Invalidate all cached copies of translation table entries from TLBs that meet\nthe following requirements:\n\n  - The entry is a stage 1 translation table entry, from any level of the\ntranslation table walk.\n  - The entry would be used to translate the specified address.\n  - If EL2 is implemented and enabled in the current Security state, the entry\nwould be used with the current VMID.\n\nFrom the entries that match these requirements, the entries that are invalidated\nare required for the following translation regime:\n\n  - If executed at Secure EL1 when EL3 is using AArch64, the Secure EL1&0\ntranslation regime.\n  - If executed in Secure state when EL3 is using AArch32, the Secure PL1&0\ntranslation regime.\n  - If executed in Non-secure state, the Non-secure PL1&0 translation regime.\n\nThe invalidation applies to all PEs in the same Inner Shareable shareability\ndomain as the PE that executes this System instruction.\n\nVA, bits [12:31] - Virtual address to match. Any unlocked TLB entries that match\n                   the VA will be affected by this System instruction,\n                   regardless of the ASID."
      },
      "TLBIMVAAL": {
        "long_name": "TLB Invalidate by VA, All ASID, Last level",
        "purpose": "Invalidate all cached copies of translation table entries from TLBs that meet\nthe following requirements:\n\n  - The entry is a stage 1 translation table entry, from the final level of the\ntranslation table walk.\n  - The entry would be used to translate the specified address.\n  - If EL2 is implemented and enabled in the current Security state, the entry\nwould be used with the current VMID.\n\nFrom the entries that match these requirements, the entries that are invalidated\nare required for the following translation regime:\n\n  - If executed at Secure EL1 when EL3 is using AArch64, the Secure EL1&0\ntranslation regime.\n  - If executed in Secure state when EL3 is using AArch32, the Secure PL1&0\ntranslation regime.\n  - If executed in Non-secure state, the Non-secure PL1&0 translation regime.\n\nThe invalidation only applies to the PE that executes this System instruction.\n\nVA, bits [12:31] - Virtual address to match. Any unlocked TLB entries that match\n                   the VA will be affected by this System instruction,\n                   regardless of the ASID."
      },
      "TLBIMVAALIS": {
        "long_name": "TLB Invalidate by VA, All ASID, Last level, Inner Shareable",
        "purpose": "Invalidate all cached copies of translation table entries from TLBs that meet\nthe following requirements:\n\n  - The entry is a stage 1 translation table entry, from the final level of the\ntranslation table walk.\n  - The entry would be used to translate the specified address.\n  - If EL2 is implemented and enabled in the current Security state, the entry\nwould be used with the current VMID.\n\nFrom the entries that match these requirements, the entries that are invalidated\nare required for the following translation regime:\n\n  - If executed at Secure EL1 when EL3 is using AArch64, the Secure EL1&0\ntranslation regime.\n  - If executed in Secure state when EL3 is using AArch32, the Secure PL1&0\ntranslation regime.\n  - If executed in Non-secure state, the Non-secure PL1&0 translation regime.\n\nThe invalidation applies to all PEs in the same Inner Shareable shareability\ndomain as the PE that executes this System instruction.\n\nVA, bits [12:31] - Virtual address to match. Any unlocked TLB entries that match\n                   the VA will be affected by this System instruction,\n                   regardless of the ASID."
      },
      "TLBIMVAH": {
        "long_name": "TLB Invalidate by VA, Hyp mode",
        "purpose": "If EL2 is implemented, invalidate all cached copies of translation table entries\nfrom TLBs that are from any level of the translation table walk that would be\nrequired for the Non-secure EL2 translation regime and used to translate the\nspecified address.\n\nThe invalidation only applies to the PE that executes this System instruction.\n\nVA, bits [12:31] - Virtual address to match. Any TLB entries that match the ASID\n                   value and VA value will be affected by this System\n                   instruction."
      },
      "TLBIMVAHIS": {
        "long_name": "TLB Invalidate by VA, Hyp mode, Inner Shareable",
        "purpose": "If EL2 is implemented, invalidate all cached copies of translation table entries\nfrom TLBs that are from any level of the translation table walk that would be\nrequired for the Non-secure EL2 translation regime and used to translate the\nspecified address.\n\nThe invalidation applies to all PEs in the same Inner Shareable shareability\ndomain as the PE that executes this System instruction.\n\nVA, bits [12:31] - Virtual address to match. Any TLB entries that match the ASID\n                   value and VA value will be affected by this System\n                   instruction."
      },
      "TLBIMVAIS": {
        "long_name": "TLB Invalidate by VA, Inner Shareable",
        "purpose": "Invalidate all cached copies of translation table entries from TLBs that meet\nthe following requirements:\n\n  - The entry is a stage 1 translation table entry.\n  - The entry would be used to translate the specified address, and one of the\nfollowing applies:\n    - The entry is from a level of lookup above the final level and matches the\nspecified ASID.\n    - The entry is a global entry from the final level of lookup.\n    - The entry is a non-global entry from the final level of lookup that\nmatches the specified ASID.\n  - If EL2 is implemented and enabled in the current Security state, the entry\nwould be used with the current VMID.\n\nFrom the entries that match these requirements, the entries that are invalidated\nare required for the following translation regime:\n\n  - If executed at Secure EL1 when EL3 is using AArch64, the Secure EL1&0\ntranslation regime.\n  - If executed in Secure state when EL3 is using AArch32, the Secure PL1&0\ntranslation regime.\n  - If executed in Non-secure state, the Non-secure PL1&0 translation regime.\n\nThe invalidation applies to all PEs in the same Inner Shareable shareability\ndomain as the PE that executes this System instruction.\n\nVA, bits [12:31] - Virtual address to match.\nASID, bits [0:7] - ASID value to match."
      },
      "TLBIMVAL": {
        "long_name": "TLB Invalidate by VA, Last level",
        "purpose": "Invalidate all cached copies of translation table entries from TLBs that meet\nthe following requirements:\n\n  - The entry is a stage 1 translation table entry.\n  - The entry would be used to translate the specified address, and one of the\nfollowing applies:\n    - The entry is a global entry from the final level of lookup.\n    - The entry is a non-global entry from the final level of lookup that\nmatches the specified ASID.\n  - If EL2 is implemented and enabled in the current Security state, the entry\nwould be used with the current VMID.\n\nFrom the entries that match these requirements, the entries that are invalidated\nare required for the following translation regime:\n\n  - If executed at Secure EL1 when EL3 is using AArch64, the Secure EL1&0\ntranslation regime.\n  - If executed in Secure state when EL3 is using AArch32, the Secure PL1&0\ntranslation regime.\n  - If executed in Non-secure state, the Non-secure PL1&0 translation regime.\n\nThe invalidation only applies to the PE that executes this System instruction.\n\nVA, bits [12:31] - Virtual address to match.\nASID, bits [0:7] - ASID value to match."
      },
      "TLBIMVALH": {
        "long_name": "TLB Invalidate by VA, Last level, Hyp mode",
        "purpose": "If EL2 is implemented, invalidate all cached copies of translation table entries\nfrom TLBs that are from the final level of the translation table walk that would\nbe required for the Non-secure EL2 translation regime and used to translate the\nspecified address.\n\nThe invalidation only applies to the PE that executes this System instruction.\n\nVA, bits [12:31] - Virtual address to match. Any TLB entries that match the ASID\n                   value and VA value will be affected by this System\n                   instruction."
      },
      "TLBIMVALHIS": {
        "long_name": "TLB Invalidate by VA, Last level, Hyp mode, Inner Shareable",
        "purpose": "If EL2 is implemented, invalidate all cached copies of translation table entries\nfrom TLBs that are from the final level of the translation table walk that would\nbe required for the Non-secure EL2 translation regime and used to translate the\nspecified address.\n\nThe invalidation applies to all PEs in the same Inner Shareable shareability\ndomain as the PE that executes this System instruction.\n\nVA, bits [12:31] - Virtual address to match. Any TLB entries that match the ASID\n                   value and VA value will be affected by this System\n                   instruction."
      },
      "TLBIMVALIS": {
        "long_name": "TLB Invalidate by VA, Last level, Inner Shareable",
        "purpose": "Invalidate all cached copies of translation table entries from TLBs that meet\nthe following requirements:\n\n  - The entry is a stage 1 translation table entry.\n  - The entry would be used to translate the specified address, and one of the\nfollowing applies:\n    - The entry is a global entry from the final level of lookup.\n    - The entry is a non-global entry from the final level of lookup that\nmatches the specified ASID.\n  - If EL2 is implemented and enabled in the current Security state, the entry\nwould be used with the current VMID.\n\nFrom the entries that match these requirements, the entries that are invalidated\nare required for the following translation regime:\n\n  - If executed at Secure EL1 when EL3 is using AArch64, the Secure EL1&0\ntranslation regime.\n  - If executed in Secure state when EL3 is using AArch32, the Secure PL1&0\ntranslation regime.\n  - If executed in Non-secure state, the Non-secure PL1&0 translation regime.\n\nThe invalidation applies to all PEs in the same Inner Shareable shareability\ndomain as the PE that executes this System instruction.\n\nVA, bits [12:31] - Virtual address to match.\nASID, bits [0:7] - ASID value to match."
      }
    },
    "registers": {
      "ACTLR": {
        "long_name": "Auxiliary Control Register",
        "purpose": "Provides implementation defined configuration and control options for execution\nat EL1 and EL0."
      },
      "ACTLR2": {
        "long_name": "Auxiliary Control Register 2",
        "purpose": "Provides additional space to the ACTLR register to hold implementation defined\ntrap functionality for execution at EL1 and EL0."
      },
      "ADFSR": {
        "long_name": "Auxiliary Data Fault Status Register",
        "purpose": "Provides additional implementation defined fault status information for Data\nAbort exceptions taken to EL1 modes, and EL3 modes when EL3 is implemented and\nis using AArch32."
      },
      "AIDR": {
        "long_name": "Auxiliary ID Register",
        "purpose": "Provides implementation defined identification information.\n\nThe value of this register must be used in conjunction with the value of MIDR."
      },
      "AIFSR": {
        "long_name": "Auxiliary Instruction Fault Status Register",
        "purpose": "Provides additional implementation defined fault status information for Prefetch\nAbort exceptions taken to EL1 modes, and EL3 modes when EL3 is implemented and\nis using AArch32."
      },
      "AMAIR0": {
        "long_name": "Auxiliary Memory Attribute Indirection Register 0",
        "purpose": "When using the Long-descriptor format translation tables for stage 1\ntranslations, provides implementation defined memory attributes for the memory\nregions specified by MAIR0."
      },
      "AMAIR1": {
        "long_name": "Auxiliary Memory Attribute Indirection Register 1",
        "purpose": "When using the Long-descriptor format translation tables for stage 1\ntranslations, provides implementation defined memory attributes for the memory\nregions specified by MAIR1."
      },
      "AMCFGR": {
        "long_name": "Activity Monitors Configuration Register",
        "purpose": "Global configuration register for the activity monitors.\n\nProvides information on supported features, the number of counter groups\nimplemented, the total number of activity monitor event counters implemented,\nand the size of the counters. AMCFGR is applicable to both the architected and\nthe auxiliary counter groups.\n\nNCG, bits [28:31] - Defines the number of counter groups. The number of\n                    implemented counter groups is defined as [AMCFGR.NCG + 1].\n                    If the number of implemented auxiliary activity monitor\n                    event counters is zero, this field has a value of 0b0000.\n                    Otherwise, this field has a value of 0b0001.\nHDBG, bit [24]    - Halt-on-debug supported. From Armv8, this feature must be\n                    supported, and so this bit is 0b1.\n                        0b0 AMCR.HDBG is res0.\n                        0b1 AMCR.HDBG is read/write.\nSIZE, bits [8:13] - Defines the size of activity monitor event counters. The\n                    size of the activity monitor event counters implemented by\n                    the Activity Monitors Extension is defined as [AMCFGR.SIZE +\n                    1]. From Armv8, the counters are 64-bit, and so this field\n                    is 0b111111. Software also uses this field to determine the\n                    spacing of counters in the memory-map. From Armv8, the\n                    counters are at doubleword-aligned addresses.\nN, bits [0:7]     - Defines the number of activity monitor event counters. The\n                    total number of counters implemented in all groups by the\n                    Activity Monitors Extension is defined as [AMCFGR.N + 1]."
      },
      "AMCGCR": {
        "long_name": "Activity Monitors Counter Group Configuration Register",
        "purpose": "Provides information on the number of activity monitor event counters\nimplemented within each counter group.\n\nCG1NC, bits [8:15] - Counter Group 1 Number of Counters. The number of counters\n                     in the auxiliary counter group. In an implementation that\n                     includes FEAT_AMUv1, the permitted range of values is 0 to\n                     16.\nCG0NC, bits [0:7]  - Counter Group 0 Number of Counters. The number of counters\n                     in the architected counter group. In an implementation that\n                     includes FEAT_AMUv1, the value of this field is 4."
      },
      "AMCNTENCLR0": {
        "long_name": "Activity Monitors Count Enable Clear Register 0",
        "purpose": "Disable control bits for the architected activity monitors event counters,\nAMEVCNTR0<n>.\n\nP<n>, bits [0:15] - Activity monitor event counter disable bit for AMEVCNTR0<n>.\n                    Bits [31:16] are res0. Bits [15:N] are RAZ/WI. N is the\n                    value in AMCGCR.CG0NC. Possible values of each bit are:\n                        0b0 When read, means that AMEVCNTR0<n> is disabled. When\n                    written, has no effect.\n                        0b1 When read, means that AMEVCNTR0<n> is enabled. When\n                    written, disables AMEVCNTR0<n>."
      },
      "AMCNTENCLR1": {
        "long_name": "Activity Monitors Count Enable Clear Register 1",
        "purpose": "Disable control bits for the auxiliary activity monitors event counters,\nAMEVCNTR1<n>.\n\nP<n>, bits [0:15] - Activity monitor event counter disable bit for AMEVCNTR1<n>.\n                    Bits [31:16] are res0. Bits [15:N] are RAZ/WI. N is the\n                    value in AMCGCR_EL0.CG1NC. Possible values of each bit are:\n                        0b0 When read, means that AMEVCNTR1<n> is disabled. When\n                    written, has no effect.\n                        0b1 When read, means that AMEVCNTR1<n> is enabled. When\n                    written, disables AMEVCNTR1<n>."
      },
      "AMCNTENSET0": {
        "long_name": "Activity Monitors Count Enable Set Register 0",
        "purpose": "Enable control bits for the architected activity monitors event counters,\nAMEVCNTR0<n>.\n\nP<n>, bits [0:15] - Activity monitor event counter enable bit for AMEVCNTR0<n>.\n                    Bits [31:16] are res0. Bits [15:N] are RAZ/WI. N is the\n                    value in AMCGCR.CG0NC. Possible values of each bit are:\n                        0b0 When read, means that AMEVCNTR0<n> is disabled. When\n                    written, has no effect.\n                        0b1 When read, means that AMEVCNTR0<n> is enabled. When\n                    written, enables AMEVCNTR0<n>."
      },
      "AMCNTENSET1": {
        "long_name": "Activity Monitors Count Enable Set Register 1",
        "purpose": "Enable control bits for the auxiliary activity monitors event counters,\nAMEVCNTR1<n>.\n\nP<n>, bits [0:15] - Activity monitor event counter enable bit for AMEVCNTR1<n>.\n                    Bits [31:16] are res0. Bits [15:N] are RAZ/WI. N is the\n                    value in AMCGCR.CG1NC. Possible values of each bit are:\n                        0b0 When read, means that AMEVCNTR1<n> is disabled. When\n                    written, has no effect.\n                        0b1 When read, means that AMEVCNTR1<n> is enabled. When\n                    written, enables AMEVCNTR1<n>."
      },
      "AMCR": {
        "long_name": "Activity Monitors Control Register",
        "purpose": "Global control register for the activity monitors implementation. AMCR is\napplicable to both the architected and the auxiliary counter groups.\n\nCG1RZ, bit [17] - Counter Group 1 Read Zero.\n                      0b0 System register reads of AMEVCNTR1<n> return the event\n                  count at all implemented and enabled Exception levels.\n                      0b1 If the current Exception level is the highest\n                  implemented Exception level, system register reads of\n                  AMEVCNTR1<n> return the event count. Otherwise, reads of\n                  AMEVCNTR1<n> return a zero value.\n                  Reads from the memory-mapped view are unaffected by this\n                  field.\nHDBG, bit [10]  - This bit controls whether activity monitor counting is halted\n                  when the PE is halted in Debug state.\n                      0b0 Activity monitors do not halt counting when the PE is\n                  halted in Debug state.\n                      0b1 Activity monitors halt counting when the PE is halted\n                  in Debug state."
      },
      "AMEVCNTR0<n>": {
        "long_name": "Activity Monitors Event Counter Registers 0",
        "purpose": "Provides access to the architected activity monitor event counters.\n\nACNT, bits [0:63] - Architected activity monitor event counter n. Value of\n                    architected activity monitor event counter n, where n is the\n                    number of this register and is a number from 0 to 15. If\n                    FEAT_AMUv1p1 is implemented, HCR_EL2.AMVOFFEN is 1,\n                    SCR_EL3.AMVOFFEN is 1, HCR_EL2.{E2H, TGE} is not {1,1}, and\n                    EL2 is using AArch64 and is implemented in the current\n                    Security state, access to these registers at EL0 or EL1\n                    return (PCount<63:0> - AMEVCNTVOFF0<n>_EL2<63:0>). PCount is\n                    the physical count returned when AMEVCNTR0<n> is read from\n                    EL2 or EL3.\n                    If the counter is enabled, writes to this register have\n                    unpredictable results."
      },
      "AMEVCNTR1<n>": {
        "long_name": "Activity Monitors Event Counter Registers 1",
        "purpose": "Provides access to the auxiliary activity monitor event counters.\n\nACNT, bits [0:63] - Auxiliary activity monitor event counter n. Value of\n                    auxiliary activity monitor event counter n, where n is the\n                    number of this register and is a number from 0 to 15. If\n                    FEAT_AMUv1p1 is implemented, HCR_EL2.AMVOFFEN is 1,\n                    SCR_EL3.AMVOFFEN is 1, HCR_EL2.{E2H, TGE} is not {1,1}, EL2\n                    is using AArch64 and is implemented in the current Security\n                    state, and AMCR_EL0.CG1RZ is 0, reads to these registers at\n                    EL0 or EL1 return (PCount<63:0> -\n                    AMEVCNTVOFF1<n>_EL2<63:0>). PCount is the physical count\n                    returned when AMEVCNTR1<n> is read from EL2 or EL3.\n                    If the counter is enabled, writes to this register have\n                    unpredictable results."
      },
      "AMEVTYPER0<n>": {
        "long_name": "Activity Monitors Event Type Registers 0",
        "purpose": "Provides information on the events that an architected activity monitor event\ncounter AMEVCNTR0<n> counts.\n\nevtCount, bits [0:15] - Event to count. The event number of the event that is\n                        counted by the architected activity monitor event\n                        counter AMEVCNTR0<n>. The value of this field is\n                        architecturally mandated for each architected counter.\n                        The following table shows the mapping between required\n                        event numbers and the corresponding counters:\n                            0x0011 Processor frequency cycles\n                            0x4004 Constant frequency cycles\n                            0x0008 Instructions retired\n                            0x4005 Memory stall cycles"
      },
      "AMEVTYPER1<n>": {
        "long_name": "Activity Monitors Event Type Registers 1",
        "purpose": "Provides information on the events that an auxiliary activity monitor event\ncounter AMEVCNTR1<n> counts.\n\nevtCount, bits [0:15] - Event to count. The event number of the event that is\n                        counted by the auxiliary activity monitor event counter\n                        AMEVCNTR1<n>. It is implementation defined what values\n                        are supported by each counter. If software writes a\n                        value to this field which is not supported by the\n                        corresponding counter AMEVCNTR1<n>, then:\n                          - It is unpredictable which event will be counted.\n                          - The value read back is unknown. The event counted by\n                        AMEVCNTR1<n> might be fixed at implementation. In this\n                        case, the field is read-only and writes are undefined.\n                        If the corresponding counter AMEVCNTR1<n> is enabled,\n                        writes to this register have unpredictable results."
      },
      "AMUSERENR": {
        "long_name": "Activity Monitors User Enable Register",
        "purpose": "Global user enable register for the activity monitors. Enables or disables EL0\naccess to the activity monitors. AMUSERENR is applicable to both the architected\nand the auxiliary counter groups.\n\nEN, bit [0] - Traps EL0 accesses to the activity monitors registers to EL1.\n                  0b0 EL0 accesses to the activity monitors registers are\n              trapped to EL1.\n                  0b1 This control does not cause any instructions to be\n              trapped. Software can access all activity monitor registers at\n              EL0.\n              \n                - AMUSERENR can always be read at EL0 and is not governed by\n              this bit."
      },
      "APSR": {
        "long_name": "Application Program Status Register",
        "purpose": "Hold program status and control information.\n\nN, bit [31]      - Negative condition flag. Set to bit[31] of the result of the\n                   last flag-setting instruction. If the result is regarded as a\n                   two's complement signed integer, then N is set to 1 if the\n                   result was negative, and N is set to 0 if the result was\n                   positive or zero.\nZ, bit [30]      - Zero condition flag. Set to 1 if the result of the last flag-\n                   setting instruction was zero, and to 0 otherwise. A result of\n                   zero often indicates an equal result from a comparison.\nC, bit [29]      - Carry condition flag. Set to 1 if the last flag-setting\n                   instruction resulted in a carry condition, for example an\n                   unsigned overflow on an addition.\nV, bit [28]      - Overflow condition flag. Set to 1 if the last flag-setting\n                   instruction resulted in an overflow condition, for example a\n                   signed overflow on an addition.\nQ, bit [27]      - Cumulative saturation bit. Set to 1 to indicate that overflow\n                   or saturation occurred in some instructions.\nGE, bits [16:19] - Greater than or Equal flags, for parallel addition and\n                   subtraction."
      },
      "CCSIDR": {
        "long_name": "Current Cache Size ID Register",
        "purpose": "Provides information about the architecture of the currently selected cache.\n\nWhen FEAT_CCIDX is implemented, this register is used in conjunction with\nCCSIDR2.\n\nAssociativity, bits [3:23] - (Associativity of cache) - 1, therefore a value of\n                             0 indicates an associativity of 1. The\n                             associativity does not have to be a power of 2.\nLineSize, bits [0:2]       - (Log_2(Number of bytes in cache line)) - 4. For\n                             example: For a line length of 16 bytes: Log_2(16) =\n                             4, LineSize entry = 0. This is the minimum line\n                             length. For a line length of 32 bytes: Log_2(32) =\n                             5, LineSize entry = 1."
      },
      "CCSIDR2": {
        "long_name": "Current Cache Size ID Register 2",
        "purpose": "When FEAT_CCIDX is implemented, in conjunction with CCSIDR, provides information\nabout the architecture of the currently selected cache.\n\nWhen FEAT_CCIDX is not implemented, this register is not implemented.\n\nNumSets, bits [0:23] - (Number of sets in cache) - 1, therefore a value of 0\n                       indicates 1 set in the cache. The number of sets does not\n                       have to be a power of 2."
      },
      "CLIDR": {
        "long_name": "Cache Level ID Register",
        "purpose": "Identifies the type of cache, or caches, that are implemented at each level and\ncan be managed using the architected cache maintenance instructions that operate\nby set/way, up to a maximum of seven levels. Also identifies the Level of\nCoherence (LoC) and Level of Unification (LoU) for the cache hierarchy.\n\nICB, bits [30:31]     - Inner cache boundary. This field indicates the boundary\n                        for caching Inner Cacheable memory regions.\nLoUU, bits [27:29]    - Level of Unification Uniprocessor for the cache\n                        hierarchy. When FEAT_S2FWB is implemented, the\n                        architecture requires that this field is zero so that no\n                        levels of data cache need to be cleaned in order to\n                        manage coherency with instruction fetches.\nLoC, bits [24:26]     - Level of Coherence for the cache hierarchy.\nLoUIS, bits [21:23]   - Level of Unification Inner Shareable for the cache\n                        hierarchy. When FEAT_S2FWB is implemented, the\n                        architecture requires that this field is zero so that no\n                        levels of data cache need to be cleaned in order to\n                        manage coherency with instruction fetches.\nCtype<n>, bits [0:20] - Cache Type fields. Indicate the type of cache that is\n                        implemented and can be managed using the architected\n                        cache maintenance instructions that operate by set/way\n                        at each level, from Level 1 up to a maximum of seven\n                        levels of cache hierarchy."
      },
      "CNTFRQ": {
        "long_name": "Counter-timer Frequency register",
        "purpose": "This register is provided so that software can discover the frequency of the\nsystem counter. It must be programmed with this value as part of system\ninitialization. The value of the register is not interpreted by hardware.\n\nbits [0:31] - Clock frequency. Indicates the system counter clock frequency, in\n              Hz."
      },
      "CNTHCTL": {
        "long_name": "Counter-timer Hyp Control register",
        "purpose": "Controls the generation of an event stream from the physical counter, and access\nfrom Non-secure EL1 modes to the physical counter and the Non-secure EL1\nphysical timer.\n\nEVNTIS, bit [17]  - Controls the scale of the generation of the event stream.\nEVNTI, bits [4:7] - Selects which bit of the counter register CNTPCT is the\n                    trigger for the event stream generated from that counter,\n                    when that stream is enabled. If FEAT_ECV is implemented, and\n                    CNTHCTL.EVNTIS is 1, this field selects a trigger bit in the\n                    range 8 to 23 of the counter register CNTPCT is the trigger.\n                    Otherwise, this field selects a trigger bit in the range 0\n                    to 15 of the counter register.\nEVNTDIR, bit [3]  - Controls which transition of the counter register CNTPCT\n                    trigger bit, defined by EVNTI, generates an event when the\n                    event stream is enabled:\nEVNTEN, bit [2]   - Enables the generation of an event stream from the counter\n                    register CNTPCT:\nPL1PCEN, bit [1]  - Traps Non-secure EL0 and EL1 accesses to the physical timer\n                    registers to Hyp mode.\nPL1PCTEN, bit [0] - Traps Non-secure EL0 and EL1 accesses to the physical\n                    counter register to Hyp mode."
      },
      "CNTHPS_CTL": {
        "long_name": "Counter-timer Secure Physical Timer Control Register (EL2)",
        "purpose": "Provides AArch32 access from EL0 to the Secure EL2 physical timer.\n\nISTATUS, bit [2] - The status of the timer. This bit indicates whether the timer\n                   condition is met:\n                       0b0 Timer condition is not met.\n                       0b1 Timer condition is met.\n                   When the value of the CNTHPS_CTL.ENABLE bit is 1, ISTATUS\n                   indicates whether the timer condition is met. ISTATUS takes\n                   no account of the value of the IMASK bit. If the value of\n                   ISTATUS is 1 and the value of IMASK is 0 then the timer\n                   interrupt is asserted. When the value of the\n                   CNTHPS_CTL.ENABLE bit is 0, the ISTATUS field is unknown.\nIMASK, bit [1]   - Timer interrupt mask bit. Permitted values are:\n                       0b0 Timer interrupt is not masked by the IMASK bit.\n                       0b1 Timer interrupt is masked by the IMASK bit.\n                   For more information, see the description of the ISTATUS bit.\nENABLE, bit [0]  - Enables the timer. Permitted values are:\n                       0b0 Timer disabled.\n                       0b1 Timer enabled.\n                   Setting this bit to 0 disables the timer output signal, but\n                   the timer value accessible from CNTHPS_TVAL_EL2 continues to\n                   count down. Disabling the output signal might be a power-\n                   saving option."
      },
      "CNTHPS_CVAL": {
        "long_name": "Counter-timer Secure Physical Timer CompareValue Register (EL2)",
        "purpose": "Provides AArch32 access from EL0 to the compare value for the Secure EL2\nphysical timer.\n\nCompareValue, bits [0:63] - Holds the EL2 physical timer CompareValue. When\n                            CNTHPS_CTL_EL2.ENABLE is 1, the timer condition is\n                            met when (CNTPCT_EL0 - CompareValue) is greater than\n                            or equal to zero. This means that CompareValue acts\n                            like a 64-bit upcounter timer. When the timer\n                            condition is met:\n                              - CNTHPS_CTL_EL2.ISTATUS is set to 1.\n                              - If CNTHPS_CTL_EL2.IMASK is 0, an interrupt is\n                            generated. When CNTHPS_CTL_EL2.ENABLE is 0, the\n                            timer condition is not met, but CNTPCT_EL0 continues\n                            to count If the Generic counter is implemented at a\n                            size less than 64 bits, then this field is permitted\n                            to be implemented at the same width as the counter,\n                            and the upper bits are res0. The value of this field\n                            is treated as zero-extended in all counter\n                            calculations."
      },
      "CNTHPS_TVAL": {
        "long_name": "Counter-timer Secure Physical Timer TimerValue Register (EL2)",
        "purpose": "Provides AArch32 access from EL0 to the timer value for the Secure EL2 physical\ntimer.\n\nTimerValue, bits [0:31] - The TimerValue view of the EL2 physical timer. On a\n                          read of this register:\n                            - If CNTHPS_CTL_EL2.ENABLE is 0, the value returned\n                          is unknown.\n                            - If CNTHPS_CTL_EL2.ENABLE is 1, the value returned\n                          is (CNTHPS_CVAL_EL2 - CNTPCT_EL0). On a write of this\n                          register, CNTHPS_CVAL_EL2 is set to (CNTPCT_EL0 +\n                          TimerValue), where TimerValue is treated as a signed\n                          32-bit integer. When CNTHPS_CTL_EL2.ENABLE is 1, the\n                          timer condition is met when (CNTPCT_EL0 -\n                          CNTHPS_CVAL_EL2) is greater than or equal to zero.\n                          This means that TimerValue acts like a 32-bit\n                          downcounter timer. When the timer condition is met:\n                            - CNTHPS_CTL_EL2.ISTATUS is set to 1.\n                            - If CNTHPS_CTL_EL2.IMASK is 0, an interrupt is\n                          generated. When CNTHPS_CTL_EL2.ENABLE is 0, the timer\n                          condition is not met, but CNTPCT_EL0 continues to\n                          count, so the TimerValue view appears to continue to\n                          count down."
      },
      "CNTHP_CTL": {
        "long_name": "Counter-timer Hyp Physical Timer Control register",
        "purpose": "Control register for the Hyp mode physical timer.\n\nISTATUS, bit [2] - The status of the timer. This bit indicates whether the timer\n                   condition is met:\n                       0b0 Timer condition is not met.\n                       0b1 Timer condition is met.\n                   When the value of the ENABLE bit is 1, ISTATUS indicates\n                   whether the timer condition is met. ISTATUS takes no account\n                   of the value of the IMASK bit. If the value of ISTATUS is 1\n                   and the value of IMASK is 0 then the timer interrupt is\n                   asserted. When the value of the ENABLE bit is 0, the ISTATUS\n                   field is unknown.\nIMASK, bit [1]   - Timer interrupt mask bit. Permitted values are:\n                       0b0 Timer interrupt is not masked by the IMASK bit.\n                       0b1 Timer interrupt is masked by the IMASK bit.\n                   For more information, see the description of the ISTATUS bit.\nENABLE, bit [0]  - Enables the timer. Permitted values are:\n                       0b0 Timer disabled.\n                       0b1 Timer enabled.\n                   Setting this bit to 0 disables the timer output signal, but\n                   the timer value accessible from CNTHP_TVAL continues to count\n                   down. Disabling the output signal might be a power-saving\n                   option."
      },
      "CNTHP_CVAL": {
        "long_name": "Counter-timer Hyp Physical CompareValue register",
        "purpose": "Holds the compare value for the Hyp mode physical timer.\n\nCompareValue, bits [0:63] - Holds the EL2 physical timer CompareValue. When\n                            CNTHP_CTL.ENABLE is 1, the timer condition is met\n                            when (CNTPCT - CompareValue) is greater than or\n                            equal to zero. This means that CompareValue acts\n                            like a 64-bit upcounter timer. When the timer\n                            condition is met:\n                              - CNTHP_CTL.ISTATUS is set to 1.\n                              - If CNTHP_CTL.IMASK is 0, an interrupt is\n                            generated. When CNTHP_CTL.ENABLE is 0, the timer\n                            condition is not met, but CNTPCT continues to count.\n                            If the Generic counter is implemented at a size less\n                            than 64 bits, then this field is permitted to be\n                            implemented at the same width as the counter, and\n                            the upper bits are res0. The value of this field is\n                            treated as zero-extended in all counter\n                            calculations."
      },
      "CNTHP_TVAL": {
        "long_name": "Counter-timer Hyp Physical Timer TimerValue register",
        "purpose": "Holds the timer value for the Hyp mode physical timer.\n\nTimerValue, bits [0:31] - The TimerValue view of the EL2 physical timer. On a\n                          read of this register:\n                            - If CNTHP_CTL.ENABLE is 0, the value returned is\n                          unknown.\n                            - If CNTHP_CTL.ENABLE is 1, the value returned is\n                          (CNTHP_CVAL - CNTPCT). On a write of this register,\n                          CNTHP_CVAL is set to (CNTPCT + TimerValue), where\n                          TimerValue is treated as a signed 32-bit integer. When\n                          CNTHP_CTL.ENABLE is 1, the timer condition is met when\n                          (CNTPCT - CNTHP_CVAL) is greater than or equal to\n                          zero. This means that TimerValue acts like a 32-bit\n                          downcounter timer. When the timer condition is met:\n                            - CNTHP_CTL.ISTATUS is set to 1.\n                            - If CNTHP_CTL.IMASK is 0, an interrupt is\n                          generated. When CNTHP_CTL.ENABLE is 0, the timer\n                          condition is not met, but CNTPCT continues to count,\n                          so the TimerValue view appears to continue to count\n                          down."
      },
      "CNTHVS_CTL": {
        "long_name": "Counter-timer Secure Virtual Timer Control Register (EL2)",
        "purpose": "Provides AArch32 access from EL0 to the Secure EL2 virtual timer.\n\nISTATUS, bit [2] - The status of the timer. This bit indicates whether the timer\n                   condition is met:\n                       0b0 Timer condition is not met.\n                       0b1 Timer condition is met.\n                   When the value of the ENABLE bit is 1, ISTATUS indicates\n                   whether the timer condition is met. ISTATUS takes no account\n                   of the value of the IMASK bit. If the value of ISTATUS is 1\n                   and the value of IMASK is 0 then the timer interrupt is\n                   asserted. When the value of the ENABLE bit is 0, the ISTATUS\n                   field is unknown.\nIMASK, bit [1]   - Timer interrupt mask bit. Permitted values are:\n                       0b0 Timer interrupt is not masked by the IMASK bit.\n                       0b1 Timer interrupt is masked by the IMASK bit.\n                   For more information, see the description of the ISTATUS bit.\nENABLE, bit [0]  - Enables the timer. Permitted values are:\n                       0b0 Timer disabled.\n                       0b1 Timer enabled.\n                   Setting this bit to 0 disables the timer output signal, but\n                   the timer value accessible from CNTHVS_TVAL continues to\n                   count down. Disabling the output signal might be a power-\n                   saving option."
      },
      "CNTHVS_CVAL": {
        "long_name": "Counter-timer Secure Virtual Timer CompareValue Register (EL2)",
        "purpose": "Provides AArch32 access to the compare value for the Secure EL2 virtual timer.\n\nCompareValue, bits [0:63] - Holds the EL2 virtual timer CompareValue. When\n                            CNTHVS_CTL.ENABLE is 1, the timer condition is met\n                            when (CNTVCT - CompareValue) is greater than or\n                            equal to zero. This means that CompareValue acts\n                            like a 64-bit upcounter timer. When the timer\n                            condition is met:\n                              - CNTHVS_CTL.ISTATUS is set to 1.\n                              - If CNTHVS_CTL.IMASK is 0, an interrupt is\n                            generated. When CNTHVS_CTL.ENABLE is 0, the timer\n                            condition is not met, but CNTVCT continues to count.\n                            If the Generic counter is implemented at a size less\n                            than 64 bits, then this field is permitted to be\n                            implemented at the same width as the counter, and\n                            the upper bits are res0. The value of this field is\n                            treated as zero-extended in all counter\n                            calculations."
      },
      "CNTHVS_TVAL": {
        "long_name": "Counter-timer Secure Virtual Timer TimerValue Register (EL2)",
        "purpose": "Provides AArch32 access to the timer value for the Secure EL2 virtual timer.\n\nTimerValue, bits [0:31] - The TimerValue view of the EL2 virtual timer. On a\n                          read of this register:\n                            - If CNTHVS_CTL.ENABLE is 0, the value returned is\n                          unknown.\n                            - If CNTHVS_CTL.ENABLE is 1, the value returned is\n                          (CNTHVS_CVAL - CNTVCT). On a write of this register,\n                          CNTHVS_CVAL is set to (CNTVCT + TimerValue), where\n                          TimerValue is treated as a signed 32-bit integer. When\n                          CNTHVS_CTL.ENABLE is 1, the timer condition is met\n                          when (CNTVCT - CNTHVS_CVAL) is greater than or equal\n                          to zero. This means that TimerValue acts like a 32-bit\n                          downcounter timer. When the timer condition is met:\n                            - CNTHVS_CTL.ISTATUS is set to 1.\n                            - If CNTHVS_CTL.IMASK is 0, an interrupt is\n                          generated. When CNTHVS_CTL.ENABLE is 0, the timer\n                          condition is not met, but CNTVCT continues to count,\n                          so the TimerValue view appears to continue to count\n                          down."
      },
      "CNTHV_CTL": {
        "long_name": "Counter-timer Virtual Timer Control register (EL2)",
        "purpose": "Provides AArch32 access to the control register for the EL2 virtual timer.\n\nISTATUS, bit [2] - The status of the timer. This bit indicates whether the timer\n                   condition is met:\n                       0b0 Timer condition is not met.\n                       0b1 Timer condition is met.\n                   When the value of the ENABLE bit is 1, ISTATUS indicates\n                   whether the timer condition is met. ISTATUS takes no account\n                   of the value of the IMASK bit. If the value of ISTATUS is 1\n                   and the value of IMASK is 0 then the timer interrupt is\n                   asserted. When the value of the ENABLE bit is 0, the ISTATUS\n                   field is unknown.\nIMASK, bit [1]   - Timer interrupt mask bit. Permitted values are:\n                       0b0 Timer interrupt is not masked by the IMASK bit.\n                       0b1 Timer interrupt is masked by the IMASK bit.\n                   For more information, see the description of the ISTATUS bit.\nENABLE, bit [0]  - Enables the timer. Permitted values are:\n                       0b0 Timer disabled.\n                       0b1 Timer enabled.\n                   Setting this bit to 0 disables the timer output signal, but\n                   the timer value accessible from CNTHV_TVAL continues to count\n                   down. Disabling the output signal might be a power-saving\n                   option."
      },
      "CNTHV_CVAL": {
        "long_name": "Counter-timer Virtual Timer CompareValue register (EL2)",
        "purpose": "Provides AArch32 access to the compare value for the EL2 virtual timer.\n\nCompareValue, bits [0:63] - Holds the EL2 virtual timer CompareValue. When\n                            CNTHV_CTL.ENABLE is 1, the timer condition is met\n                            when (CNTVCT - CompareValue) is greater than or\n                            equal to zero. This means that CompareValue acts\n                            like a 64-bit upcounter timer. When the timer\n                            condition is met:\n                              - CNTHV_CTL.ISTATUS is set to 1.\n                              - If CNTHV_CTL.IMASK is 0, an interrupt is\n                            generated. When CNTHV_CTL.ENABLE is 0, the timer\n                            condition is not met, but CNTVCT continues to count.\n                            If the Generic counter is implemented at a size less\n                            than 64 bits, then this field is permitted to be\n                            implemented at the same width as the counter, and\n                            the upper bits are res0. The value of this field is\n                            treated as zero-extended in all counter\n                            calculations."
      },
      "CNTHV_TVAL": {
        "long_name": "Counter-timer Virtual Timer TimerValue register (EL2)",
        "purpose": "Provides AArch32 access to the timer value for the EL2 virtual timer.\n\nTimerValue, bits [0:31] - The TimerValue view of the EL2 virtual timer. On a\n                          read of this register:\n                            - If CNTHV_CTL.ENABLE is 0, the value returned is\n                          unknown.\n                            - If CNTHV_CTL.ENABLE is 1, the value returned is\n                          (CNTHV_CVAL - CNTVCT). On a write of this register,\n                          CNTHV_CVAL is set to (CNTVCT + TimerValue), where\n                          TimerValue is treated as a signed 32-bit integer. When\n                          CNTHV_CTL.ENABLE is 1, the timer condition is met when\n                          (CNTVCT - CNTHV_CVAL) is greater than or equal to\n                          zero. This means that TimerValue acts like a 32-bit\n                          downcounter timer. When the timer condition is met:\n                            - CNTHV_CTL.ISTATUS is set to 1.\n                            - If CNTHV_CTL.IMASK is 0, an interrupt is\n                          generated. When CNTHV_CTL.ENABLE is 0, the timer\n                          condition is not met, but CNTVCT continues to count,\n                          so the TimerValue view appears to continue to count\n                          down."
      },
      "CNTKCTL": {
        "long_name": "Counter-timer Kernel Control register",
        "purpose": "Controls the generation of an event stream from the virtual counter, and access\nfrom EL0 modes to the physical counter, virtual counter, EL1 physical timers,\nand the virtual timer.\n\nEVNTIS, bit [17]  - Controls the scale of the generation of the event stream.\nPL0PTEN, bit [9]  - Traps PL0 accesses to the physical timer registers to\n                    Undefined mode.\nPL0VTEN, bit [8]  - Traps PL0 accesses to the virtual timer registers to\n                    Undefined mode.\nEVNTI, bits [4:7] - Selects which bit of the counter register CNTVCT is the\n                    trigger for the event stream generated from that counter,\n                    when that stream is enabled. If FEAT_ECV is implemented, and\n                    CNTKCTL.EVNTIS is 1, this field selects a trigger bit in the\n                    range 8 to 23 of the counter register CNTVCT. Otherwise,\n                    this field selects a trigger bt in the range 0 to 15 of the\n                    counter register.\nEVNTDIR, bit [3]  - Controls which transition of the counter register CNTVCT\n                    trigger bit, defined by EVNTI, generates an event when the\n                    event stream is enabled:\nEVNTEN, bit [2]   - Enables the generation of an event stream from the counter\n                    register CNTVCT:\nPL0VCTEN, bit [1] - Traps PL0 accesses to the frequency register and virtual\n                    counter register to Undefined mode.\nPL0PCTEN, bit [0] - Traps PL0 accesses to the frequency register and physical\n                    counter register to Undefined mode."
      },
      "CNTPCT": {
        "long_name": "Counter-timer Physical Count register",
        "purpose": "Holds the 64-bit physical count value.\n\nbits [0:63] - Physical count value."
      },
      "CNTPCTSS": {
        "long_name": "Counter-timer Self-Synchronized Physical Count register",
        "purpose": "Holds the 64-bit physical count value.\n\nbits [0:63] - Self-Synchronized Physical count value."
      },
      "CNTP_CTL": {
        "long_name": "Counter-timer Physical Timer Control register",
        "purpose": "Control register for the EL1 physical timer.\n\nISTATUS, bit [2] - The status of the timer. This bit indicates whether the timer\n                   condition is met:\n                       0b0 Timer condition is not met.\n                       0b1 Timer condition is met.\n                   When the value of the ENABLE bit is 1, ISTATUS indicates\n                   whether the timer condition is met. ISTATUS takes no account\n                   of the value of the IMASK bit. If the value of ISTATUS is 1\n                   and the value of IMASK is 0 then the timer interrupt is\n                   asserted. When the value of the ENABLE bit is 0, the ISTATUS\n                   field is unknown.\nIMASK, bit [1]   - Timer interrupt mask bit. Permitted values are:\n                       0b0 Timer interrupt is not masked by the IMASK bit.\n                       0b1 Timer interrupt is masked by the IMASK bit.\n                   For more information, see the description of the ISTATUS bit.\nENABLE, bit [0]  - Enables the timer. Permitted values are:\n                       0b0 Timer disabled.\n                       0b1 Timer enabled.\n                   Setting this bit to 0 disables the timer output signal, but\n                   the timer value accessible from CNTP_TVAL continues to count\n                   down. Disabling the output signal might be a power-saving\n                   option."
      },
      "CNTP_CVAL": {
        "long_name": "Counter-timer Physical Timer CompareValue register",
        "purpose": "Holds the compare value for the EL1 physical timer.\n\nCompareValue, bits [0:63] - Holds the EL1 physical timer CompareValue. When\n                            CNTP_CTL.ENABLE is 1, the timer condition is met\n                            when (CNTPCT - CompareValue) is greater than or\n                            equal to zero. This means that CompareValue acts\n                            like a 64-bit upcounter timer. When the timer\n                            condition is met:\n                              - CNTP_CTL.ISTATUS is set to 1.\n                              - If CNTP_CTL.IMASK is 0, an interrupt is\n                            generated. When CNTP_CTL.ENABLE is 0, the timer\n                            condition is not met, but CNTPCT continues to count.\n                            If the Generic counter is implemented at a size less\n                            than 64 bits, then this field is permitted to be\n                            implemented at the same width as the counter, and\n                            the upper bits are res0. The value of this field is\n                            treated as zero-extended in all counter\n                            calculations."
      },
      "CNTP_TVAL": {
        "long_name": "Counter-timer Physical Timer TimerValue register",
        "purpose": "Holds the timer value for the EL1 physical timer.\n\nTimerValue, bits [0:31] - The TimerValue view of the EL1 physical timer. On a\n                          read of this register:\n                            - If CNTP_CTL.ENABLE is 0, the value returned is\n                          unknown.\n                            - If CNTP_CTL.ENABLE is 1, the value returned is\n                          (CNTP_CVAL - CNTPCT). On a write of this register,\n                          CNTP_CVAL is set to (CNTPCT + TimerValue), where\n                          TimerValue is treated as a signed 32-bit integer. When\n                          CNTP_CTL.ENABLE is 1, the timer condition is met when\n                          (CNTPCT - CNTP_CVAL) is greater than or equal to zero.\n                          This means that TimerValue acts like a 32-bit\n                          downcounter timer. When the timer condition is met:\n                            - CNTP_CTL.ISTATUS is set to 1.\n                            - If CNTP_CTL.IMASK is 0, an interrupt is generated.\n                          When CNTP_CTL.ENABLE is 0, the timer condition is not\n                          met, but CNTPCT continues to count, so the TimerValue\n                          view appears to continue to count down."
      },
      "CNTVCT": {
        "long_name": "Counter-timer Virtual Count register",
        "purpose": "Holds the 64-bit virtual count value. The virtual count value is equal to the\nphysical count value minus the virtual offset visible in CNTVOFF.\n\nbits [0:63] - Virtual count value."
      },
      "CNTVCTSS": {
        "long_name": "Counter-timer Self-Synchronized Virtual Count register",
        "purpose": "Holds the 64-bit virtual count value. The virtual count value is equal to the\nphysical count value visible in CNTPCT minus the virtual offset visible in\nCNTVOFF.\n\nbits [0:63] - Self-Synchronized Virtual count value."
      },
      "CNTVOFF": {
        "long_name": "Counter-timer Virtual Offset register",
        "purpose": "Holds the 64-bit virtual offset. This is the offset between the physical count\nvalue visible in CNTPCT and the virtual count value visible in CNTVCT.\n\nbits [0:63] - Virtual offset. If the Generic counter is implemented at a size\n              less than 64 bits, then this field is permitted to be implemented\n              at the same width as the counter, and the upper bits are res0. The\n              value of this field is treated as zero-extended in all counter\n              calculations."
      },
      "CNTV_CTL": {
        "long_name": "Counter-timer Virtual Timer Control register",
        "purpose": "Control register for the virtual timer.\n\nISTATUS, bit [2] - The status of the timer. This bit indicates whether the timer\n                   condition is met:\n                       0b0 Timer condition is not met.\n                       0b1 Timer condition is met.\n                   When the value of the ENABLE bit is 1, ISTATUS indicates\n                   whether the timer condition is met. ISTATUS takes no account\n                   of the value of the IMASK bit. If the value of ISTATUS is 1\n                   and the value of IMASK is 0 then the timer interrupt is\n                   asserted. When the value of the ENABLE bit is 0, the ISTATUS\n                   field is unknown.\nIMASK, bit [1]   - Timer interrupt mask bit. Permitted values are:\n                       0b0 Timer interrupt is not masked by the IMASK bit.\n                       0b1 Timer interrupt is masked by the IMASK bit.\n                   For more information, see the description of the ISTATUS bit.\nENABLE, bit [0]  - Enables the timer. Permitted values are:\n                       0b0 Timer disabled.\n                       0b1 Timer enabled.\n                   Setting this bit to 0 disables the timer output signal, but\n                   the timer value accessible from CNTV_TVAL continues to count\n                   down. Disabling the output signal might be a power-saving\n                   option."
      },
      "CNTV_CVAL": {
        "long_name": "Counter-timer Virtual Timer CompareValue register",
        "purpose": "Holds the compare value for the virtual timer.\n\nCompareValue, bits [0:63] - Holds the EL1 virtual timer CompareValue. When\n                            CNTV_CTL.ENABLE is 1, the timer condition is met\n                            when (CNTVCT - CompareValue) is greater than or\n                            equal to zero. This means that CompareValue acts\n                            like a 64-bit upcounter timer. When the timer\n                            condition is met:\n                              - CNTV_CTL.ISTATUS is set to 1.\n                              - If CNTV_CTL.IMASK is 0, an interrupt is\n                            generated. When CNTV_CTL.ENABLE is 0, the timer\n                            condition is not met, but CNTVCT continues to count.\n                            If the Generic counter is implemented at a size less\n                            than 64 bits, then this field is permitted to be\n                            implemented at the same width as the counter, and\n                            the upper bits are res0. The value of this field is\n                            treated as zero-extended in all counter\n                            calculations."
      },
      "CNTV_TVAL": {
        "long_name": "Counter-timer Virtual Timer TimerValue register",
        "purpose": "Holds the timer value for the virtual timer.\n\nTimerValue, bits [0:31] - The TimerValue view of the virtual timer. On a read of\n                          this register:\n                            - If CNTV_CTL.ENABLE is 0, the value returned is\n                          unknown.\n                            - If CNTV_CTL.ENABLE is 1, the value returned is\n                          (CNTV_CVAL - CNTVCT). On a write of this register,\n                          CNTV_CVAL is set to (CNTVCT + TimerValue), where\n                          TimerValue is treated as a signed 32-bit integer. When\n                          CNTP_CTL.ENABLE is 1, the timer condition is met when\n                          (CNTVCT - CNTP_CVAL) is greater than or equal to zero.\n                          This means that TimerValue acts like a 32-bit\n                          downcounter timer. When the timer condition is met:\n                            - CNTV_CTL.ISTATUS is set to 1.\n                            - If CNTV_CTL.IMASK is 0, an interrupt is generated.\n                          When CNTV_CTL.ENABLE is 0, the timer condition is not\n                          met, but CNTVCT continues to count, so the TimerValue\n                          view appears to continue to count down."
      },
      "CONTEXTIDR": {
        "long_name": "Context ID Register",
        "purpose": "Identifies the current Process Identifier and, when using the Short-descriptor\ntranslation table format, the Address Space Identifier.\n\nThe value of the whole of this register is called the Context ID and is used by:\n\n  - The debug logic, for Linked and Unlinked Context ID matching.\n  - The trace logic, to identify the current process.\n\nThe significance of this register is for debug and trace use only.\n\nPROCID, bits [8:31] - Process Identifier. This field must be programmed with a\n                      unique value that identifies the current process.\nASID, bits [0:7]    - Address Space Identifier. This field is programmed with\n                      the value of the current ASID."
      },
      "CPACR": {
        "long_name": "Architectural Feature Access Control Register",
        "purpose": "Controls access to trace, and to Advanced SIMD and floating-point functionality\nfrom EL0, EL1, and EL3.\n\nIn an implementation that includes EL2, the CPACR has no effect on instructions\nexecuted at EL2.\n\nASEDIS, bit [31]   - Disables PL0 and PL1 execution of Advanced SIMD\n                     instructions.\nTRCDIS, bit [28]   - Traps PL0 and PL1 System register accesses to all\n                     implemented trace registers to Undefined mode.\ncp11, bits [22:23] - The value of this field is ignored. If this field is\n                     programmed with a different value to the cp10 field then\n                     this field is unknown on a direct read of the CPACR. If the\n                     implementation does not include Advanced SIMD and floating-\n                     point functionality, this field is res0. In Non-secure\n                     state, if EL3 is implemented and is using AArch32, when the\n                     value of NSACR.cp10 is 0, this field behaves as RAZ/WI,\n                     regardless of its actual value.\ncp10, bits [20:21] - Defines the access rights for the floating-point and\n                     Advanced SIMD functionality."
      },
      "CPSR": {
        "long_name": "Current Program Status Register",
        "purpose": "Holds PE status and control information.\n\nN, bit [31]      - Negative condition flag.\nZ, bit [30]      - Zero condition flag.\nC, bit [29]      - Carry condition flag.\nV, bit [28]      - Overflow condition flag.\nQ, bit [27]      - Cumulative saturation bit.\nSSBS, bit [23]   - Speculative Store Bypass Safe.\nPAN, bit [22]    - Privileged Access Never.\nDIT, bit [21]    - Data Independent Timing.\nGE, bits [16:19] - Greater than or Equal flags, for parallel addition and\n                   subtraction.\nE, bit [9]       - Endianness state bit.\nA, bit [8]       - SError interrupt mask bit.\nI, bit [7]       - IRQ mask bit.\nF, bit [6]       - FIQ mask bit.\nM, bits [0:3]    - Current PE mode."
      },
      "CSSELR": {
        "long_name": "Cache Size Selection Register",
        "purpose": "Selects the current Cache Size ID Register, CCSIDR, by specifying the required\ncache level and the cache type, which is either instruction cache or data cache.\n\nIf FEAT_CCIDX is implemented, CSSELR also selects the current CCSIDR2.\n\nLevel, bits [1:3] - Cache level of required cache. Permitted values are:\n                        0b000 Level 1 cache.\n                        0b001 Level 2 cache.\n                        0b010 Level 3 cache.\n                        0b011 Level 4 cache.\n                        0b100 Level 5 cache.\n                        0b101 Level 6 cache.\n                        0b110 Level 7 cache.\n                    All other values are reserved. If CSSELR.Level is programmed\n                    to a cache level that is not implemented, then the value for\n                    this field on a read of CSSELR is unknown.\nInD, bit [0]      - Instruction not Data bit. Permitted values are:\n                        0b0 Data or unified cache.\n                        0b1 Instruction cache.\n                    If CSSELR.Level is programmed to a cache level that is not\n                    implemented, then the value for this field on a read of\n                    CSSELR is unknown."
      },
      "CTR": {
        "long_name": "Cache Type Register",
        "purpose": "Provides information about the architecture of the caches.\n\nDIC, bit [29]          - Instruction cache invalidation requirements for data to\n                         instruction coherence.\nIDC, bit [28]          - Data cache clean requirements for instruction to data\n                         coherence.\nCWG, bits [24:27]      - Cache writeback granule.\nERG, bits [20:23]      - Exclusives reservation granule.\nDminLine, bits [16:19] - Log_2 of the number of words in the smallest cache line\n                         of all the data caches and unified caches that are\n                         controlled by the PE.\nL1Ip, bits [14:15]     - Level 1 instruction cache policy.\nIminLine, bits [0:3]   - Log_2 of the number of words in the smallest cache line\n                         of all the instruction caches that are controlled by\n                         the PE."
      },
      "DACR": {
        "long_name": "Domain Access Control Register",
        "purpose": "Defines the access permission for each of the sixteen memory domains.\n\nD<n>, bits [0:31] - Domain n access permission, where n = 0 to 15. Permitted\n                    values are:\n                        0b00 No access. Any access to the domain generates a\n                    Domain fault.\n                        0b01 Client. Accesses are checked against the permission\n                    bits in the translation tables.\n                        0b11 Manager. Accesses are not checked against the\n                    permission bits in the translation tables.\n                    The value 0b10 is reserved."
      },
      "DBGAUTHSTATUS": {
        "long_name": "Debug Authentication Status register",
        "purpose": "Provides information about the state of the implementation defined\nauthentication interface for debug.\n\nSNID, bits [6:7]  - Secure Non-Invasive Debug.\nSNID, bits [6:7]  - Secure Non-Invasive Debug.\nSID, bits [4:5]   - Secure Invasive Debug.\nNSNID, bits [2:3] - Non-secure Non-invasive debug.\nNSNID, bits [2:3] - Non-secure Non-Invasive Debug.\nNSID, bits [0:1]  - Non-secure Invasive Debug."
      },
      "DBGBCR<n>": {
        "long_name": "Debug Breakpoint Control Registers",
        "purpose": "Holds control information for a breakpoint. \nForms breakpoint n together with value register DBGBVR<n>. \nIf EL2 is implemented and this breakpoint supports Context matching, DBGBVR<n>\ncan be associated with a Breakpoint Extended Value\nRegister DBGBXVR<n> for VMID matching.\n\nBT, bits [20:23]  - Breakpoint Type.\nLBN, bits [16:19] - Linked breakpoint number.\nSSC, bits [14:15] - Security state control.\nHMC, bit [13]     - Higher mode control.\nBAS, bits [5:8]   - Byte address select.\nPMC, bits [1:2]   - Privilege mode control.\nE, bit [0]        - Enable breakpoint DBGBVR<n>."
      },
      "DBGBVR<n>": {
        "long_name": "Debug Breakpoint Value Registers",
        "purpose": "Holds a value for use in breakpoint matching, either the virtual address of an\ninstruction or a context ID. Forms breakpoint n together with control register\nDBGBCR<n>. If EL2 is implemented and this breakpoint supports Context matching,\nDBGBVR<n> can be associated with a Breakpoint Extended Value Register DBGBXVR<n>\nfor VMID matching.\n\nVA[31:2], bits [2:31] - Bits[31:2] of the address value for comparison."
      },
      "DBGBXVR<n>": {
        "long_name": "Debug Breakpoint Extended Value Registers",
        "purpose": "Holds a value for use in breakpoint matching, to support VMID matching. Used in\nconjunction with a control register DBGBCR<n> and a value register DBGBVR<n>,\nwhere EL2 is implemented and breakpoint n supports Context matching.\n\nVMID[15:8], bits [8:15] - Extension to VMID[7:0]. For more information, see\n                          VMID[7:0].\nVMID[7:0], bits [0:7]   - VMID value for comparison. The VMID is 8 bits when any\n                          of the following are true:\n                            - EL2 is using AArch32.\n                            - VTCR_EL2.VS is 0.\n                            - FEAT_VMID16 is not implemented."
      },
      "DBGCLAIMCLR": {
        "long_name": "Debug CLAIM Tag Clear register",
        "purpose": "Used by software to read the values of the CLAIM tag bits, and to clear CLAIM\ntag bits to 0.\n\nThe architecture does not define any functionality for the CLAIM tag bits.\n\nCLAIM tags are typically used for communication between the debugger and target\nsoftware.\n\nUsed in conjunction with the DBGCLAIMSET register.\n\nCLAIM, bits [0:7] - Read or clear CLAIM tag bits. Reading this field returns the\n                    current value of the CLAIM tag bits. Writing a 1 to one of\n                    these bits clears the corresponding CLAIM tag bit to 0. This\n                    is an indirect write to the CLAIM tag bits. A single write\n                    operation can clear multiple CLAIM tag bits to 0. Writing 0\n                    to one of these bits has no effect."
      },
      "DBGCLAIMSET": {
        "long_name": "Debug CLAIM Tag Set register",
        "purpose": "Used by software to set the CLAIM tag bits to 1.\n\nThe architecture does not define any functionality for the CLAIM tag bits.\n\nCLAIM tags are typically used for communication between the debugger and target\nsoftware.\n\nUsed in conjunction with the DBGCLAIMCLR register.\n\nCLAIM, bits [0:7] - Set CLAIM tag bits. This field is RAO. Writing a 1 to one of\n                    these bits sets the corresponding CLAIM tag bit to 1. This\n                    is an indirect write to the CLAIM tag bits. A single write\n                    operation can set multiple CLAIM tag bits to 1. Writing 0 to\n                    one of these bits has no effect."
      },
      "DBGDCCINT": {
        "long_name": "DCC Interrupt Enable Register",
        "purpose": "Enables interrupt requests to be signaled based on the DCC status flags.\n\nRX, bit [30] - DCC interrupt request enable control for DTRRX. Enables a common\n               COMMIRQ interrupt request to be signaled based on the DCC status\n               flags.\n                   0b0 No interrupt request generated by DTRRX.\n                   0b1 Interrupt request will be generated on RXfull == 1.\n               If legacy COMMRX and COMMTX signals are implemented, then these\n               are not affected by the value of this bit.\nTX, bit [29] - DCC interrupt request enable control for DTRTX. Enables a common\n               COMMIRQ interrupt request to be signaled based on the DCC status\n               flags.\n                   0b0 No interrupt request generated by DTRTX.\n                   0b1 Interrupt request will be generated on TXfull == 0.\n               If legacy COMMRX and COMMTX signals are implemented, then these\n               are not affected by the value of this bit."
      },
      "DBGDEVID": {
        "long_name": "Debug Device ID register 0",
        "purpose": "Adds to the information given by the DBGDIDR by describing other features of the\ndebug implementation.\n\nCIDMask, bits [28:31]     - Indicates the level of support for the Context ID\n                            matching breakpoint masking capability.\nAuxRegs, bits [24:27]     - Indicates support for Auxiliary registers.\nDoubleLock, bits [20:23]  - OS Double Lock implemented.\nVirtExtns, bits [16:19]   - Indicates whether EL2 is implemented.\nVectorCatch, bits [12:15] - Defines the form of Vector Catch exception\n                            implemented.\nBPAddrMask, bits [8:11]   - Indicates the level of support for the instruction\n                            address matching breakpoint masking capability.\nWPAddrMask, bits [4:7]    - Indicates the level of support for the data address\n                            matching watchpoint masking capability.\nPCSample, bits [0:3]      - Indicates the level of PC Sample-based Profiling\n                            support using external debug registers."
      },
      "DBGDEVID1": {
        "long_name": "Debug Device ID register 1",
        "purpose": "Adds to the information given by the DBGDIDR by describing other features of the\ndebug implementation.\n\nPCSROffset, bits [0:3] - This field indicates the offset applied to PC samples\n                         returned by reads of EDPCSR. Permitted values of this\n                         field in Armv8 are:\n                             0b0000 EDPCSR is not implemented.\n                             0b0010 EDPCSR implemented. Samples have no offset\n                         applied and do not sample the instruction set state in\n                         AArch32 state.\n                         When FEAT_PCSRv8p2 is implemented, the only permitted\n                         value is 0b0000. FEAT_PCSRv8p2 implements the PC\n                         Sample-based Profiling Extension in the Performance\n                         Monitors register space, as indicated by the value of\n                         PMDEVID.PCSample."
      },
      "DBGDEVID2": {
        "long_name": "Debug Device ID register 2",
        "purpose": "Reserved for future descriptions of features of the debug implementation."
      },
      "DBGDIDR": {
        "long_name": "Debug ID Register",
        "purpose": "Specifies which version of the Debug architecture is implemented, and some\nfeatures of the debug implementation.\n\nWRPs, bits [28:31]     - The number of watchpoints implemented, minus 1.\n                         Permitted values of this field are from 0b0001 for 2\n                         implemented watchpoints, to 0b1111 for 16 implemented\n                         watchpoints. The value of 0b0000 is reserved. If\n                         AArch64 is implemented, this field has the same value\n                         as ID_AA64DFR0_EL1.WRPs.\nBRPs, bits [24:27]     - The number of breakpoints implemented, minus 1.\n                         Permitted values of this field are from 0b0001 for 2\n                         implemented breakpoint, to 0b1111 for 16 implemented\n                         breakpoints. The value of 0b0000 is reserved. If\n                         AArch64 is implemented, this field has the same value\n                         as ID_AA64DFR0_EL1.BRPs.\nCTX_CMPs, bits [20:23] - The number of breakpoints that can be used for Context\n                         matching, minus 1. Permitted values of this field are\n                         from 0b0000 for 1 Context matching breakpoint, to\n                         0b1111 for 16 Context matching breakpoints. The Context\n                         matching breakpoints must be the highest addressed\n                         breakpoints. For example, if six breakpoints are\n                         implemented and two are Context matching breakpoints,\n                         they must be breakpoints 4 and 5. If AArch64 is\n                         implemented, this field has the same value as\n                         ID_AA64DFR0_EL1.CTX_CMPs.\nVersion, bits [16:19]  - The Debug architecture version.\nnSUHD_imp, bit [14]    - In Armv7-A, was Secure User Halting Debug not\n                         implemented. The value of this bit must match the value\n                         of the SE_imp bit.\nSE_imp, bit [12]       - EL3 implemented."
      },
      "DBGDRAR": {
        "long_name": "Debug ROM Address Register",
        "purpose": "Defines the base physical address of a 4KB-aligned memory-mapped debug\ncomponent, usually a ROM table that locates and describes the memory-mapped\ndebug components in the system. Armv8 deprecates any use of this register.\n\nROMADDR[47:12], bits [12:47] - Bits[47:12] of the ROM table physical address. If\n                               the physical address size in bits (PAsize) is\n                               less than 48 then the register bits corresponding\n                               to ROMADDR [47:PAsize] are res0. Bits [11:0] of\n                               the ROM table physical address are zero. Arm\n                               strongly recommends that bits\n                               ROMADDR[(PAsize-1):32] are zero in any system\n                               that supports AArch32 at the highest implemented\n                               Exception level. In an implementation that\n                               includes EL3, ROMADDR is an address in Non-secure\n                               memory. It is implementation defined whether the\n                               ROM table is also accessible in Secure memory. If\n                               DBGDRAR.Valid == 0b00, then this field is\n                               unknown.\nValid, bits [0:1]            - This field indicates whether the ROM Table\n                               address is valid.\n                                   0b00 ROM Table address is not valid. Software\n                               must ignore ROMADDR.\n                                   0b11 ROM Table address is valid.\n                               Other values are reserved."
      },
      "DBGDSAR": {
        "long_name": "Debug Self Address Register",
        "purpose": "In earlier versions of the Arm Architecture, this register defines the offset\nfrom the base address defined in DBGDRAR of the physical base address of the\ndebug registers for the PE. Armv8 deprecates any use of this register."
      },
      "DBGDSCRext": {
        "long_name": "Debug Status and Control Register, External View",
        "purpose": "Main control register for the debug implementation.\n\nTFO, bit [31]        - Trace Filter override.\nRXfull, bit [30]     - DTRRX full.\nTXfull, bit [29]     - DTRTX full.\nRXO, bit [27]        - Used for save/restore of EDSCR.RXO.\nTXU, bit [26]        - Used for save/restore of EDSCR.TXU.\nINTdis, bits [22:23] - Used for save/restore of EDSCR.INTdis.\nTDA, bit [21]        - Used for save/restore of EDSCR.TDA.\nSC2, bit [19]        - Used for save/restore of EDSCR.SC2.\nNS, bit [18]         - Non-secure status.\nSPNIDdis, bit [17]   - Secure privileged profiling disabled status bit.\nSPIDdis, bit [16]    - Secure privileged AArch32 invasive self-hosted debug\n                       disabled status bit.\nMDBGen, bit [15]     - Monitor debug events enable.\nHDE, bit [14]        - Used for save/restore of EDSCR.HDE.\nUDCCdis, bit [12]    - Traps EL0 accesses to the DCC registers to Undefined\n                       mode.\nERR, bit [6]         - Used for save/restore of EDSCR.ERR.\nMOE, bits [2:5]      - Method of Entry for debug exception."
      },
      "DBGDSCRint": {
        "long_name": "Debug Status and Control Register, Internal View",
        "purpose": "Main control register for the debug implementation. This is an internal, read-\nonly view.\n\nRXfull, bit [30]   - DTRRX full. Read-only view of the equivalent bit in the\n                     EDSCR.\nTXfull, bit [29]   - DTRTX full. Read-only view of the equivalent bit in the\n                     EDSCR.\nNS, bit [18]       - Non-secure status. Read-only view of the equivalent bit in\n                     the DBGDSCRext. Arm deprecates use of this field.\nSPNIDdis, bit [17] - Secure privileged non-invasive debug disable. Read-only\n                     view of the equivalent bit in the DBGDSCRext. Arm\n                     deprecates use of this field.\nSPIDdis, bit [16]  - Secure privileged invasive debug disable. Read-only view of\n                     the equivalent bit in the DBGDSCRext. Arm deprecates use of\n                     this field.\nMDBGen, bit [15]   - Monitor debug events enable. Read-only view of the\n                     equivalent bit in the DBGDSCRext.\nUDCCdis, bit [12]  - User mode access to Debug Communications Channel disable.\n                     Read-only view of the equivalent bit in the DBGDSCRext. Arm\n                     deprecates use of this field.\nMOE, bits [2:5]    - Method of Entry for debug exception. When a debug exception\n                     is taken to an Exception level using AArch32, this field is\n                     set to indicate the event that caused the exception:\n                         0b0001 Breakpoint\n                         0b0011 Software breakpoint (BKPT) instruction\n                         0b0101 Vector catch\n                         0b1010 Watchpoint\n                     Read-only view of the equivalent bit in the DBGDSCRext."
      },
      "DBGDTRRXext": {
        "long_name": "Debug OS Lock Data Transfer Register, Receive, External View",
        "purpose": "Used for save/restore of DBGDTRRXint. It is a component of the Debug\nCommunications Channel.\n\nbits [0:31] - Update DTRRX without side-effect. Writes to this register update\n              the value in DTRRX and do not change RXfull. Reads of this\n              register return the last value written to DTRRX and do not change\n              RXfull. For the full behavior of the Debug Communications Channel,\n              see 'The Debug Communication Channel and Instruction Transfer\n              Register'."
      },
      "DBGDTRRXint": {
        "long_name": "Debug Data Transfer Register, Receive",
        "purpose": "Transfers data from an external debugger to the PE. For example, it is used by a\ndebugger transferring commands and data to a debug target. See DBGDTR_EL0 for\nadditional architectural mappings. It is a component of the Debug Communications\nChannel.\n\nbits [0:31] - Update DTRRX. Reads of this register:\n                -  If RXfull is set to 1, return the last value written to\n              DTRRX.\n                -  If RXfull is set to 0, return an unknown value. After the\n              read, RXfull is cleared to 0. For the full behavior of the Debug\n              Communications Channel, see 'The Debug Communication Channel and\n              Instruction Transfer Register'."
      },
      "DBGDTRTXext": {
        "long_name": "Debug OS Lock Data Transfer Register, Transmit",
        "purpose": "Used for save/restore of DBGDTRTXint. It is a component of the Debug\nCommunication Channel.\n\nbits [0:31] - Return DTRTX without side-effect. Reads of this register return\n              the value in DTRTX and do not change TXfull. Writes of this\n              register update the value in DTRTX and do not change TXfull. For\n              the full behavior of the Debug Communications Channel, see 'The\n              Debug Communication Channel and Instruction Transfer Register'."
      },
      "DBGDTRTXint": {
        "long_name": "Debug Data Transfer Register, Transmit",
        "purpose": "Transfers data from the PE to an external debugger. For example, it is used by a\ndebug target to transfer data to the debugger. See DBGDTR_EL0 for additional\narchitectural mappings. It is a component of the Debug Communication Channel.\n\nbits [0:31] - Return DTRTX. Writes to this register:\n                -  If TXfull is set to 1, set DTRTX to unknown.\n                -  If TXfull is set to 0, update the value in DTRTX. After the\n              write, TXfull is set to 1. For the full behavior of the Debug\n              Communications Channel, see 'The Debug Communication Channel and\n              Instruction Transfer Register'."
      },
      "DBGOSDLR": {
        "long_name": "Debug OS Double Lock Register",
        "purpose": "Locks out the external debug interface.\n\nDLK, bit [0] - OS Double Lock control bit.\n                   0b0 OS Double Lock unlocked.\n                   0b1 OS Double Lock locked, if DBGPRCR.CORENPDRQ (Core no\n               powerdown request) bit is set to 0 and the PE is in Non-debug\n               state."
      },
      "DBGOSECCR": {
        "long_name": "Debug OS Lock Exception Catch Control Register",
        "purpose": "Provides a mechanism for an operating system to access the contents of EDECCR\nthat are otherwise invisible to software, so it can save/restore the contents of\nEDECCR over powerdown on behalf of the external debugger.\n\nEDECCR, bits [0:31] - Used for save/restore to EDECCR over powerdown. Reads or\n                      writes to this field are indirect accesses to EDECCR."
      },
      "DBGOSLAR": {
        "long_name": "Debug OS Lock Access Register",
        "purpose": "Provides a lock for the debug registers. The OS Lock also disables some debug\nexceptions and debug events.\n\nOSLA, bits [0:31] - OS Lock Access. Writing the value 0xC5ACCE55 to the DBGOSLAR\n                    sets the OS lock to 1. Writing any other value sets the OS\n                    lock to 0. Use DBGOSLSR.OSLK to check the current status of\n                    the lock."
      },
      "DBGOSLSR": {
        "long_name": "Debug OS Lock Status Register",
        "purpose": "Provides status information for the OS Lock.\n\nOSLM, bit [3]    - OS lock model implemented. Identifies the form of OS save and\n                   restore mechanism implemented.\n                       0b00 OS Lock not implemented.\n                       0b10 OS Lock implemented.\n                   All other values are reserved. In an Armv8 implementation the\n                   value 0b00 is not permitted. The OSLM field is split as\n                   follows:\n                     - OSLM[1] is DBGOSLSR[3].\n                     - OSLM[0] is DBGOSLSR[0].\nnTT, bit [2]     - Not 32-bit access. This bit is always RAZ. It indicates that\n                   a 32-bit access is needed to write the key to the OS Lock\n                   Access Register.\nOSLK, bit [1]    - OS Lock Status. The possible values are:\n                       0b0 OS Lock unlocked.\n                       0b1 OS Lock locked.\n                   The OS Lock is locked and unlocked by writing to the OS Lock\n                   Access Register.\nOSLM[0], bit [0] - This field is bit[0] of OSLM[1:0]. See OSLM[1] for the field\n                   description."
      },
      "DBGPRCR": {
        "long_name": "Debug Power Control Register",
        "purpose": "Controls behavior of the PE on powerdown request.\n\nCORENPDRQ, bit [0] - Core no powerdown request. Requests emulation of powerdown.\n                     This request is typically passed to an external power\n                     controller. This means that whether a request causes power\n                     up is dependent on the implementation defined nature of the\n                     system. The power controller must not allow the Core power\n                     domain to switch off while this bit is 1.\n                         0b0 If the system responds to a powerdown request, it\n                     powers down Core power domain.\n                         0b1 If the system responds to a powerdown request, it\n                     does not powerdown the Core power domain, but instead\n                     emulates a powerdown of that domain.\nCORENPDRQ, bit [0] - Core no powerdown request. Requests emulation of powerdown.\n                     This request is typically passed to an external power\n                     controller. This means that whether a request causes power\n                     up is dependent on the implementation defined nature of the\n                     system. The power controller must not allow the Core power\n                     domain to switch off while this bit is 1.\n                         0b0 If the system responds to a powerdown request, it\n                     powers down Core power domain.\n                         0b1 If the system responds to a powerdown request, it\n                     does not powerdown the Core power domain, but instead\n                     emulates a powerdown of that domain."
      },
      "DBGVCR": {
        "long_name": "Debug Vector Catch Register",
        "purpose": "Controls Vector Catch debug events.\n\nNSF, bit [31] - FIQ vector catch enable in Non-secure state.\nNSI, bit [30] - IRQ vector catch enable in Non-secure state.\nNSD, bit [28] - Data Abort vector catch enable in Non-secure state.\nNSP, bit [27] - Prefetch Abort vector catch enable in Non-secure state.\nNSS, bit [26] - Supervisor Call (SVC) vector catch enable in Non-secure state.\nNSU, bit [25] - Undefined Instruction vector catch enable in Non-secure state.\nMF, bit [15]  - FIQ vector catch enable in Monitor mode.\nMI, bit [14]  - IRQ vector catch enable in Monitor mode.\nMD, bit [12]  - Data Abort vector catch enable in Monitor mode.\nMP, bit [11]  - Prefetch Abort vector catch enable in Monitor mode.\nMS, bit [10]  - Secure Monitor Call (SMC) vector catch enable in Monitor mode.\nSF, bit [7]   - FIQ vector catch enable in Secure state.\nSI, bit [6]   - IRQ vector catch enable in Secure state.\nSD, bit [4]   - Data Abort vector catch enable in Secure state.\nSP, bit [3]   - Prefetch Abort vector catch enable in Secure state.\nSS, bit [2]   - Supervisor Call (SVC) vector catch enable in Secure state.\nSU, bit [1]   - Undefined Instruction vector catch enable in Secure state."
      },
      "DBGWCR<n>": {
        "long_name": "Debug Watchpoint Control Registers",
        "purpose": "Holds control information for a watchpoint. Forms watchpoint n together with\nvalue register DBGWVR<n>.\n\nMASK, bits [24:28] - Address mask.\nWT, bit [20]       - Watchpoint type.\nLBN, bits [16:19]  - Linked breakpoint number.\nSSC, bits [14:15]  - Security state control.\nHMC, bit [13]      - Higher mode control.\nBAS, bits [5:12]   - Byte address select.\nLSC, bits [3:4]    - Load/store control.\nPAC, bits [1:2]    - Privilege of access control.\nE, bit [0]         - Enable watchpoint n."
      },
      "DBGWFAR": {
        "long_name": "Debug Watchpoint Fault Address Register",
        "purpose": "Previously returned information about the address of the instruction that\naccessed a watchpointed address. Is now deprecated and res0."
      },
      "DBGWVR<n>": {
        "long_name": "Debug Watchpoint Value Registers",
        "purpose": "Holds a data address value for use in watchpoint matching. Forms watchpoint n\ntogether with control register DBGWCR<n>.\n\nVA, bits [2:31] - Bits[31:2] of the address value for comparison. Arm deprecates\n                  setting DBGWVR<n>[2] == 1."
      },
      "DFAR": {
        "long_name": "Data Fault Address Register",
        "purpose": "Holds the virtual address of the faulting address that caused a synchronous Data\nAbort exception.\n\nbits [0:31] - VA of faulting address of synchronous Data Abort exception."
      },
      "DFSR": {
        "long_name": "Data Fault Status Register",
        "purpose": "Holds status information about the last data fault.\n\nFnV, bit [16]       - FAR not Valid, for a synchronous External abort other than\n                      a synchronous External abort on a translation table walk.\nAET, bits [14:15]   - Asynchronous Error Type. When DFSC is 0b010001, describes\n                      the PE error state after taking the SError interrupt\n                      exception.\nCM, bit [13]        - Cache maintenance fault. For synchronous faults, this bit\n                      indicates whether a cache maintenance instruction\n                      generated the fault.\nExT, bit [12]       - External abort type. This bit can be used to provide an\n                      implementation defined classification of External aborts.\n                      In an implementation that does not provide any\n                      classification of External aborts, this bit is res0. For\n                      aborts other than External aborts this bit always returns\n                      0.\nWnR, bit [11]       - Write not Read bit. Indicates whether the abort was caused\n                      by a write or a read instruction.\nFS, bit [10]        - Fault status bits.\nLPAE, bit [9]       - On taking a Data Abort exception, this bit is set as\n                      follows:\nDomain, bits [4:7]  - The domain of the fault address. Arm deprecates any use of\n                      this field, see 'The Domain field in the DFSR'. This field\n                      is unknown for certain faults where the DFSR is updated\n                      and reported using the Short-descriptor FSR encodings, see\n                      'Validity of Domain field on faults that update the DFSR\n                      when using the Short-descriptor encodings'.\nFS[3:0], bits [0:3] - This field is bits[3:0] of FS[4:0]. See FS[4] for the\n                      field description."
      },
      "DISR": {
        "long_name": "Deferred Interrupt Status Register",
        "purpose": "Records that an SError interrupt has been consumed by an ESB instruction.\n\nA, bit [31]       - Set to 1 when an ESB instruction defers an asynchronous\n                    SError interrupt. If the implementation does not include any\n                    sources of SError interrupt that can be synchronized by an\n                    Error Synchronization Barrier, then this bit is res0.\nAET, bits [10:11] - Asynchronous Error Type. See the description of HSR.AET for\n                    an SError interrupt.\nEA, bit [9]       - External abort Type. See the description of HSR.EA for an\n                    SError interrupt.\nDFSC, bits [0:5]  - Fault Status Code. See the description of HSR.DFSC for an\n                    SError interrupt."
      },
      "DLR": {
        "long_name": "Debug Link Register",
        "purpose": "In Debug state, holds the address to restart from.\n\nbits [0:31] - Restart address."
      },
      "DSPSR": {
        "long_name": "Debug Saved Program Status Register",
        "purpose": "Holds the saved process state for Debug state. On entering Debug state, PSTATE\ninformation is written to this register. On exiting Debug state, values are\ncopied from this register to PSTATE.\n\nN, bit [31]           - Negative Condition flag.\nZ, bit [30]           - Zero Condition flag.\nC, bit [29]           - Carry Condition flag.\nV, bit [28]           - Overflow Condition flag.\nQ, bit [27]           - Overflow or saturation flag.\nIT, bits [25:26]      - If-Then.\nDIT, bit [24]         - Data Independent Timing.\nSSBS, bit [23]        - Speculative Store Bypass.\nPAN, bit [22]         - Privileged Access Never.\nSS, bit [21]          - Software Step.\nIL, bit [20]          - Illegal Execution state.\nGE, bits [16:19]      - Greater than or Equal flags.\nIT[7:2], bits [10:15] - This field is bits[7:2] of IT[7:0].\nE, bit [9]            - Endianness.\nA, bit [8]            - SError interrupt mask.\nI, bit [7]            - IRQ interrupt mask.\nF, bit [6]            - FIQ interrupt mask.\nT, bit [5]            - T32 Instruction set state.\nM[4:0], bits [0:4]    - Mode."
      },
      "ELR_hyp": {
        "long_name": "Exception Link Register (Hyp mode)",
        "purpose": "When taking an exception to Hyp mode, holds the address to return to.\n\nbits [0:31] - Return address."
      },
      "ERRIDR": {
        "long_name": "Error Record ID Register",
        "purpose": "Defines the highest numbered index of the error records that can be accessed\nthrough the Error Record System registers.\n\nNUM, bits [0:15] - Highest numbered index of the records that can be accessed\n                   through the Error Record System registers plus one. Zero\n                   indicates that no records can be accessed through the Error\n                   Record System registers. Each implemented record is owned by\n                   a node. A node might own multiple records."
      },
      "ERRSELR": {
        "long_name": "Error Record Select Register",
        "purpose": "Selects an error record to be accessed through the Error Record System\nregisters.\n\nSEL, bits [0:15] - Selects the error record accessed through the ERX registers.\n                   For example, if ERRSELR.SEL is set to 0x0004, then direct\n                   reads and writes of ERXSTATUS access ERR4STATUS. If\n                   ERRSELR.SEL is set to a value greater than or equal to\n                   ERRIDR.NUM, then all of the following apply:\n                     - The value read back from ERRSELR.SEL is unknown.\n                     - One of the following occurs:\n                       - An unknown error record is selected.\n                       - The ERX* registers are RAZ/WI.\n                       - ERX* register reads and writes are NOPs.\n                       - ERX* register reads and writes are undefined."
      },
      "ERXADDR": {
        "long_name": "Selected Error Record Address Register",
        "purpose": "Accesses bits [31:0] of ERR<n>ADDR for the error record <n> selected by\nERRSELR.SEL.\n\nbits [0:31] - ERXADDR accesses bits [31:0] of ERR<n>ADDR, where <n> is the value\n              in ERRSELR.SEL."
      },
      "ERXADDR2": {
        "long_name": "Selected Error Record Address Register 2",
        "purpose": "Accesses bits [63:32] of ERR<n>ADDR for the error record <n> selected by\nERRSELR.SEL.\n\nbits [0:31] - ERXADDR2 accesses bits [63:32] of ERR<n>ADDR, where <n> is the\n              value in ERRSELR.SEL."
      },
      "ERXCTLR": {
        "long_name": "Selected Error Record Control Register",
        "purpose": "Accesses bits [31:0] of ERR<n>CTLR for the error record <n> selected by\nERRSELR.SEL.\n\nbits [0:31] - ERXCTLR accesses bits [31:0] of ERR<n>CTLR, where <n> is the value\n              in ERRSELR.SEL."
      },
      "ERXCTLR2": {
        "long_name": "Selected Error Record Control Register 2",
        "purpose": "Accesses bits [63:32] of ERR<n>CTLR for the error record <n> selected by\nERRSELR.SEL.\n\nbits [0:31] - ERXCTLR2 accesses bits [63:32] of ERR<n>CTLR, where <n> is the\n              value in ERRSELR.SEL."
      },
      "ERXFR": {
        "long_name": "Selected Error Record Feature Register",
        "purpose": "Accesses bits [31:0] of ERR<n>FR for the error record <n> selected by\nERRSELR.SEL.\n\nbits [0:31] - ERXFR accesses bits [31:0] of ERR<n>FR, where <n> is the value in\n              ERRSELR.SEL."
      },
      "ERXFR2": {
        "long_name": "Selected Error Record Feature Register 2",
        "purpose": "Accesses bits [63:32] of ERR<n>FR for the error record <n> selected by\nERRSELR.SEL.\n\nbits [0:31] - ERXFR2 accesses bits [63:32] of ERR<n>FR, where <n> is the value\n              in ERRSELR.SEL."
      },
      "ERXMISC0": {
        "long_name": "Selected Error Record Miscellaneous Register 0",
        "purpose": "Accesses bits [31:0] of ERR<n>MISC0 for the error record <n> selected by\nERRSELR.SEL.\n\nbits [0:31] - ERXMISC0 accesses bits [31:0] of ERR<n>MISC0, where <n> is the\n              value in ERRSELR.SEL."
      },
      "ERXMISC1": {
        "long_name": "Selected Error Record Miscellaneous Register 1",
        "purpose": "Accesses bits [63:32] of ERR<n>MISC0 for the error record <n> selected by\nERRSELR.SEL.\n\nbits [0:31] - ERXMISC1 accesses bits [63:32] of ERR<n>MISC0, where <n> is the\n              value in ERRSELR.SEL."
      },
      "ERXMISC2": {
        "long_name": "Selected Error Record Miscellaneous Register 2",
        "purpose": "Accesses bits [31:0] of ERR<n>MISC1 for the error record <n> selected by\nERRSELR.SEL.\n\nbits [0:31] - ERXMISC2 accesses bits [31:0] of ERR<n>MISC1, where <n> is the\n              value in ERRSELR.SEL."
      },
      "ERXMISC3": {
        "long_name": "Selected Error Record Miscellaneous Register 3",
        "purpose": "Accesses bits [63:32] of ERR<n>MISC1 for the error record <n> selected by\nERRSELR.SEL.\n\nbits [0:31] - ERXMISC3 accesses bits [63:32] of ERR<n>MISC1, where <n> is the\n              value in ERRSELR.SEL."
      },
      "ERXMISC4": {
        "long_name": "Selected Error Record Miscellaneous Register 4",
        "purpose": "Accesses bits [31:0] of ERR<n>MISC2 for the error record <n> selected by\nERRSELR.SEL.\n\nbits [0:31] - ERXMISC4 accesses bits [31:0] of ERR<n>MISC2, where <n> is the\n              value in ERRSELR.SEL."
      },
      "ERXMISC5": {
        "long_name": "Selected Error Record Miscellaneous Register 5",
        "purpose": "Accesses bits [63:32] of ERR<n>MISC2 for the error record <n> selected by\nERRSELR.SEL.\n\nbits [0:31] - ERXMISC5 accesses bits [63:32] of ERR<n>MISC2, where <n> is the\n              value in ERRSELR.SEL."
      },
      "ERXMISC6": {
        "long_name": "Selected Error Record Miscellaneous Register 6",
        "purpose": "Accesses bits [31:0] of ERR<n>MISC3 for the error record <n> selected by\nERRSELR.SEL.\n\nbits [0:31] - ERXMISC6 accesses bits [31:0] of ERR<n>MISC3, where <n> is the\n              value in ERRSELR.SEL."
      },
      "ERXMISC7": {
        "long_name": "Selected Error Record Miscellaneous Register 7",
        "purpose": "Accesses bits [63:32] of ERR<n>MISC3 for the error record <n> selected by\nERRSELR.SEL.\n\nbits [0:31] - ERXMISC7 accesses bits [63:32] of ERR<n>MISC3, where <n> is the\n              value in ERRSELR.SEL."
      },
      "ERXSTATUS": {
        "long_name": "Selected Error Record Primary Status Register",
        "purpose": "Accesses bits [31:0] of ERR<n>STATUS for the error record selected by\nERRSELR.SEL.\n\nbits [0:31] - ERXSTATUS accesses bits [31:0] of ERR<n>STATUS, where n is the\n              value in ERRSELR.SEL."
      },
      "FCSEIDR": {
        "long_name": "FCSE Process ID register",
        "purpose": "Identifies whether the Fast Context Switch Extension (FCSE) is implemented.\n\nFrom Armv8, the FCSE is not implemented, so this register is RAZ/WI. Software\ncan access this register to determine that the implementation does not include\nthe FCSE."
      },
      "FPEXC": {
        "long_name": "Floating-Point Exception Control register",
        "purpose": "Provides a global enable for the implemented Advanced SIMD and floating-point\nfunctionality, and reports floating-point status information.\n\nEX, bit [31]        - Exception bit.\nEN, bit [30]        - Enables access to the Advanced SIMD and floating-point\n                      functionality from all Exception levels, except that\n                      setting this field to 0 does not disable the following.\nDEX, bit [29]       - Defined synchronous exception on floating-point execution.\nFP2V, bit [28]      - FPINST2 instruction valid bit.\nVV, bit [27]        - VECITR valid bit.\nTFV, bit [26]       - Trapped Fault Valid bit.\nVECITR, bits [8:10] - Vector iteration count.\nIDF, bit [7]        - Input Denormal trapped exception bit.\nIXF, bit [4]        - Inexact trapped exception bit.\nUFF, bit [3]        - Underflow trapped exception bit.\nOFF, bit [2]        - Overflow trapped exception bit.\nDZF, bit [1]        - Divide by Zero trapped exception bit.\nIOF, bit [0]        - Invalid Operation trapped exception bit."
      },
      "FPSCR": {
        "long_name": "Floating-Point Status and Control Register",
        "purpose": "Provides floating-point system status information and control.\n\nN, bit [31]          - Negative condition flag.\nZ, bit [30]          - Zero condition flag.\nC, bit [29]          - Carry condition flag.\nV, bit [28]          - Overflow condition flag.\nQC, bit [27]         - Cumulative saturation bit, Advanced SIMD only.\nAHP, bit [26]        - Alternative half-precision control bit:\nDN, bit [25]         - Default NaN mode control bit:\nFZ, bit [24]         - Flush-to-zero mode control bit:\nRMode, bits [22:23]  - Rounding Mode control field.\nStride, bits [20:21] - It is implementation defined whether this field is RW or\n                       RAZ.\nFZ16, bit [19]       - Flush-to-zero mode control bit on half-precision data-\n                       processing instructions:\nLen, bits [16:18]    - It is implementation defined whether this field is RW or\n                       RAZ.\nIDE, bit [15]        - Input Denormal floating-point exception trap enable.\nIXE, bit [12]        - Inexact floating-point exception trap enable.\nUFE, bit [11]        - Underflow floating-point exception trap enable.\nOFE, bit [10]        - Overflow floating-point exception trap enable.\nDZE, bit [9]         - Divide by Zero floating-point exception trap enable.\nIOE, bit [8]         - Invalid Operation floating-point exception trap enable.\nIDC, bit [7]         - Input Denormal cumulative floating-point exception bit.\nIXC, bit [4]         - Inexact cumulative floating-point exception bit.\nUFC, bit [3]         - Underflow cumulative floating-point exception bit.\nOFC, bit [2]         - Overflow cumulative floating-point exception bit.\nDZC, bit [1]         - Divide by Zero cumulative floating-point exception bit.\nIOC, bit [0]         - Invalid Operation cumulative floating-point exception\n                       bit."
      },
      "FPSID": {
        "long_name": "Floating-Point System ID register",
        "purpose": "Provides top-level information about the floating-point implementation.\n\nThis register largely duplicates information held in the MIDR. Arm deprecates\nuse of it.\n\nImplementer, bits [24:31]     - Implementer codes are the same as those used for\n                                the MIDR. For an implementation by Arm this\n                                field is 0x41, the ASCII code for A.\nSW, bit [23]                  - Software bit.\nSubarchitecture, bits [16:22] - Subarchitecture version number.\nPartNum, bits [8:15]          - An implementation defined part number for the\n                                floating-point implementation, assigned by the\n                                implementer.\nVariant, bits [4:7]           - An implementation defined variant number.\n                                Typically, this field distinguishes between\n                                different production variants of a single\n                                product.\nRevision, bits [0:3]          - An implementation defined revision number for\n                                the floating-point implementation."
      },
      "HACR": {
        "long_name": "Hyp Auxiliary Configuration Register",
        "purpose": "Controls trapping to Hyp mode of implementation defined aspects of Non-secure\nEL1 or EL0 operation."
      },
      "HACTLR": {
        "long_name": "Hyp Auxiliary Control Register",
        "purpose": "Controls implementation defined features of Hyp mode operation."
      },
      "HACTLR2": {
        "long_name": "Hyp Auxiliary Control Register 2",
        "purpose": "Provides additional space to the HACTLR register to hold implementation defined\ntrap functionality."
      },
      "HADFSR": {
        "long_name": "Hyp Auxiliary Data Fault Status Register",
        "purpose": "Provides additional implementation defined syndrome information for Data Abort\nexceptions taken to Hyp mode."
      },
      "HAIFSR": {
        "long_name": "Hyp Auxiliary Instruction Fault Status Register",
        "purpose": "Provides additional implementation defined syndrome information for Prefetch\nAbort exceptions taken to Hyp mode."
      },
      "HAMAIR0": {
        "long_name": "Hyp Auxiliary Memory Attribute Indirection Register 0",
        "purpose": "Provides implementation defined memory attributes for the memory attribute\nencodings defined by HMAIR0. These implementation defined attributes can only\nprovide additional qualifiers for the memory attribute encodings, and cannot\nchange the memory attributes defined in HMAIR0."
      },
      "HAMAIR1": {
        "long_name": "Hyp Auxiliary Memory Attribute Indirection Register 1",
        "purpose": "Provides implementation defined memory attributes for the memory attribute\nencodings defined by HMAIR1. These implementation defined attributes can only\nprovide additional qualifiers for the memory attribute encodings, and cannot\nchange the memory attributes defined in HMAIR1."
      },
      "HCPTR": {
        "long_name": "Hyp Architectural Feature Trap Register",
        "purpose": "Controls:\n\n  - Trapping to Hyp mode of Non-secure access, at EL1 or EL0, to trace, and to\nAdvanced SIMD and floating-point functionality.\n  - Hyp mode access to trace, and to Advanced SIMD and floating-point\nfunctionality.\n\nAccesses to this functionality:\n  - From Non-secure modes other than Hyp mode are also affected by settings in\nthe CPACR and NSACR.\n  - From Hyp mode are also affected by settings in the NSACR.Exceptions\ngenerated by the CPACR and NSACR controls are higher priority than those\ngenerated by the HCPTR controls.\n\nTCPAC, bit [31] - Traps Non-secure EL1 accesses to the CPACR to Hyp mode.\nTAM, bit [30]   - Trap Activity Monitor access.\nTTA, bit [20]   - Traps Non-secure System register accesses to all implemented\n                  trace registers to Hyp mode.\nTASE, bit [15]  - Traps Non-secure execution of Advanced SIMD instructions to\n                  Hyp mode when the value of HCPTR.TCP10 is 0.\nTCP11, bit [11] - The value of this field is ignored.\nTCP10, bit [10] - Trap Non-secure accesses to Advanced SIMD and floating-point\n                  functionality to Hyp mode:"
      },
      "HCR": {
        "long_name": "Hyp Configuration Register",
        "purpose": "Provides configuration controls for virtualization, including defining whether\nvarious Non-secure operations are trapped to Hyp mode.\n\nTRVM, bit [30]    - Trap Reads of Virtual Memory controls.\nHCD, bit [29]     - HVC instruction disable.\nTGE, bit [27]     - Trap General Exceptions, from Non-secure EL0.\nTVM, bit [26]     - Trap Virtual Memory controls.\nTTLB, bit [25]    - Trap TLB maintenance instructions.\nTPU, bit [24]     - Trap cache maintenance instructions that operate to the\n                    Point of Unification.\nTPC, bit [23]     - Trap data or unified cache maintenance instructions that\n                    operate to the Point of Coherency.\nTSW, bit [22]     - Trap data or unified cache maintenance instructions that\n                    operate by Set/Way.\nTAC, bit [21]     - Trap Auxiliary Control Registers.\nTIDCP, bit [20]   - Trap implementation defined functionality.\nTSC, bit [19]     - Trap SMC instructions.\nTID3, bit [18]    - Trap ID group 3.\nTID2, bit [17]    - Trap ID group 2.\nTID1, bit [16]    - Trap ID group 1.\nTID0, bit [15]    - Trap ID group 0.\nTWE, bit [14]     - Traps Non-secure EL0 and EL1 execution of WFE instructions\n                    to EL2, when EL2 is enabled in the current Security state.\nTWI, bit [13]     - Traps Non-secure EL0 and EL1 execution of WFI instructions\n                    to EL2, when EL2 is enabled in the current Security state.\nDC, bit [12]      - Default Cacheability.\nBSU, bits [10:11] - Barrier Shareability upgrade.\nFB, bit [9]       - Force broadcast.\nVA, bit [8]       - Virtual SError interrupt exception.\nVI, bit [7]       - Virtual IRQ exception.\nVF, bit [6]       - Virtual FIQ exception.\nAMO, bit [5]      - SError interrupt Mask Override.\nIMO, bit [4]      - IRQ Mask Override.\nFMO, bit [3]      - FIQ Mask Override.\nPTW, bit [2]      - Protected Table Walk.\nSWIO, bit [1]     - Set/Way Invalidation Override.\nVM, bit [0]       - Virtualization enable."
      },
      "HCR2": {
        "long_name": "Hyp Configuration Register 2",
        "purpose": "Provides additional configuration controls for virtualization.\n\nTTLBIS, bit [22] - Trap TLB maintenance instructions that operate on the Inner\n                   Shareable domain.\nTOCU, bit [20]   - Trap cache maintenance instructions that operate to the Point\n                   of Unification.\nTICAB, bit [18]  - Trap ICIALLUIS cache maintenance instructions.\nTID4, bit [17]   - Trap ID group 4.\nMIOCNCE, bit [6] - Mismatched Inner/Outer Cacheable Non-Coherency Enable, for\n                   the Non-secure PL1&0 translation regime.\nTEA, bit [5]     - Route synchronous External abort exceptions from EL0 and EL1\n                   to EL2.\nTERR, bit [4]    - Trap Error record accesses from EL1 to EL2.\nID, bit [1]      - Stage 2 Instruction access cacheability disable.\nCD, bit [0]      - Stage 2 Data access cacheability disable."
      },
      "HDCR": {
        "long_name": "Hyp Debug Control Register",
        "purpose": "Controls the trapping to Hyp mode of Non-secure accesses, at EL1 or lower, to\nfunctions provided by the debug and trace architectures and the Performance\nMonitors Extension.\n\nHPMFZO, bit [29] - Hyp Performance Monitors Freeze-on-overflow.\nMTPME, bit [28]  - Multi-threaded PMU Enable.\nTDCC, bit [27]   - Trap DCC.\nHLP, bit [26]    - Hypervisor Long event counter enable.\nHCCD, bit [23]   - Hypervisor Cycle Counter Disable.\nTTRF, bit [19]   - Traps use of the Trace Filter Control registers at EL1 to\n                   EL2.\nHPMD, bit [17]   - Guest Performance Monitors Disable.\nHPMD, bit [17]   - Guest Performance Monitors Disable.\nTDRA, bit [11]   - Trap Debug ROM Address register access.\nTDOSA, bit [10]  - Trap debug OS-related register access.\nTDOSA, bit [10]  - Trap debug OS-related register access.\nTDA, bit [9]     - Trap debug access.\nTDE, bit [8]     - Trap Debug exceptions.\nHPME, bit [7]    - [HDCR.HPMN..(N-1)] event counters enable.\nTPM, bit [6]     - Trap Performance Monitors accesses.\nTPMCR, bit [5]   - Trap PMCR accesses.\nHPMN, bits [0:4] - Defines the number of event counters that are accessible from\n                   Non-secure EL1 modes, and from Non-secure EL0 modes if\n                   unprivileged access is enabled."
      },
      "HDFAR": {
        "long_name": "Hyp Data Fault Address Register",
        "purpose": "Holds the virtual address of the faulting address that caused a synchronous Data\nAbort exception that is taken to Hyp mode.\n\nbits [0:31] - VA of faulting address of synchronous Data Abort exception taken\n              to Hyp mode. On a Prefetch Abort exception, this register is\n              unknown. Any execution in a Non-secure EL1 or Non-secure EL0 mode\n              makes this register unknown."
      },
      "HIFAR": {
        "long_name": "Hyp Instruction Fault Address Register",
        "purpose": "Holds the virtual address of the faulting address that caused a synchronous\nPrefetch Abort exception that is taken to Hyp mode.\n\nbits [0:31] - VA of faulting address of synchronous Prefetch Abort exception\n              taken to Hyp mode. On a Data Abort exception, this register is\n              unknown. Any execution in a Non-secure EL1 or Non-secure EL0 mode\n              makes this register unknown."
      },
      "HMAIR0": {
        "long_name": "Hyp Memory Attribute Indirection Register 0",
        "purpose": "Along with HMAIR1, provides the memory attribute encodings corresponding to the\npossible AttrIndx values in a Long-descriptor format translation table entry for\nstage 1 translations for memory accesses from Hyp mode.\n\nAttrIndx[2] indicates the HMAIR register to be used:\n\n  - When AttrIndx[2] is 0, HMAIR0 is used.\n  - When AttrIndx[2] is 1, HMAIR1 is used.\n\nAttr<n>, bits [0:31] - The memory attribute encoding for an AttrIndx[2:0] entry\n                       in a Long descriptor format translation table entry,\n                       where:\n                         - AttrIndx[2:0] gives the value of <n> in Attr<n>.\n                         - AttrIndx[2] defines which MAIR to access. Attr7 to\n                       Attr4 are in MAIR1, and Attr3 to Attr0 are in MAIR0. Bits\n                       [7:4] are encoded as follows: R = Outer Read-Allocate\n                       policy, W = Outer Write-Allocate policy. The meaning of\n                       bits [3:0] depends on the value of bits [7:4]: R = Inner\n                       Read-Allocate policy, W = Inner Write-Allocate policy.\n                       The R and W bits in some Attr<n> fields have the\n                       following meanings: When FEAT_XS is implemented, stage 1\n                       Inner Write-Back Cacheable, Outer Write-Back Cacheable\n                       memory types have the XS attribute set to 0."
      },
      "HMAIR1": {
        "long_name": "Hyp Memory Attribute Indirection Register 1",
        "purpose": "Along with HMAIR0, provides the memory attribute encodings corresponding to the\npossible AttrIndx values in a Long-descriptor format translation table entry for\nstage 1 translations for memory accesses from Hyp mode.\n\nAttrIndx[2] indicates the HMAIR register to be used:\n\n  - When AttrIndx[2] is 0, HMAIR0 is used.\n  - When AttrIndx[2] is 1, HMAIR1 is used.\n\nAttr<n>, bits [0:31] - The memory attribute encoding for an AttrIndx[2:0] entry\n                       in a Long descriptor format translation table entry,\n                       where:\n                         - AttrIndx[2:0] gives the value of <n> in Attr<n>.\n                         - AttrIndx[2] defines which MAIR to access. Attr7 to\n                       Attr4 are in MAIR1, and Attr3 to Attr0 are in MAIR0. Bits\n                       [7:4] are encoded as follows: R = Outer Read-Allocate\n                       policy, W = Outer Write-Allocate policy. The meaning of\n                       bits [3:0] depends on the value of bits [7:4]: R = Inner\n                       Read-Allocate policy, W = Inner Write-Allocate policy.\n                       The R and W bits in some Attr<n> fields have the\n                       following meanings: When FEAT_XS is implemented, stage 1\n                       Inner Write-Back Cacheable, Outer Write-Back Cacheable\n                       memory types have the XS attribute set to 0."
      },
      "HPFAR": {
        "long_name": "Hyp IPA Fault Address Register",
        "purpose": "Holds the faulting IPA for some aborts on a stage 2 translation taken to Hyp\nmode.\n\nFIPA[39:12], bits [4:31] - Bits [39:12] of the faulting intermediate physical\n                           address."
      },
      "HRMR": {
        "long_name": "Hyp Reset Management Register",
        "purpose": "If EL2 is the highest implemented Exception level and this register is\nimplemented:\n\n  - A write to the register at EL2 can request a Warm reset.\n  - If EL2 can use AArch32 and AArch64, this register specifies the Execution\nstate that the PE boots into on a Warm reset.\n\nRR, bit [1]   - Reset Request. Setting this bit to 1 requests a Warm reset.\nAA64, bit [0] - When EL2 can use AArch64, determines which Execution state the\n                PE boots into after a Warm reset:\n                    0b0 AArch32.\n                    0b1 AArch64.\n                On coming out of the Warm reset, execution starts at the\n                implementation defined reset vector address of the specified\n                Execution state. If EL2 cannot use AArch64 this bit is RAZ/WI."
      },
      "HSCTLR": {
        "long_name": "Hyp System Control Register",
        "purpose": "Provides top level control of the system operation in Hyp mode.\n\nDSSBS, bit [31]  - Default PSTATE.SSBS value on Exception Entry.\nTE, bit [30]     - T32 Exception Enable.\nEE, bit [25]     - The value of the PSTATE.E bit on entry to Hyp mode, the\n                   endianness of stage 1 translation table walks in the EL2\n                   translation regime, and the endianness of stage 2 translation\n                   table walks in the PL1&0 translation regime.\nWXN, bit [19]    - Write permission implies XN (Execute-never). For the EL2\n                   translation regime, this bit can force all memory regions\n                   that are writable to be treated as XN.\nI, bit [12]      - Instruction access Cacheability control, for accesses at EL2:\nSED, bit [8]     - SETEND instruction disable. Disables SETEND instructions at\n                   EL2.\nITD, bit [7]     - IT Disable. Disables some uses of IT instructions at EL2.\nCP15BEN, bit [5] - System instruction memory barrier enable.\nLSMAOE, bit [4]  - Load Multiple and Store Multiple Atomicity and Ordering\n                   Enable.\nnTLSMD, bit [3]  - No Trap Load Multiple and Store Multiple to Device-\n                   nGRE/Device-nGnRE/Device-nGnRnE memory.\nC, bit [2]       - Cacheability control, for data accesses at EL2:\nA, bit [1]       - Alignment check enable.\nM, bit [0]       - MMU enable for EL2 stage 1 address translation."
      },
      "HSR": {
        "long_name": "Hyp Syndrome Register",
        "purpose": "Holds syndrome information for an exception taken to Hyp mode.\n\nEC, bits [26:31] - Exception Class. Indicates the reason for the exception that\n                   this register holds information about.\nIL, bit [25]     - Instruction length bit. Indicates the size of the instruction\n                   that has been trapped to Hyp mode.\nISS, bits [0:24] - Instruction Specific Syndrome. Architecturally, this field\n                   can be defined independently for each defined Exception\n                   class. However, in practice, some ISS encodings are used for\n                   more than one Exception class."
      },
      "HSTR": {
        "long_name": "Hyp System Trap Register",
        "purpose": "Controls trapping to Hyp mode of Non-secure accesses, at EL1 or lower, to System\nregisters in the coproc == 0b1111 encoding space:\n\n  - By the CRn value used to access the register using MCR or MRC instruction.\n  - By the CRm value used to access the register using MCRR or MRRC instruction.\n\nT<n>, bit [15] - The remaining fields control whether Non-secure EL0 and EL1\n                 accesses, using MCR, MRC, MCRR, and MRRC instructions, to the\n                 System registers in the coproc == 0b1111 encoding space are\n                 trapped to Hyp mode:\nT15, bit [15]  - The remaining fields control whether Non-secure EL0 and EL1\n                 accesses, using MCR, MRC, MCRR, and MRRC instructions, to the\n                 System registers in the coproc == 0b1111 encoding space are\n                 trapped to Hyp mode:\nT13, bit [13]  - The remaining fields control whether Non-secure EL0 and EL1\n                 accesses, using MCR, MRC, MCRR, and MRRC instructions, to the\n                 System registers in the coproc == 0b1111 encoding space are\n                 trapped to Hyp mode:\nT12, bit [12]  - The remaining fields control whether Non-secure EL0 and EL1\n                 accesses, using MCR, MRC, MCRR, and MRRC instructions, to the\n                 System registers in the coproc == 0b1111 encoding space are\n                 trapped to Hyp mode:\nT11, bit [11]  - The remaining fields control whether Non-secure EL0 and EL1\n                 accesses, using MCR, MRC, MCRR, and MRRC instructions, to the\n                 System registers in the coproc == 0b1111 encoding space are\n                 trapped to Hyp mode:\nT10, bit [10]  - The remaining fields control whether Non-secure EL0 and EL1\n                 accesses, using MCR, MRC, MCRR, and MRRC instructions, to the\n                 System registers in the coproc == 0b1111 encoding space are\n                 trapped to Hyp mode:\nT9, bit [9]    - The remaining fields control whether Non-secure EL0 and EL1\n                 accesses, using MCR, MRC, MCRR, and MRRC instructions, to the\n                 System registers in the coproc == 0b1111 encoding space are\n                 trapped to Hyp mode:\nT8, bit [8]    - The remaining fields control whether Non-secure EL0 and EL1\n                 accesses, using MCR, MRC, MCRR, and MRRC instructions, to the\n                 System registers in the coproc == 0b1111 encoding space are\n                 trapped to Hyp mode:\nT7, bit [7]    - The remaining fields control whether Non-secure EL0 and EL1\n                 accesses, using MCR, MRC, MCRR, and MRRC instructions, to the\n                 System registers in the coproc == 0b1111 encoding space are\n                 trapped to Hyp mode:\nT6, bit [6]    - The remaining fields control whether Non-secure EL0 and EL1\n                 accesses, using MCR, MRC, MCRR, and MRRC instructions, to the\n                 System registers in the coproc == 0b1111 encoding space are\n                 trapped to Hyp mode:\nT5, bit [5]    - The remaining fields control whether Non-secure EL0 and EL1\n                 accesses, using MCR, MRC, MCRR, and MRRC instructions, to the\n                 System registers in the coproc == 0b1111 encoding space are\n                 trapped to Hyp mode:\nT3, bit [3]    - The remaining fields control whether Non-secure EL0 and EL1\n                 accesses, using MCR, MRC, MCRR, and MRRC instructions, to the\n                 System registers in the coproc == 0b1111 encoding space are\n                 trapped to Hyp mode:\nT2, bit [2]    - The remaining fields control whether Non-secure EL0 and EL1\n                 accesses, using MCR, MRC, MCRR, and MRRC instructions, to the\n                 System registers in the coproc == 0b1111 encoding space are\n                 trapped to Hyp mode:\nT1, bit [1]    - The remaining fields control whether Non-secure EL0 and EL1\n                 accesses, using MCR, MRC, MCRR, and MRRC instructions, to the\n                 System registers in the coproc == 0b1111 encoding space are\n                 trapped to Hyp mode:\nT0, bit [0]    - The remaining fields control whether Non-secure EL0 and EL1\n                 accesses, using MCR, MRC, MCRR, and MRRC instructions, to the\n                 System registers in the coproc == 0b1111 encoding space are\n                 trapped to Hyp mode:"
      },
      "HTCR": {
        "long_name": "Hyp Translation Control Register",
        "purpose": "The control register for stage 1 of the EL2 translation regime.\n\nThis stage of translation always uses the Long-descriptor translation table\nformat.\n\nHWU62, bit [28]     - Hardware Use. Indicates implementation defined hardware\n                      use of bit[62] of the stage 1 translation table Block or\n                      Page entry.\nHWU61, bit [27]     - Hardware Use. Indicates implementation defined hardware\n                      use of bit[61] of the stage 1 translation table Block or\n                      Page entry.\nHWU60, bit [26]     - Hardware Use. Indicates implementation defined hardware\n                      use of bit[60] of the stage 1 translation table Block or\n                      Page entry.\nHWU59, bit [25]     - Hardware Use. Indicates implementation defined hardware\n                      use of bit[59] of the stage 1 translation table Block or\n                      Page entry.\nHPD, bit [24]       - Hierarchical Permission Disables. This affects the\n                      hierarchical control bits, APTable, XNTable, and PXNTable,\n                      in the PL2 translation regime.\nSH0, bits [12:13]   - Shareability attribute for memory associated with\n                      translation table walks using HTTBR.\nORGN0, bits [10:11] - Outer cacheability attribute for memory associated with\n                      translation table walks using HTTBR.\nIRGN0, bits [8:9]   - Inner cacheability attribute for memory associated with\n                      translation table walks using HTTBR.\nT0SZ, bits [0:2]    - The size offset of the memory region addressed by HTTBR.\n                      The region size is 2^(32-T0SZ) bytes."
      },
      "HTPIDR": {
        "long_name": "Hyp Software Thread ID Register",
        "purpose": "Provides a location where software running in Hyp mode can store thread\nidentifying information that is not visible to Non-secure software executing at\nEL0 or EL1, for hypervisor management purposes.\n\nThe PE makes no use of this register.\n\nbits [0:31] - Thread ID. Thread identifying information stored by software\n              running at this Exception level."
      },
      "HTRFCR": {
        "long_name": "Hyp Trace Filter Control Register",
        "purpose": "Provides EL2 controls for Trace.\n\nTS, bits [5:6]  - Timestamp Control. Controls which timebase is used for trace\n                  timestamps.\n                      0b00 The timestamp is controlled by TRFCR.TS.\n                      0b01 Virtual timestamp. The traced timestamp is the\n                  physical counter value minus the value of CNTVOFF.\n                      0b11 Physical timestamp. The traced timestamp is the\n                  physical counter value.\n                  When SelfHostedTraceEnabled() == FALSE, this field is ignored.\nCX, bit [3]     - VMID Trace Enable.\n                      0b0 VMID tracing is not allowed.\n                      0b1 VMID tracing is allowed.\n                  When SelfHostedTraceEnabled() == FALSE, this field is ignored.\nE2TRE, bit [1]  - EL2 Trace Enable.\n                      0b0 Tracing is prohibited at EL2.\n                      0b1 Tracing is allowed at EL2.\n                  When SelfHostedTraceEnabled() == FALSE, this field is ignored.\nE0HTRE, bit [0] - EL0 Trace Enable.\n                      0b0 Tracing is prohibited at EL0 when HCR.TGE == 1.\n                      0b1 Tracing is allowed at EL0 when HCR.TGE == 1.\n                  This field is ignored if any of the following are true:\n                    - The PE is in Secure state.\n                    - SelfHostedTraceEnabled() == FALSE.\n                    - HCR.TGE == 0."
      },
      "HTTBR": {
        "long_name": "Hyp Translation Table Base Register",
        "purpose": "Holds the base address of the translation table for the initial lookup for stage\n1 of an address translation in the EL2 translation regime, and other information\nfor this translation regime.\n\nBADDR, bits [1:47] - Translation table base address, bits[47:x], Bits [x-1:1]\n                     are res0, with the additional requirement that if\n                     bits[x-1:3] are not all zero, this is a misaligned\n                     translation table base address, with effects that are\n                     constrained unpredictable, and must be one of the\n                     following:\n                       - Register bits [x-1:3] are treated as if all the bits\n                     are zero. The value read back from these bits is either the\n                     value written or zero.\n                       - The result of the calculation of an address for a\n                     translation table walk using this register can be corrupted\n                     in those bits that are nonzero. x is determined from the\n                     value of HTCR.T0SZ as follows:\n                       - If HTCR.T0SZ is 0 or 1, x = 5 - HTCR.T0SZ.\n                       - If HTCR.T0SZ is greater than 1, x = 14 - HTCR.T0SZ. If\n                     bits[47:40] of the translation table base address are not\n                     zero, an Address size fault is generated.\nCnP, bit [0]       - Common not Private. This bit indicates whether each entry\n                     that is pointed to by HTTBR is a member of a common set\n                     that can be used by every PE in the Inner Shareable domain\n                     for which the value of HTTBR.CnP is 1."
      },
      "HVBAR": {
        "long_name": "Hyp Vector Base Address Register",
        "purpose": "Holds the vector base address for any exception that is taken to Hyp mode.\n\nbits [5:31] - Vector Base Address. Bits[31:5] of the base address of the\n              exception vectors for exceptions taken to this Exception level.\n              Bits[4:0] of an exception vector are the exception offset."
      },
      "ICC_AP0R<n>": {
        "long_name": "Interrupt Controller Active Priorities Group 0 Registers",
        "purpose": "Provides information about Group 0 active priorities."
      },
      "ICC_AP1R<n>": {
        "long_name": "Interrupt Controller Active Priorities Group 1 Registers",
        "purpose": "Provides information about Group 1 active priorities."
      },
      "ICC_ASGI1R": {
        "long_name": "Interrupt Controller Alias Software Generated Interrupt Group 1 Register",
        "purpose": "Generates Group 1 SGIs for the Security state that is not the current Security\nstate.\n\nAff3, bits [48:55]      - The affinity 3 value of the affinity path of the\n                          cluster for which SGI interrupts will be generated.\nRS, bits [44:47]        - RangeSelector Controls which group of 16 values is\n                          represented by the TargetList field.\nIRM, bit [40]           - Interrupt Routing Mode.\nAff2, bits [32:39]      - The affinity 2 value of the affinity path of the\n                          cluster for which SGI interrupts will be generated.\nINTID, bits [24:27]     - The INTID of the SGI.\nAff1, bits [16:23]      - The affinity 1 value of the affinity path of the\n                          cluster for which SGI interrupts will be generated.\nTargetList, bits [0:15] - Target List."
      },
      "ICC_BPR0": {
        "long_name": "Interrupt Controller Binary Point Register 0",
        "purpose": "Defines the point at which the priority value fields split into two parts, the\ngroup priority field and the subpriority field. The group priority field\ndetermines Group 0 interrupt preemption.\n\nBinaryPoint, bits [0:2] - The value of this field controls how the 8-bit\n                          interrupt priority field is split into a group\n                          priority field, that determines interrupt preemption,\n                          and a subpriority field. This is done as follows:"
      },
      "ICC_BPR1": {
        "long_name": "Interrupt Controller Binary Point Register 1",
        "purpose": "Defines the point at which the priority value fields split into two parts, the\ngroup priority field and the subpriority field. The group priority field\ndetermines Group 1 interrupt preemption.\n\nBinaryPoint, bits [0:2] - If the GIC is configured to use separate binary point\n                          fields for Group 0 and Group 1 interrupts, the value\n                          of this field controls how the 8-bit interrupt\n                          priority field is split into a group priority field,\n                          that determines interrupt preemption, and a\n                          subpriority field. For more information about\n                          priorities, see 'Priority grouping' in ARM\u00ae Generic\n                          Interrupt Controller Architecture Specification, GIC\n                          architecture version 3.0 and version 4.0 (ARM IHI\n                          0069). Writing 0 to this field will set this field to\n                          its reset value. If EL3 is implemented and\n                          ICC_MCTLR.CBPR_EL1S is 1:\n                            - Accesses to this register at EL3 not in Monitor\n                          mode access the state of ICC_BPR0.\n                            - When SCR_EL3.EEL2 is 1 and HCR_EL2.IMO is 1,\n                          Secure accesses to this register at EL1 access the\n                          state of ICV_BPR1.\n                            - Otherwise, Secure accesses to this register at EL1\n                          access the state of ICC_BPR0. If EL3 is implemented\n                          and ICC_MCTLR.CBPR_EL1NS is 1, Non-secure accesses to\n                          this register at EL1 or EL2 behave as follows,\n                          depending on the values of HCR.IMO and SCR.IRQ: If EL3\n                          is not implemented and ICC_CTLR.CBPR is 1, Non-secure\n                          accesses to this register at EL1 or EL2 behave as\n                          follows, depending on the values of HCR.IMO:"
      },
      "ICC_CTLR": {
        "long_name": "Interrupt Controller Control Register",
        "purpose": "Controls aspects of the behavior of the GIC CPU interface and provides\ninformation about the features implemented.\n\nExtRange, bit [19]   - Extended INTID range (read-only).\nRSS, bit [18]        - Range Selector Support.\nA3V, bit [15]        - Affinity 3 Valid. Read-only and writes are ignored.\nSEIS, bit [14]       - SEI Support. Read-only and writes are ignored.\nIDbits, bits [11:13] - Identifier bits. Read-only and writes are ignored.\nPRIbits, bits [8:10] - Priority bits. Read-only and writes are ignored. The\n                       number of priority bits implemented, minus one. An\n                       implementation that supports two Security states must\n                       implement at least 32 levels of physical priority (5\n                       priority bits). An implementation that supports only a\n                       single Security state must implement at least 16 levels\n                       of physical priority (4 priority bits). This field always\n                       returns the number of priority bits implemented,\n                       regardless of the Security state of the access or the\n                       value of GICD_CTLR.DS. The division between group\n                       priority and subpriority is defined in the binary point\n                       registers ICC_BPR0 and ICC_BPR1. If EL3 is implemented\n                       and using AArch32, physical accesses return the value\n                       from ICC_MCTLR.PRIbits. If EL3 is implemented and using\n                       AArch64, physical accesses return the value from\n                       ICC_CTLR_EL3.PRIbits. If EL3 is not implemented, physical\n                       accesses return the value from this field.\nPMHE, bit [6]        - Priority Mask Hint Enable.\nEOImode, bit [1]     - EOI mode for the current Security state.\nCBPR, bit [0]        - Common Binary Point Register."
      },
      "ICC_DIR": {
        "long_name": "Interrupt Controller Deactivate Interrupt Register",
        "purpose": "When interrupt priority drop is separated from interrupt deactivation, a write\nto this register deactivates the specified interrupt.\n\nINTID, bits [0:23] - The INTID of the interrupt to be deactivated. This field\n                     has either 16 or 24 bits implemented. The number of\n                     implemented bits can be found in ICC_CTLR.IDbits and\n                     ICC_MCTLR.IDbits. If only 16 bits are implemented, bits\n                     [23:16] of this register are res0."
      },
      "ICC_EOIR0": {
        "long_name": "Interrupt Controller End Of Interrupt Register 0",
        "purpose": "A PE writes to this register to inform the CPU interface that it has completed\nthe processing of the specified Group 0 interrupt.\n\nINTID, bits [0:23] - The INTID from the corresponding ICC_IAR0 access. This\n                     field has either 16 or 24 bits implemented. The number of\n                     implemented bits can be found in ICC_CTLR.IDbits and\n                     ICC_MCTLR.IDbits. If only 16 bits are implemented, bits\n                     [23:16] of this register are res0. If the EOImode bit for\n                     the current Exception level and Security state is 0, a\n                     write to this register drops the priority for the\n                     interrupt, and also deactivates the interrupt. If the\n                     EOImode bit for the current Exception level and Security\n                     state is 1, a write to this register only drops the\n                     priority for the interrupt. Software must write to ICC_DIR\n                     to deactivate the interrupt. The appropriate EOImode bit\n                     varies as follows:\n                       - If EL3 is not implemented, the appropriate bit is\n                     ICC_CTLR.EOImode.\n                       - If EL3 is implemented and the software is executing in\n                     Monitor mode, the appropriate bit is ICC_MCTLR.EOImode_EL3.\n                       - If EL3 is implemented and the software is not executing\n                     in Monitor mode, the bit depends on the current Security\n                     state:\n                         - If the software is executing in Secure state, the bit\n                     is ICC_CTLR.EOImode in the Secure instance of ICC_CTLR.\n                     This is an alias of ICC_MCTLR.EOImode_EL1S.\n                         - If the software is executing in Non-secure state, the\n                     bit is ICC_CTLR.EOImode in the Non-secure instance of\n                     ICC_CTLR. This is an alias of ICC_MCTLR.EOImode_EL1NS."
      },
      "ICC_EOIR1": {
        "long_name": "Interrupt Controller End Of Interrupt Register 1",
        "purpose": "A PE writes to this register to inform the CPU interface that it has completed\nthe processing of the specified Group 1 interrupt.\n\nINTID, bits [0:23] - The INTID from the corresponding ICC_IAR1 access. This\n                     field has either 16 or 24 bits implemented. The number of\n                     implemented bits can be found in ICC_CTLR.IDbits and\n                     ICC_MCTLR.IDbits. If only 16 bits are implemented, bits\n                     [23:16] of this register are res0. If the EOImode bit for\n                     the current Exception level and Security state is 0, a\n                     write to this register drops the priority for the\n                     interrupt, and also deactivates the interrupt. If the\n                     EOImode bit for the current Exception level and Security\n                     state is 1, a write to this register only drops the\n                     priority for the interrupt. Software must write to ICC_DIR\n                     to deactivate the interrupt. The appropriate EOImode bit\n                     varies as follows:\n                       - If EL3 is not implemented, the appropriate bit is\n                     ICC_CTLR.EOImode.\n                       - If EL3 is implemented and the software is executing in\n                     Monitor mode, the appropriate bit is ICC_MCTLR.EOImode_EL3.\n                       - If EL3 is implemented and the software is not executing\n                     in Monitor mode, the bit depends on the current Security\n                     state:\n                         - If the software is executing in Secure state, the bit\n                     is ICC_CTLR.EOImode in the Secure instance of ICC_CTLR.\n                     This is an alias of ICC_MCTLR.EOImode_EL1S.\n                         - If the software is executing in Non-secure state, the\n                     bit is ICC_CTLR.EOImode in the Non-secure instance of\n                     ICC_CTLR. This is an alias of ICC_MCTLR.EOImode_EL1NS."
      },
      "ICC_HPPIR0": {
        "long_name": "Interrupt Controller Highest Priority Pending Interrupt Register 0",
        "purpose": "Indicates the highest priority pending Group 0 interrupt on the CPU interface.\n\nINTID, bits [0:23] - The INTID of the highest priority pending interrupt, if\n                     that interrupt is observable at the current Security state\n                     and Exception level. If the highest priority pending\n                     interrupt is not observable, this field contains a special\n                     INTID to indicate the reason. These special INTIDs can be\n                     one of: 1020, 1021, or 1023. For more information, see\n                     'Special INTIDs' in ARM\u00ae Generic Interrupt Controller\n                     Architecture Specification, GIC architecture version 3.0\n                     and version 4.0 (ARM IHI 0069). This field has either 16 or\n                     24 bits implemented. The number of implemented bits can be\n                     found in ICC_CTLR.IDbits and ICC_MCTLR.IDbits. If only 16\n                     bits are implemented, bits [23:16] of this register are\n                     res0."
      },
      "ICC_HPPIR1": {
        "long_name": "Interrupt Controller Highest Priority Pending Interrupt Register 1",
        "purpose": "Indicates the highest priority pending Group 1 interrupt on the CPU interface.\n\nINTID, bits [0:23] - The INTID of the highest priority pending interrupt, if\n                     that interrupt is observable at the current Security state\n                     and Exception level. If the highest priority pending\n                     interrupt is not observable, this field contains a special\n                     INTID to indicate the reason. This special INTID can take\n                     the value 1023 only. For more information, see 'Special\n                     INTIDs' in ARM\u00ae Generic Interrupt Controller Architecture\n                     Specification, GIC architecture version 3.0 and version 4.0\n                     (ARM IHI 0069). This field has either 16 or 24 bits\n                     implemented. The number of implemented bits can be found in\n                     ICC_CTLR.IDbits and ICC_MCTLR.IDbits. If only 16 bits are\n                     implemented, bits [23:16] of this register are res0."
      },
      "ICC_HSRE": {
        "long_name": "Interrupt Controller Hyp System Register Enable register",
        "purpose": "Controls whether the System register interface or the memory-mapped interface to\nthe GIC CPU interface is used for EL2.\n\nEnable, bit [3] - Enable. Enables lower Exception level access to ICC_SRE.\n                      0b0 Non-secure EL1 accesses to ICC_SRE trap to EL2.\n                      0b1 Non-secure EL1 accesses to ICC_SRE do not trap to EL2.\nDIB, bit [2]    - Disable IRQ bypass.\n                      0b0 IRQ bypass enabled.\n                      0b1 IRQ bypass disabled.\nDFB, bit [1]    - Disable FIQ bypass.\n                      0b0 FIQ bypass enabled.\n                      0b1 FIQ bypass disabled.\nSRE, bit [0]    - System Register Enable.\n                      0b0 The memory-mapped interface must be used. Accesses at\n                  EL2 or below to any ICH_* System register, or any EL1 or EL2\n                  ICC_* register other than ICC_SRE or ICC_HSRE, are undefined.\n                      0b1 The System register interface to the ICH_* registers\n                  and the EL1 and EL2 ICC_* registers is enabled for EL2."
      },
      "ICC_IAR0": {
        "long_name": "Interrupt Controller Interrupt Acknowledge Register 0",
        "purpose": "The PE reads this register to obtain the INTID of the signaled Group 0\ninterrupt. This read acts as an acknowledge for the interrupt.\n\nINTID, bits [0:23] - The INTID of the signaled interrupt. This is the INTID of\n                     the highest priority pending interrupt, if that interrupt\n                     is of sufficient priority for it to be signaled to the PE,\n                     and if it can be acknowledged at the current Security state\n                     and Exception level. If the highest priority pending\n                     interrupt is not observable, this field contains a special\n                     INTID to indicate the reason. These special INTIDs can be\n                     one of: 1020, 1021, or 1023. For more information, see\n                     'Special INTIDs' in ARM\u00ae Generic Interrupt Controller\n                     Architecture Specification, GIC architecture version 3.0\n                     and version 4.0 (ARM IHI 0069). This field has either 16 or\n                     24 bits implemented. The number of implemented bits can be\n                     found in ICC_CTLR.IDbits and ICC_MCTLR.IDbits. If only 16\n                     bits are implemented, bits [23:16] of this register are\n                     res0."
      },
      "ICC_IAR1": {
        "long_name": "Interrupt Controller Interrupt Acknowledge Register 1",
        "purpose": "The PE reads this register to obtain the INTID of the signaled Group 1\ninterrupt. This read acts as an acknowledge for the interrupt.\n\nINTID, bits [0:23] - The INTID of the signaled interrupt. This is the INTID of\n                     the highest priority pending interrupt, if that interrupt\n                     is of sufficient priority for it to be signaled to the PE,\n                     and if it can be acknowledged at the current Security state\n                     and Exception level. If the highest priority pending\n                     interrupt is not observable, this field contains a special\n                     INTID to indicate the reason. This special INTID can take\n                     the value 1023 only. For more information, see 'Special\n                     INTIDs' in ARM\u00ae Generic Interrupt Controller Architecture\n                     Specification, GIC architecture version 3.0 and version 4.0\n                     (ARM IHI 0069). This field has either 16 or 24 bits\n                     implemented. The number of implemented bits can be found in\n                     ICC_CTLR.IDbits and ICC_MCTLR.IDbits. If only 16 bits are\n                     implemented, bits [23:16] of this register are res0."
      },
      "ICC_IGRPEN0": {
        "long_name": "Interrupt Controller Interrupt Group 0 Enable register",
        "purpose": "Controls whether Group 0 interrupts are enabled or not.\n\nEnable, bit [0] - Enables Group 0 interrupts.\n                      0b0 Group 0 interrupts are disabled.\n                      0b1 Group 0 interrupts are enabled.\n                  Virtual accesses to this register update ICH_VMCR.VENG0."
      },
      "ICC_IGRPEN1": {
        "long_name": "Interrupt Controller Interrupt Group 1 Enable register",
        "purpose": "Controls whether Group 1 interrupts are enabled for the current Security state.\n\nEnable, bit [0] - Enables Group 1 interrupts for the current Security state.\n                      0b0 Group 1 interrupts are disabled for the current\n                  Security state.\n                      0b1 Group 1 interrupts are enabled for the current\n                  Security state.\n                  Virtual accesses to this register update ICH_VMCR.VENG1. If\n                  EL3 is present:\n                    - This bit is a read/write alias of\n                  ICC_MGRPEN1.EnableGrp1{S, NS} as appropriate if EL3 is using\n                  AArch32, or ICC_IGRPEN1_EL3.EnableGrp1{S, NS} as appropriate\n                  if EL3 is using AArch64.\n                    - When this register is accessed at EL3, the copy of this\n                  register appropriate to the current setting of SCR.NS is\n                  accessed."
      },
      "ICC_MCTLR": {
        "long_name": "Interrupt Controller Monitor Control Register",
        "purpose": "Controls aspects of the behavior of the GIC CPU interface and provides\ninformation about the features implemented.\n\nExtRange, bit [19]     - Extended INTID range (read-only).\nRSS, bit [18]          - Range Selector Support.\nnDS, bit [17]          - Disable Security not supported.\nA3V, bit [15]          - Affinity 3 Valid.\nSEIS, bit [14]         - SEI Support.\nIDbits, bits [11:13]   - Identifier bits.\nPRIbits, bits [8:10]   - Priority bits.\nPMHE, bit [6]          - Priority Mask Hint Enable.\nRM, bit [5]            - SBZ.\nEOImode_EL1NS, bit [4] - EOI mode for interrupts handled at Non-secure EL1 and\n                         EL2.\nEOImode_EL1S, bit [3]  - EOI mode for interrupts handled at Secure EL1.\nEOImode_EL3, bit [2]   - EOI mode for interrupts handled at EL3.\nCBPR_EL1NS, bit [1]    - Common Binary Point Register, EL1 Non-secure.\nCBPR_EL1S, bit [0]     - Common Binary Point Register, EL1 Secure."
      },
      "ICC_MGRPEN1": {
        "long_name": "Interrupt Controller Monitor Interrupt Group 1 Enable register",
        "purpose": "Controls whether Group 1 interrupts are enabled or not.\n\nEnableGrp1S, bit [1]  - Enables Group 1 interrupts for the Secure state.\n                            0b0 Secure Group 1 interrupts are disabled.\n                            0b1 Secure Group 1 interrupts are enabled.\n                        The Secure ICC_IGRPEN1.Enable bit is a read/write alias\n                        of the ICC_MGRPEN1.EnableGrp1S bit. If the highest\n                        priority pending interrupt for that PE is a Group 1\n                        interrupt using 1 of N model, then the interrupt will\n                        target another PE as a result of the Enable bit changing\n                        from 1 to 0.\nEnableGrp1NS, bit [0] - Enables Group 1 interrupts for the Non-secure state.\n                            0b0 Non-secure Group 1 interrupts are disabled.\n                            0b1 Non-secure Group 1 interrupts are enabled.\n                        The Non-secure ICC_IGRPEN1.Enable bit is a read/write\n                        alias of the ICC_MGRPEN1.EnableGrp1NS bit. If the\n                        highest priority pending interrupt for that PE is a\n                        Group 1 interrupt using 1 of N model, then the interrupt\n                        will target another PE as a result of the Enable bit\n                        changing from 1 to 0."
      },
      "ICC_MSRE": {
        "long_name": "Interrupt Controller Monitor System Register Enable register",
        "purpose": "Controls whether the System register interface or the memory-mapped interface to\nthe GIC CPU interface is used for EL3.\n\nEnable, bit [3] - Enable. Enables lower Exception level access to ICC_SRE and\n                  ICC_HSRE.\n                      0b0 Secure EL1 accesses to Secure ICC_SRE trap to EL3. EL2\n                  accesses to Non-secure ICC_SRE and ICC_HSRE trap to EL3. Non-\n                  secure EL1 accesses to ICC_SRE trap to EL3, unless these\n                  accesses are trapped to EL2 as a result of ICC_HSRE.Enable ==\n                  0.\n                      0b1 Secure EL1 accesses to Secure ICC_SRE do not trap to\n                  EL3. EL2 accesses to Non-secure ICC_SRE and ICC_HSRE do not\n                  trap to EL3. Non-secure EL1 accesses to ICC_SRE do not trap to\n                  EL3.\nDIB, bit [2]    - Disable IRQ bypass.\n                      0b0 IRQ bypass enabled.\n                      0b1 IRQ bypass disabled.\nDFB, bit [1]    - Disable FIQ bypass.\n                      0b0 FIQ bypass enabled.\n                      0b1 FIQ bypass disabled.\nSRE, bit [0]    - System Register Enable.\n                      0b0 The memory-mapped interface must be used. Accesses at\n                  EL3 or below to any ICH_* System register, or any EL1, EL2, or\n                  EL3 ICC_* register other than ICC_SRE, ICC_HSRE, or ICC_MSRE,\n                  are undefined.\n                      0b1 The System register interface to the ICH_* registers\n                  and the EL1, EL2, and EL3 ICC_* registers is enabled for EL3."
      },
      "ICC_PMR": {
        "long_name": "Interrupt Controller Interrupt Priority Mask Register",
        "purpose": "Provides an interrupt priority filter. Only interrupts with a higher priority\nthan the value in this register are signaled to the PE.\n\nPriority, bits [0:7] - The priority mask level for the CPU interface. If the\n                       priority of an interrupt is higher than the value\n                       indicated by this field, the interface signals the\n                       interrupt to the PE. The possible priority field values\n                       are as follows: Unimplemented priority bits are RAZ/WI."
      },
      "ICC_RPR": {
        "long_name": "Interrupt Controller Running Priority Register",
        "purpose": "Indicates the Running priority of the CPU interface.\n\nPriority, bits [0:7] - The current running priority on the CPU interface. This\n                       is the group priority of the current active interrupt.\n                       The priority returned is the group priority as if the BPR\n                       for the current Exception level and Security state was\n                       set to the minimum value of BPR for the number of\n                       implemented priority bits. If 8 bits of priority are\n                       implemented the group priority is bits[7:1] of the\n                       priority."
      },
      "ICC_SGI0R": {
        "long_name": "Interrupt Controller Software Generated Interrupt Group 0 Register",
        "purpose": "Generates Secure Group 0 SGIs.\n\nAff3, bits [48:55]      - The affinity 3 value of the affinity path of the\n                          cluster for which SGI interrupts will be generated.\nRS, bits [44:47]        - RangeSelector Controls which group of 16 values is\n                          represented by the TargetList field.\nIRM, bit [40]           - Interrupt Routing Mode.\nAff2, bits [32:39]      - The affinity 2 value of the affinity path of the\n                          cluster for which SGI interrupts will be generated.\nINTID, bits [24:27]     - The INTID of the SGI.\nAff1, bits [16:23]      - The affinity 1 value of the affinity path of the\n                          cluster for which SGI interrupts will be generated.\nTargetList, bits [0:15] - Target List."
      },
      "ICC_SGI1R": {
        "long_name": "Interrupt Controller Software Generated Interrupt Group 1 Register",
        "purpose": "Generates Group 1 SGIs for the current Security state.\n\nAff3, bits [48:55]      - The affinity 3 value of the affinity path of the\n                          cluster for which SGI interrupts will be generated.\nRS, bits [44:47]        - RangeSelector Controls which group of 16 values is\n                          represented by the TargetList field.\nIRM, bit [40]           - Interrupt Routing Mode.\nAff2, bits [32:39]      - The affinity 2 value of the affinity path of the\n                          cluster for which SGI interrupts will be generated.\nINTID, bits [24:27]     - The INTID of the SGI.\nAff1, bits [16:23]      - The affinity 1 value of the affinity path of the\n                          cluster for which SGI interrupts will be generated.\nTargetList, bits [0:15] - Target List."
      },
      "ICC_SRE": {
        "long_name": "Interrupt Controller System Register Enable register",
        "purpose": "Controls whether the System register interface or the memory-mapped interface to\nthe GIC CPU interface is used for EL0 and EL1.\n\nDIB, bit [2] - Disable IRQ bypass.\n                   0b0 IRQ bypass enabled.\n                   0b1 IRQ bypass disabled.\nDFB, bit [1] - Disable FIQ bypass.\n                   0b0 FIQ bypass enabled.\n                   0b1 FIQ bypass disabled.\nSRE, bit [0] - System Register Enable.\n                   0b0 The memory-mapped interface must be used. Accesses at EL1\n               to any ICC_* System register other than ICC_SRE are undefined.\n                   0b1 The System register interface for the current Security\n               state is enabled."
      },
      "ICH_AP0R<n>": {
        "long_name": "Interrupt Controller Hyp Active Priorities Group 0 Registers",
        "purpose": "Provides information about Group 0 active priorities for EL2.\n\nP<x>, bits [0:31] - Provides the access to the virtual active priorities for\n                    Group 0 interrupts. Possible values of each bit are:\n                        0b0 There is no Group 0 interrupt active at the priority\n                    corresponding to that bit.\n                        0b1 There is a Group 0 interrupt active at the priority\n                    corresponding to that bit."
      },
      "ICH_AP1R<n>": {
        "long_name": "Interrupt Controller Hyp Active Priorities Group 1 Registers",
        "purpose": "Provides information about Group 1 active priorities for EL2.\n\nP<x>, bits [0:31] - Group 1 interrupt active priorities. Possible values of each\n                    bit are:\n                        0b0 There is no Group 1 interrupt active at the priority\n                    corresponding to that bit.\n                        0b1 There is a Group 1 interrupt active at the priority\n                    corresponding to that bit."
      },
      "ICH_EISR": {
        "long_name": "Interrupt Controller End of Interrupt Status Register",
        "purpose": "Indicates which List registers have outstanding EOI maintenance interrupts.\n\nStatus<n>, bits [0:15] - EOI maintenance interrupt status bit for List register\n                         <n>:\n                             0b0 List register <n>, ICH_LR<n>, does not have an\n                         EOI maintenance interrupt.\n                             0b1 List register <n>, ICH_LR<n>, has an EOI\n                         maintenance interrupt that has not been handled.\n                         For any ICH_LR<n>, the corresponding status bit is set\n                         to 1 if all of the following are true:\n                           - ICH_LRC<n>.State is 0b00.\n                           - ICH_LRC<n>.HW is 0.\n                           - ICH_LRC<n>.EOI (bit [9]) is 1, indicating that when\n                         the interrupt corresponding to that List register is\n                         deactivated, a maintenance interrupt is asserted."
      },
      "ICH_ELRSR": {
        "long_name": "Interrupt Controller Empty List Register Status Register",
        "purpose": "Indicates which List registers contain valid interrupts.\n\nStatus<n>, bits [0:15] - Status bit for List register <n>, ICH_LR<n>:\n                             0b0 List register ICH_LR<n>, if implemented,\n                         contains a valid interrupt. Using this List register\n                         can result in overwriting a valid interrupt.\n                             0b1 List register ICH_LR<n> does not contain a\n                         valid interrupt. The List register is empty and can be\n                         used without overwriting a valid interrupt or losing an\n                         EOI maintenance interrupt.\n                         For any List register <n>, the corresponding status bit\n                         is set to 1 if ICH_LRC<n>.State is 0b00 and either\n                         ICH_LRC<n>.HW is 1 or ICH_LRC<n>.EOI (bit [9]) is 0."
      },
      "ICH_HCR": {
        "long_name": "Interrupt Controller Hyp Control Register",
        "purpose": "Controls the environment for VMs.\n\nEOIcount, bits [27:31] - This field is incremented whenever a successful write\n                         to a virtual EOIR or DIR register would have resulted\n                         in a virtual interrupt deactivation.\nTDIR, bit [14]         - Trap Non-secure EL1 writes to ICC_DIR and ICV_DIR.\nTSEI, bit [13]         - Trap all locally generated SEIs.\nTALL1, bit [12]        - Trap all Non-secure EL1 accesses to ICC_* and ICV_*\n                         System registers for Group 1 interrupts to EL2.\nTALL0, bit [11]        - Trap all Non-secure EL1 accesses to ICC_* and ICV_*\n                         System registers for Group 0 interrupts to EL2.\nTC, bit [10]           - Trap all Non-secure EL1 accesses to System registers\n                         that are common to Group 0 and Group 1 to EL2.\nvSGIEOICount, bit [8]  - Controls whether deactivation of virtual SGIs can\n                         increment ICH_HCR_EL2.EOIcount\nVGrp1DIE, bit [7]      - VM Group 1 Disabled Interrupt Enable.\nVGrp1EIE, bit [6]      - VM Group 1 Enabled Interrupt Enable.\nVGrp0DIE, bit [5]      - VM Group 0 Disabled Interrupt Enable.\nVGrp0EIE, bit [4]      - VM Group 0 Enabled Interrupt Enable.\nNPIE, bit [3]          - No Pending Interrupt Enable.\nLRENPIE, bit [2]       - List Register Entry Not Present Interrupt Enable.\nUIE, bit [1]           - Underflow Interrupt Enable.\nEn, bit [0]            - Enable."
      },
      "ICH_LR<n>": {
        "long_name": "Interrupt Controller List Registers",
        "purpose": "Provides interrupt context information for the virtual CPU interface.\n\nvINTID, bits [0:31] - Virtual INTID of the interrupt. If the value of vINTID is\n                      1020-1023 and ICH_LRC<n>.State!=0b00 (Inactive), behavior\n                      is unpredictable. Behavior is unpredictable if two or more\n                      List Registers specify the same vINTID when:\n                        - ICH_LRC<n>.State == 01.\n                        - ICH_LRC<n>.State == 10.\n                        - ICH_LRC<n>.State == 11. It is implementation defined\n                      how many bits are implemented, though at least 16 bits\n                      must be implemented. Unimplemented bits are res0. The\n                      number of implemented bits can be discovered from\n                      ICH_VTR.IDbits. When a VM is using memory-mapped access to\n                      the GIC, software must ensure that the correct source PE\n                      ID is provided in bits[12:10]."
      },
      "ICH_LRC<n>": {
        "long_name": "Interrupt Controller List Registers",
        "purpose": "Provides interrupt context information for the virtual CPU interface.\n\nState, bits [30:31]    - The state of the interrupt:\nHW, bit [29]           - Indicates whether this virtual interrupt maps directly\n                         to a hardware interrupt, meaning that it corresponds to\n                         a physical interrupt.\nGroup, bit [28]        - Indicates the group for this virtual interrupt.\nPriority, bits [16:23] - The priority of this interrupt.\npINTID, bits [0:12]    - Physical INTID, for hardware interrupts."
      },
      "ICH_MISR": {
        "long_name": "Interrupt Controller Maintenance Interrupt State Register",
        "purpose": "Indicates which maintenance interrupts are asserted.\n\nVGrp1D, bit [7] - vPE Group 1 Disabled.\nVGrp1E, bit [6] - vPE Group 1 Enabled.\nVGrp0D, bit [5] - vPE Group 0 Disabled.\nVGrp0E, bit [4] - vPE Group 0 Enabled.\nNP, bit [3]     - No Pending.\nLRENP, bit [2]  - List Register Entry Not Present.\nU, bit [1]      - Underflow.\nEOI, bit [0]    - End Of Interrupt."
      },
      "ICH_VMCR": {
        "long_name": "Interrupt Controller Virtual Machine Control Register",
        "purpose": "Enables the hypervisor to save and restore the virtual machine view of the GIC\nstate.\n\nVPMR, bits [24:31]  - Virtual Priority Mask. The priority mask level for the\n                      virtual CPU interface. If the priority of a pending\n                      virtual interrupt is higher than the value indicated by\n                      this field, the interface signals the virtual interrupt to\n                      the PE. This field is an alias of ICV_PMR.Priority.\nVBPR0, bits [21:23] - Virtual Binary Point Register, Group 0. Defines the point\n                      at which the priority value fields split into two parts,\n                      the group priority field and the subpriority field. The\n                      group priority field determines Group 0 interrupt\n                      preemption, and also determines Group 1 interrupt\n                      preemption if ICH_VMCR.VCBPR == 1. This field is an alias\n                      of ICV_BPR0.BinaryPoint.\nVBPR1, bits [18:20] - Virtual Binary Point Register, Group 1. Defines the point\n                      at which the priority value fields split into two parts,\n                      the group priority field and the subpriority field. The\n                      group priority field determines Group 1 interrupt\n                      preemption if ICH_VMCR.VCBPR == 0. This field is an alias\n                      of ICV_BPR1.BinaryPoint.\nVEOIM, bit [9]      - Virtual EOI mode.\nVCBPR, bit [4]      - Virtual Common Binary Point Register.\nVFIQEn, bit [3]     - Virtual FIQ enable.\nVAckCtl, bit [2]    - Virtual AckCtl.\nVENG1, bit [1]      - Virtual Group 1 interrupt enable.\nVENG0, bit [0]      - Virtual Group 0 interrupt enable."
      },
      "ICH_VTR": {
        "long_name": "Interrupt Controller VGIC Type Register",
        "purpose": "Reports supported GIC virtualization features.\n\nPRIbits, bits [29:31] - Priority bits. The number of virtual priority bits\n                        implemented, minus one. An implementation must implement\n                        at least 32 levels of virtual priority (5 priority\n                        bits). This field is an alias of ICV_CTLR.PRIbits.\nPREbits, bits [26:28] - The number of virtual preemption bits implemented, minus\n                        one. An implementation must implement at least 32 levels\n                        of virtual preemption priority (5 preemption bits). The\n                        value of this field must be less than or equal to the\n                        value of ICH_VTR.PRIbits.\nIDbits, bits [23:25]  - The number of virtual interrupt identifier bits\n                        supported:\nSEIS, bit [22]        - SEI Support.\nA3V, bit [21]         - Affinity 3 Valid.\nnV4, bit [20]         - Direct injection of virtual interrupts not supported.\nTDS, bit [19]         - Separate trapping of Non-secure EL1 writes to ICV_DIR\n                        supported.\nListRegs, bits [0:4]  - The number of implemented List registers, minus one. For\n                        example, a value of 0b01111 indicates that the maximum\n                        of 16 List registers are implemented."
      },
      "ICV_AP0R<n>": {
        "long_name": "Interrupt Controller Virtual Active Priorities Group 0 Registers",
        "purpose": "Provides information about virtual Group 0 active priorities."
      },
      "ICV_AP1R<n>": {
        "long_name": "Interrupt Controller Virtual Active Priorities Group 1 Registers",
        "purpose": "Provides information about virtual Group 1 active priorities."
      },
      "ICV_BPR0": {
        "long_name": "Interrupt Controller Virtual Binary Point Register 0",
        "purpose": "Defines the point at which the priority value fields split into two parts, the\ngroup priority field and the subpriority field. The group priority field\ndetermines virtual Group 0 interrupt preemption.\n\nBinaryPoint, bits [0:2] - The value of this field controls how the 8-bit\n                          interrupt priority field is split into a group\n                          priority field, that determines interrupt preemption,\n                          and a subpriority field. This is done as follows:"
      },
      "ICV_BPR1": {
        "long_name": "Interrupt Controller Virtual Binary Point Register 1",
        "purpose": "Defines the point at which the priority value fields split into two parts, the\ngroup priority field and the subpriority field. The group priority field\ndetermines virtual Group 1 interrupt preemption.\n\nBinaryPoint, bits [0:2] - If the GIC is configured to use separate binary point\n                          fields for virtual Group 0 and virtual Group 1\n                          interrupts, the value of this field controls how the\n                          8-bit interrupt priority field is split into a group\n                          priority field, that determines interrupt preemption,\n                          and a subpriority field. This is done as follows:\n                          Writing 0 to this field will set this field to its\n                          reset value. If ICV_CTLR.CBPR is set to 1, Non-secure\n                          EL1 reads return ICV_BPR0 + 1 saturated to 0b111. Non-\n                          secure EL1 writes are ignored."
      },
      "ICV_CTLR": {
        "long_name": "Interrupt Controller Virtual Control Register",
        "purpose": "Controls aspects of the behavior of the GIC virtual CPU interface and provides\ninformation about the features implemented.\n\nExtRange, bit [19]   - Extended INTID range (read-only).\nRSS, bit [18]        - Range Selector Support.\nA3V, bit [15]        - Affinity 3 Valid. Read-only and writes are ignored.\nSEIS, bit [14]       - SEI Support. Read-only and writes are ignored.\nIDbits, bits [11:13] - Identifier bits. Read-only and writes are ignored.\nPRIbits, bits [8:10] - Priority bits. Read-only and writes are ignored. The\n                       number of priority bits implemented, minus one. An\n                       implementation must implement at least 32 levels of\n                       physical priority (5 priority bits). This field always\n                       returns the number of priority bits implemented. The\n                       division between group priority and subpriority is\n                       defined in the binary point registers ICV_BPR0 and\n                       ICV_BPR1.\nEOImode, bit [1]     - Virtual EOI mode.\nCBPR, bit [0]        - Common Binary Point Register."
      },
      "ICV_DIR": {
        "long_name": "Interrupt Controller Deactivate Virtual Interrupt Register",
        "purpose": "When interrupt priority drop is separated from interrupt deactivation, a write\nto this register deactivates the specified virtual interrupt.\n\nINTID, bits [0:23] - The INTID of the virtual interrupt to be deactivated. This\n                     field has either 16 or 24 bits implemented. The number of\n                     implemented bits can be found in ICV_CTLR.IDbits. If only\n                     16 bits are implemented, bits [23:16] of this register are\n                     res0."
      },
      "ICV_EOIR0": {
        "long_name": "Interrupt Controller Virtual End Of Interrupt Register 0",
        "purpose": "A PE writes to this register to inform the CPU interface that it has completed\nthe processing of the specified virtual Group 0 interrupt.\n\nINTID, bits [0:23] - The INTID from the corresponding ICV_IAR0 access. This\n                     field has either 16 or 24 bits implemented. The number of\n                     implemented bits can be found in ICV_CTLR.IDbits. If only\n                     16 bits are implemented, bits [23:16] of this register are\n                     res0. If the ICV_CTLR.EOImode bit is 0, a write to this\n                     register drops the priority for the virtual interrupt, and\n                     also deactivates the virtual interrupt. If the\n                     ICV_CTLR.EOImode bit is 1, a write to this register only\n                     drops the priority for the virtual interrupt. Software must\n                     write to ICV_DIR to deactivate the virtual interrupt."
      },
      "ICV_EOIR1": {
        "long_name": "Interrupt Controller Virtual End Of Interrupt Register 1",
        "purpose": "A PE writes to this register to inform the CPU interface that it has completed\nthe processing of the specified virtual Group 1 interrupt.\n\nINTID, bits [0:23] - The INTID from the corresponding ICV_IAR1 access. This\n                     field has either 16 or 24 bits implemented. The number of\n                     implemented bits can be found in ICV_CTLR.IDbits. If only\n                     16 bits are implemented, bits [23:16] of this register are\n                     res0. If the ICV_CTLR.EOImode bit is 0, a write to this\n                     register drops the priority for the virtual interrupt, and\n                     also deactivates the virtual interrupt. If the\n                     ICV_CTLR.EOImode bit is 1, a write to this register only\n                     drops the priority for the virtual interrupt. Software must\n                     write to ICV_DIR to deactivate the virtual interrupt."
      },
      "ICV_HPPIR0": {
        "long_name": "Interrupt Controller Virtual Highest Priority Pending Interrupt Register 0",
        "purpose": "Indicates the highest priority pending virtual Group 0 interrupt on the virtual\nCPU interface.\n\nINTID, bits [0:23] - The INTID of the highest priority pending virtual\n                     interrupt. If the highest priority pending interrupt is not\n                     observable, this field contains a special INTID to indicate\n                     the reason. This special INTID can take the value 1023\n                     only. For more information, see 'Special INTIDs' in ARM\u00ae\n                     Generic Interrupt Controller Architecture Specification,\n                     GIC architecture version 3.0 and version 4.0 (ARM IHI\n                     0069). This field has either 16 or 24 bits implemented. The\n                     number of implemented bits can be found in ICV_CTLR.IDbits.\n                     If only 16 bits are implemented, bits [23:16] of this\n                     register are res0."
      },
      "ICV_HPPIR1": {
        "long_name": "Interrupt Controller Virtual Highest Priority Pending Interrupt Register 1",
        "purpose": "Indicates the highest priority pending virtual Group 1 interrupt on the virtual\nCPU interface.\n\nINTID, bits [0:23] - The INTID of the highest priority pending virtual\n                     interrupt. If the highest priority pending interrupt is not\n                     observable, this field contains a special INTID to indicate\n                     the reason. This special INTID can take the value 1023\n                     only. For more information, see 'Special INTIDs' in ARM\u00ae\n                     Generic Interrupt Controller Architecture Specification,\n                     GIC architecture version 3.0 and version 4.0 (ARM IHI\n                     0069). This field has either 16 or 24 bits implemented. The\n                     number of implemented bits can be found in ICV_CTLR.IDbits.\n                     If only 16 bits are implemented, bits [23:16] of this\n                     register are res0."
      },
      "ICV_IAR0": {
        "long_name": "Interrupt Controller Virtual Interrupt Acknowledge Register 0",
        "purpose": "The PE reads this register to obtain the INTID of the signaled virtual Group 0\ninterrupt. This read acts as an acknowledge for the interrupt.\n\nINTID, bits [0:23] - The INTID of the signaled virtual interrupt. This is the\n                     INTID of the highest priority pending virtual interrupt, if\n                     that interrupt is of sufficient priority for it to be\n                     signaled to the PE, and if it can be acknowledged. If the\n                     highest priority pending interrupt is not observable, this\n                     field contains a special INTID to indicate the reason. This\n                     special INTID can take the value 1023 only. For more\n                     information, see 'Special INTIDs' in ARM\u00ae Generic Interrupt\n                     Controller Architecture Specification, GIC architecture\n                     version 3.0 and version 4.0 (ARM IHI 0069). This field has\n                     either 16 or 24 bits implemented. The number of implemented\n                     bits can be found in ICV_CTLR.IDbits. If only 16 bits are\n                     implemented, bits [23:16] of this register are res0."
      },
      "ICV_IAR1": {
        "long_name": "Interrupt Controller Virtual Interrupt Acknowledge Register 1",
        "purpose": "The PE reads this register to obtain the INTID of the signaled virtual Group 1\ninterrupt. This read acts as an acknowledge for the interrupt.\n\nINTID, bits [0:23] - The INTID of the signaled virtual interrupt. This is the\n                     INTID of the highest priority pending virtual interrupt, if\n                     that interrupt is of sufficient priority for it to be\n                     signaled to the PE, and if it can be acknowledged. If the\n                     highest priority pending interrupt is not observable, this\n                     field contains a special INTID to indicate the reason. This\n                     special INTID can take the value 1023 only. For more\n                     information, see 'Special INTIDs' in ARM\u00ae Generic Interrupt\n                     Controller Architecture Specification, GIC architecture\n                     version 3.0 and version 4.0 (ARM IHI 0069). This field has\n                     either 16 or 24 bits implemented. The number of implemented\n                     bits can be found in ICV_CTLR.IDbits. If only 16 bits are\n                     implemented, bits [23:16] of this register are res0."
      },
      "ICV_IGRPEN0": {
        "long_name": "Interrupt Controller Virtual Interrupt Group 0 Enable register",
        "purpose": "Controls whether virtual Group 0 interrupts are enabled or not.\n\nEnable, bit [0] - Enables virtual Group 0 interrupts.\n                      0b0 Virtual Group 0 interrupts are disabled.\n                      0b1 Virtual Group 0 interrupts are enabled."
      },
      "ICV_IGRPEN1": {
        "long_name": "Interrupt Controller Virtual Interrupt Group 1 Enable register",
        "purpose": "Controls whether virtual Group 1 interrupts are enabled for the current Security\nstate.\n\nEnable, bit [0] - Enables virtual Group 1 interrupts.\n                      0b0 Virtual Group 1 interrupts are disabled.\n                      0b1 Virtual Group 1 interrupts are enabled."
      },
      "ICV_PMR": {
        "long_name": "Interrupt Controller Virtual Interrupt Priority Mask Register",
        "purpose": "Provides a virtual interrupt priority filter. Only virtual interrupts with a\nhigher priority than the value in this register are signaled to the PE.\n\nPriority, bits [0:7] - The priority mask level for the virtual CPU interface. If\n                       the priority of a virtual interrupt is higher than the\n                       value indicated by this field, the interface signals the\n                       virtual interrupt to the PE. The possible priority field\n                       values are as follows: Unimplemented priority bits are\n                       RAZ/WI."
      },
      "ICV_RPR": {
        "long_name": "Interrupt Controller Virtual Running Priority Register",
        "purpose": "Indicates the Running priority of the virtual CPU interface.\n\nPriority, bits [0:7] - The current running priority on the virtual CPU\n                       interface. This is the group priority of the current\n                       active virtual interrupt. The priority returned is the\n                       group priority as if the BPR for the current Exception\n                       level and Security state was set to the minimum value of\n                       BPR for the number of implemented priority bits. If 8\n                       bits of priority are implemented the group priority is\n                       bits[7:1] of the priority."
      },
      "ID_AFR0": {
        "long_name": "Auxiliary Feature Register 0",
        "purpose": "Provides information about the implementation defined features of the PE in\nAArch32 state.\n\nMust be interpreted with the Main ID Register, MIDR.\n\nFor general information about the interpretation of the ID registers see\n'Principles of the ID scheme for fields in ID registers'."
      },
      "ID_DFR0": {
        "long_name": "Debug Feature Register 0",
        "purpose": "Provides top level information about the debug system in AArch32 state.\n\nMust be interpreted with the Main ID Register, MIDR.\n\nFor general information about the interpretation of the ID registers see\n'Principles of the ID scheme for fields in ID registers'.\n\nTraceFilt, bits [28:31] - Armv8.4 Self-hosted Trace Extension version.\nPerfMon, bits [24:27]   - Performance Monitors Extension version.\nMProfDbg, bits [20:23]  - M Profile Debug.\nMMapTrc, bits [16:19]   - Memory Mapped Trace.\nCopTrc, bits [12:15]    - Support for System registers-based trace model, using\n                          registers in the coproc == 0b1110 encoding space.\nMMapDbg, bits [8:11]    - Memory Mapped Debug.\nCopSDbg, bits [4:7]     - Support for a System registers-based Secure debug\n                          model, using registers in the coproc = 0b1110 encoding\n                          space, for an A profile processor that includes EL3.\nCopDbg, bits [0:3]      - Support for System registers-based debug model, using\n                          registers in the coproc == 0b1110 encoding space, for\n                          A and R profile processors."
      },
      "ID_DFR1": {
        "long_name": "Debug Feature Register 1",
        "purpose": "Provides top level information about the debug system in AArch32.\n\nFor general information about the interpretation of the ID registers, see\n'Principles of the ID scheme for fields in ID registers'.\n\nMTPMU, bits [0:3] - Multi-threaded PMU extension. Defined values are:\n                        0b0000 FEAT_MTPMU not implemented. If FEAT_PMUv3 is\n                    implemented, it is implementation defined whether\n                    PMEVTYPER<n>.MT are read/write or res0.\n                        0b0001 FEAT_MTPMU and FEAT_PMUv3 implemented.\n                    PMEVTYPER<n>.MT are read/write. When FEAT_MTPMU is disabled,\n                    the Effective values of PMEVTYPER<n>.MT are 0.\n                        0b1111 FEAT_MTPMU not implemented. If FEAT_PMUv3 is\n                    implemented, PMEVTYPER<n>.MT are res0.\n                    All other values are reserved. FEAT_MTPMU implements the\n                    functionality identified by the value 0b0001. From Armv8.6,\n                    in an implementation that includes FEAT_PMUv3, the value\n                    0b0000 is not permitted. In an implementation that does not\n                    include FEAT_PMUv3, the value 0b0001 is not permitted."
      },
      "ID_ISAR0": {
        "long_name": "Instruction Set Attribute Register 0",
        "purpose": "Provides information about the instruction sets implemented by the PE in AArch32\nstate.\n\nMust be interpreted with ID_ISAR1, ID_ISAR2, ID_ISAR3, ID_ISAR4, and ID_ISAR5.\n\nFor general information about the interpretation of the ID registers see\n'Principles of the ID scheme for fields in ID registers'.\n\nDivide, bits [24:27]    - Indicates the implemented Divide instructions.\nDebug, bits [20:23]     - Indicates the implemented Debug instructions.\nCoproc, bits [16:19]    - Indicates the implemented System register access\n                          instructions.\nCmpBranch, bits [12:15] - Indicates the implemented combined Compare and Branch\n                          instructions in the T32 instruction set.\nBitField, bits [8:11]   - Indicates the implemented BitField instructions.\nBitCount, bits [4:7]    - Indicates the implemented Bit Counting instructions.\nSwap, bits [0:3]        - Indicates the implemented Swap instructions in the A32\n                          instruction set."
      },
      "ID_ISAR1": {
        "long_name": "Instruction Set Attribute Register 1",
        "purpose": "Provides information about the instruction sets implemented by the PE in AArch32\nstate.\n\nMust be interpreted with ID_ISAR0, ID_ISAR2, ID_ISAR3, ID_ISAR4, and ID_ISAR5.\n\nFor general information about the interpretation of the ID registers see\n'Principles of the ID scheme for fields in ID registers'.\n\nJazelle, bits [28:31]   - Indicates the implemented Jazelle extension\n                          instructions.\nInterwork, bits [24:27] - Indicates the implemented Interworking instructions.\nImmediate, bits [20:23] - Indicates the implemented data-processing instructions\n                          with long immediates.\nIfThen, bits [16:19]    - Indicates the implemented If-Then instructions in the\n                          T32 instruction set.\nExtend, bits [12:15]    - Indicates the implemented Extend instructions.\nExcept_AR, bits [8:11]  - Indicates the implemented A and R profile exception-\n                          handling instructions.\nExcept, bits [4:7]      - Indicates the implemented exception-handling\n                          instructions in the A32 instruction set.\nEndian, bits [0:3]      - Indicates the implemented Endian instructions."
      },
      "ID_ISAR2": {
        "long_name": "Instruction Set Attribute Register 2",
        "purpose": "Provides information about the instruction sets implemented by the PE in AArch32\nstate.\n\nMust be interpreted with ID_ISAR0, ID_ISAR1, ID_ISAR3, ID_ISAR4, and ID_ISAR5.\n\nFor general information about the interpretation of the ID registers see\n'Principles of the ID scheme for fields in ID registers'.\n\nReversal, bits [28:31]      - Indicates the implemented Reversal instructions.\nPSR_AR, bits [24:27]        - Indicates the implemented A and R profile\n                              instructions to manipulate the PSR.\nMultU, bits [20:23]         - Indicates the implemented advanced unsigned\n                              Multiply instructions.\nMultS, bits [16:19]         - Indicates the implemented advanced signed Multiply\n                              instructions.\nMult, bits [12:15]          - Indicates the implemented additional Multiply\n                              instructions.\nMultiAccessInt, bits [8:11] - Indicates the support for interruptible multi-\n                              access instructions.\nMemHint, bits [4:7]         - Indicates the implemented Memory Hint\n                              instructions.\nLoadStore, bits [0:3]       - Indicates the implemented additional load/store\n                              instructions."
      },
      "ID_ISAR3": {
        "long_name": "Instruction Set Attribute Register 3",
        "purpose": "Provides information about the instruction sets implemented by the PE in AArch32\nstate.\n\nMust be interpreted with ID_ISAR0, ID_ISAR1, ID_ISAR2, ID_ISAR4, and ID_ISAR5. \n\nFor general information about the interpretation of the ID registers see\n'Principles of the ID scheme for fields in ID registers'.\n\nT32EE, bits [28:31]     - Indicates the implemented T32EE instructions.\nTrueNOP, bits [24:27]   - Indicates the implemented true NOP instructions.\nT32Copy, bits [20:23]   - Indicates the support for T32 non flag-setting MOV\n                          instructions.\nTabBranch, bits [16:19] - Indicates the implemented Table Branch instructions in\n                          the T32 instruction set.\nSynchPrim, bits [12:15] - Used in conjunction with ID_ISAR4.SynchPrim_frac to\n                          indicate the implemented Synchronization Primitive\n                          instructions.\nSVC, bits [8:11]        - Indicates the implemented SVC instructions.\nSIMD, bits [4:7]        - Indicates the implemented SIMD instructions.\nSaturate, bits [0:3]    - Indicates the implemented Saturate instructions."
      },
      "ID_ISAR4": {
        "long_name": "Instruction Set Attribute Register 4",
        "purpose": "Provides information about the instruction sets implemented by the PE in AArch32\nstate.\n\nMust be interpreted with ID_ISAR0, ID_ISAR1, ID_ISAR2, ID_ISAR3, and ID_ISAR5.\n\nFor general information about the interpretation of the ID registers see\n'Principles of the ID scheme for fields in ID registers'.\n\nSWP_frac, bits [28:31]       - Indicates support for the memory system locking\n                               the bus for SWP or SWPB instructions.\nPSR_M, bits [24:27]          - Indicates the implemented M profile instructions\n                               to modify the PSRs.\nSynchPrim_frac, bits [20:23] - Used in conjunction with ID_ISAR3.SynchPrim to\n                               indicate the implemented Synchronization\n                               Primitive instructions.\nBarrier, bits [16:19]        - Indicates the implemented Barrier instructions in\n                               the A32 and T32 instruction sets.\nSMC, bits [12:15]            - Indicates the implemented SMC instructions.\nWriteback, bits [8:11]       - Indicates the support for Writeback addressing\n                               modes.\nWithShifts, bits [4:7]       - Indicates the support for instructions with\n                               shifts.\nUnpriv, bits [0:3]           - Indicates the implemented unprivileged\n                               instructions."
      },
      "ID_ISAR5": {
        "long_name": "Instruction Set Attribute Register 5",
        "purpose": "Provides information about the instruction sets implemented by the PE in AArch32\nstate.\n\nMust be interpreted with ID_ISAR0, ID_ISAR1, ID_ISAR2, ID_ISAR3, and ID_ISAR4.\n\nFor general information about the interpretation of the ID registers see\n'Principles of the ID scheme for fields in ID registers'.\n\nVCMA, bits [28:31]  - Indicates AArch32 support for complex number addition and\n                      multiplication where numbers are stored in vectors.\nRDM, bits [24:27]   - Indicates support for the VQRDMLAH and VQRDMLSH\n                      instructions in AArch32 state.\nCRC32, bits [16:19] - Indicates support for the CRC32 instructions in AArch32\n                      state.\nSHA2, bits [12:15]  - Indicates support for the SHA2 instructions in AArch32\n                      state.\nSHA1, bits [8:11]   - Indicates support for the SHA1 instructions are\n                      implemented in AArch32 state.\nAES, bits [4:7]     - Indicates support for the AES instructions in AArch32\n                      state.\nSEVL, bits [0:3]    - Indicates support for the SEVL instruction in AArch32\n                      state."
      },
      "ID_ISAR6": {
        "long_name": "Instruction Set Attribute Register 6",
        "purpose": "Provides information about the instruction sets implemented by the PE in AArch32\nstate.\n\nMust be interpreted with ID_ISAR0, ID_ISAR1, ID_ISAR2, ID_ISAR3, ID_ISAR4, and\nID_ISAR5.\n\nFor general information about the interpretation of the ID registers, see\n'Principles of the ID scheme for fields in ID registers'.\n\nI8MM, bits [24:27]    - Indicates support for Advanced SIMD and floating-point\n                        Int8 matrix multiplication instructions in AArch32\n                        state.\nBF16, bits [20:23]    - Indicates support for Advanced SIMD and floating-point\n                        BFloat16 instructions in AArch32 state.\nSPECRES, bits [16:19] - Indicates support for Speculation invalidation\n                        instructions in AArch32 state.\nSB, bits [12:15]      - Indicates support for SB instruction in AArch32 state.\nFHM, bits [8:11]      - Indicates support for Advanced SIMD and floating-point\n                        VFMAL and VFMSL instructions in AArch32 state.\nDP, bits [4:7]        - Indicates support for dot product instructions in\n                        AArch32 state.\nJSCVT, bits [0:3]     - Indicates support for the Javascript conversion\n                        instruction in AArch32 state."
      },
      "ID_MMFR0": {
        "long_name": "Memory Model Feature Register 0",
        "purpose": "Provides information about the implemented memory model and memory management\nsupport in AArch32 state.\n\nMust be interpreted with ID_MMFR1, ID_MMFR2, ID_MMFR3, and ID_MMFR4.\n\nFor general information about the interpretation of the ID registers see\n'Principles of the ID scheme for fields in ID registers'.\n\nInnerShr, bits [28:31] - Innermost Shareability. Indicates the innermost\n                         shareability domain implemented.\nFCSE, bits [24:27]     - Indicates whether the implementation includes the FCSE.\nAuxReg, bits [20:23]   - Auxiliary Registers. Indicates support for Auxiliary\n                         registers.\nTCM, bits [16:19]      - Indicates support for TCMs and associated DMAs.\nShareLvl, bits [12:15] - Shareability Levels. Indicates the number of\n                         shareability levels implemented.\nOuterShr, bits [8:11]  - Outermost Shareability. Indicates the outermost\n                         shareability domain implemented.\nPMSA, bits [4:7]       - Indicates support for a PMSA.\nVMSA, bits [0:3]       - Indicates support for a VMSA."
      },
      "ID_MMFR1": {
        "long_name": "Memory Model Feature Register 1",
        "purpose": "Provides information about the implemented memory model and memory management\nsupport in AArch32 state.\n\nMust be interpreted with ID_MMFR0, ID_MMFR2, ID_MMFR3, and ID_MMFR4.\n\nFor general information about the interpretation of the ID registers see\n'Principles of the ID scheme for fields in ID registers'.\n\nBPred, bits [28:31]    - Branch Predictor.\nL1TstCln, bits [24:27] - Level 1 cache Test and Clean.\nL1Uni, bits [20:23]    - Level 1 Unified cache.\nL1Hvd, bits [16:19]    - Level 1 Harvard cache.\nL1UniSW, bits [12:15]  - Level 1 Unified cache by Set/Way.\nL1HvdSW, bits [8:11]   - Level 1 Harvard cache by Set/Way.\nL1UniVA, bits [4:7]    - Level 1 Unified cache by Virtual Address.\nL1HvdVA, bits [0:3]    - Level 1 Harvard cache by Virtual Address."
      },
      "ID_MMFR2": {
        "long_name": "Memory Model Feature Register 2",
        "purpose": "Provides information about the implemented memory model and memory management\nsupport in AArch32 state.\n\nMust be interpreted with ID_MMFR0, ID_MMFR1, ID_MMFR3, and ID_MMFR4.\n\nFor general information about the interpretation of the ID registers see\n'Principles of the ID scheme for fields in ID registers'.\n\nHWAccFlg, bits [28:31] - Hardware Access Flag.\nWFIStall, bits [24:27] - Wait For Interrupt Stall.\nMemBarr, bits [20:23]  - Memory Barrier.\nUniTLB, bits [16:19]   - Unified TLB.\nHvdTLB, bits [12:15]   - If the value of ID_MMFR2.UniTLB is not 0b0000, then the\n                         meaning of this field is implementation defined.\nL1HvdRng, bits [8:11]  - Level 1 Harvard cache Range.\nL1HvdBG, bits [4:7]    - Level 1 Harvard cache Background fetch.\nL1HvdFG, bits [0:3]    - Level 1 Harvard cache Foreground fetch."
      },
      "ID_MMFR3": {
        "long_name": "Memory Model Feature Register 3",
        "purpose": "Provides information about the implemented memory model and memory management\nsupport in AArch32 state.\n\nMust be interpreted with ID_MMFR0, ID_MMFR1, ID_MMFR2, and ID_MMFR4.\n\nFor general information about the interpretation of the ID registers see\n'Principles of the ID scheme for fields in ID registers'.\n\nSupersec, bits [28:31]  - Supersections. On a VMSA implementation, indicates\n                          whether Supersections are supported.\nCMemSz, bits [24:27]    - Cached Memory Size. Indicates the physical memory size\n                          supported by the caches.\nCohWalk, bits [20:23]   - Coherent Walk. Indicates whether Translation table\n                          updates require a clean to the Point of Unification.\nPAN, bits [16:19]       - Privileged Access Never. Indicates support for the PAN\n                          bit in CPSR, SPSR, and DSPSR in AArch32 state.\nMaintBcst, bits [12:15] - Maintenance Broadcast. Indicates whether Cache, TLB,\n                          and branch predictor operations are broadcast.\nBPMaint, bits [8:11]    - Branch Predictor Maintenance. Indicates the supported\n                          branch predictor maintenance operations in an\n                          implementation with hierarchical cache maintenance\n                          operations.\nCMaintSW, bits [4:7]    - Cache Maintenance by Set/Way. Indicates the supported\n                          cache maintenance operations by set/way, in an\n                          implementation with hierarchical caches.\nCMaintVA, bits [0:3]    - Cache Maintenance by  Virtual Address. Indicates the\n                          supported cache maintenance operations by VA, in an\n                          implementation with hierarchical caches."
      },
      "ID_MMFR4": {
        "long_name": "Memory Model Feature Register 4",
        "purpose": "Provides information about the implemented memory model and memory management\nsupport in AArch32 state.\n\nMust be interpreted with ID_MMFR0, ID_MMFR1, ID_MMFR2, and ID_MMFR3.\n\nFor general information about the interpretation of the ID registers see\n'Principles of the ID scheme for fields in ID registers'.\n\nEVT, bits [28:31]   - Enhanced Virtualization Traps. If EL2 is implemented,\n                      indicates support for the HCR2.{TTLBIS, TOCU, TICAB, TID4}\n                      traps.\nCCIDX, bits [24:27] - Support for use of the revised CCSIDR format and the\n                      presence of the CCSIDR2 is indicated.\nLSM, bits [20:23]   - Indicates support for LSMAOE and nTLSMD bits in HSCTLR and\n                      SCTLR.\nHPDS, bits [16:19]  - Hierarchical permission disables bits in translation\n                      tables.\nCnP, bits [12:15]   - Common not Private translations.\nXNX, bits [8:11]    - Support for execute-never control distinction by Exception\n                      level at stage 2.\nAC2, bits [4:7]     - Indicates the extension of the ACTLR and HACTLR registers\n                      using ACTLR2 and HACTLR2.\nSpecSEI, bits [0:3] - Describes whether the PE can generate SError interrupt\n                      exceptions from speculative reads of memory, including\n                      speculative instruction fetches."
      },
      "ID_MMFR5": {
        "long_name": "Memory Model Feature Register 5",
        "purpose": "Provides information about the implemented memory model and memory management\nsupport in AArch32 state.\n\nFor general information about the interpretation of the ID registers, see\n'Principles of the ID scheme for fields in ID registers'.\n\nnTLBPA, bits [4:7] - Indicates support for intermediate caching of translation\n                     table walks.\nETS, bits [0:3]    - Indicates support for Enhanced Translation Synchronization."
      },
      "ID_PFR0": {
        "long_name": "Processor Feature Register 0",
        "purpose": "Gives top-level information about the instruction sets and other features\nsupported by the PE in AArch32 state.\n\nMust be interpreted with ID_PFR1.\n\nFor general information about the interpretation of the ID registers, see\n'Principles of the ID scheme for fields in ID registers'.\n\nRAS, bits [28:31]    - RAS Extension version.\nDIT, bits [24:27]    - Data Independent Timing.\nAMU, bits [20:23]    - Indicates support for Activity Monitors Extension.\nCSV2, bits [16:19]   - Speculative use of out of context branch targets.\nState3, bits [12:15] - T32EE instruction set support.\nState2, bits [8:11]  - Jazelle extension support.\nState1, bits [4:7]   - T32 instruction set support.\nState0, bits [0:3]   - A32 instruction set support."
      },
      "ID_PFR1": {
        "long_name": "Processor Feature Register 1",
        "purpose": "Gives information about the AArch32 programmers' model.\n\nMust be interpreted with ID_PFR0.\n\nFor general information about the interpretation of the ID registers see\n'Principles of the ID scheme for fields in ID registers'.\n\nGIC, bits [28:31]            - System register GIC CPU interface.\nVirt_frac, bits [24:27]      - Virtualization fractional field. When the\n                               Virtualization field is 0b0000, determines the\n                               support for features from the ARMv7\n                               Virtualization Extensions.\nSec_frac, bits [20:23]       - Security fractional field. When the Security\n                               field is 0b0000, determines the support for\n                               features from the ARMv7 Security Extensions.\nGenTimer, bits [16:19]       - Generic Timer support.\nVirtualization, bits [12:15] - Virtualization support.\nMProgMod, bits [8:11]        - M profile programmers' model support.\nSecurity, bits [4:7]         - Security support.\nProgMod, bits [0:3]          - Support for the standard programmers' model for\n                               ARMv4 and later. Model must support User, FIQ,\n                               IRQ, Supervisor, Abort, Undefined, and System\n                               modes."
      },
      "ID_PFR2": {
        "long_name": "Processor Feature Register 2",
        "purpose": "Gives information about the AArch32 programmers' model.\n\nMust be interpreted with ID_PFR0 and ID_PFR1.\n\nFor general information about the interpretation of the ID registers see\n'Principles of the ID scheme for fields in ID registers'.\n\nRAS_frac, bits [8:11] - RAS Extension fractional field.\nSSBS, bits [4:7]      - Speculative Store Bypassing controls in AArch64 state.\nCSV3, bits [0:3]      - Speculative use of faulting data."
      },
      "IFAR": {
        "long_name": "Instruction Fault Address Register",
        "purpose": "Holds the virtual address of the faulting address that caused a synchronous\nPrefetch Abort exception.\n\nbits [0:31] - VA of faulting address of synchronous Prefetch Abort exception."
      },
      "IFSR": {
        "long_name": "Instruction Fault Status Register",
        "purpose": "Holds status information about the last instruction fault.\n\nFnV, bit [16]       - FAR not Valid, for a synchronous External abort other than\n                      a synchronous External abort on a translation table walk.\nExT, bit [12]       - External abort type. This bit can be used to provide an\n                      implementation defined classification of External aborts.\n                      In an implementation that does not provide any\n                      classification of External aborts, this bit is res0. For\n                      aborts other than External aborts this bit always returns\n                      0.\nFS, bit [10]        - Fault Status bits. Bits [10] and [3:0] are interpreted\n                      together.\nLPAE, bit [9]       - On taking a Data Abort exception, this bit is set as\n                      follows:\nFS[3:0], bits [0:3] - This field is bits[3:0] of FS[4:0]. See FS[4] for the\n                      field description."
      },
      "ISR": {
        "long_name": "Interrupt Status Register",
        "purpose": "Shows the pending status of the IRQ, FIQ, or SError.\n\nWhen executing at EL2, EL3, or Secure EL1, when SCR_EL3.EEL2 == 0b0, this shows\nthe pending status of the physical interrupts.\n\nWhen executing at Non-secure EL1, or at Secure EL1, when SCR_EL3.EEL2 == 0b01:\n\n  - If the HCR.{IMO,FMO,AMO} bit has a value of 1, the corresponding ISR.{I,F,A}\nbit shows the pending status of the virtual IRQ, FIQ, or SError.\n  - If the HCR.{IMO,FMO,AMO} bit has a value of 0, the corresponding ISR.{I,F,A}\nbit shows the pending status of the physical IRQ, FIQ, or SError.\n\nA, bit [8] - SError interrupt pending bit:\n                 0b0 No pending SError interrupt.\n                 0b1 An SError interrupt is pending.\n             If the SError interrupt is edge-triggered, this field is cleared to\n             zero when the physical SError interrupt is taken.\nI, bit [7] - IRQ pending bit. Indicates whether an IRQ interrupt is pending:\n                 0b0 No pending IRQ.\n                 0b1 An IRQ interrupt is pending.\nF, bit [6] - FIQ pending bit. Indicates whether an FIQ interrupt is pending.\n                 0b0 No pending FIQ.\n                 0b1 An FIQ interrupt is pending."
      },
      "JIDR": {
        "long_name": "Jazelle ID Register",
        "purpose": "A Jazelle register, which identified the Jazelle architecture version."
      },
      "JMCR": {
        "long_name": "Jazelle Main Configuration Register",
        "purpose": "A Jazelle register, which provides control of the Jazelle extension."
      },
      "JOSCR": {
        "long_name": "Jazelle OS Control Register",
        "purpose": "A Jazelle register, which provides operating system control of the Jazelle\nExtension."
      },
      "MAIR0": {
        "long_name": "Memory Attribute Indirection Register 0",
        "purpose": "Along with MAIR1, provides the memory attribute encodings corresponding to the\npossible AttrIndx values in a Long-descriptor format translation table entry for\nstage 1 translations.\n\nAttrIndx[2] indicates the MAIR register to be used:\n\n  - When AttrIndx[2] is 0, MAIR0 is used.\n  - When AttrIndx[2] is 1, MAIR1 is used.\n\nAttr<n>, bits [0:31] - The memory attribute encoding for an AttrIndx[2:0] entry\n                       in a Long descriptor format translation table entry,\n                       where:\n                         - AttrIndx[2:0] gives the value of <n> in Attr<n>.\n                         - AttrIndx[2] defines which MAIR to access. Attr7 to\n                       Attr4 are in MAIR1, and Attr3 to Attr0 are in MAIR0. Bits\n                       [7:4] are encoded as follows: R = Outer Read-Allocate\n                       policy, W = Outer Write-Allocate policy. The meaning of\n                       bits [3:0] depends on the value of bits [7:4]: R = Inner\n                       Read-Allocate policy, W = Inner Write-Allocate policy.\n                       The R and W bits in some Attr<n> fields have the\n                       following meanings: When FEAT_XS is implemented, stage 1\n                       Inner Write-Back Cacheable, Outer Write-Back Cacheable\n                       memory types have the XS attribute set to 0."
      },
      "MAIR1": {
        "long_name": "Memory Attribute Indirection Register 1",
        "purpose": "Along with MAIR0, provides the memory attribute encodings corresponding to the\npossible AttrIndx values in a Long-descriptor format translation table entry for\nstage 1 translations.\n\nAttrIndx[2] indicates the MAIR register to be used:\n\n  - When AttrIndx[2] is 0, MAIR0 is used.\n  - When AttrIndx[2] is 1, MAIR1 is used.\n\nAttr<n>, bits [0:31] - The memory attribute encoding for an AttrIndx[2:0] entry\n                       in a Long descriptor format translation table entry,\n                       where:\n                         - AttrIndx[2:0] gives the value of <n> in Attr<n>.\n                         - AttrIndx[2] defines which MAIR to access. Attr7 to\n                       Attr4 are in MAIR1, and Attr3 to Attr0 are in MAIR0. Bits\n                       [7:4] are encoded as follows: R = Outer Read-Allocate\n                       policy, W = Outer Write-Allocate policy. The meaning of\n                       bits [3:0] depends on the value of bits [7:4]: R = Inner\n                       Read-Allocate policy, W = Inner Write-Allocate policy.\n                       The R and W bits in some Attr<n> fields have the\n                       following meanings: When FEAT_XS is implemented, stage 1\n                       Inner Write-Back Cacheable, Outer Write-Back Cacheable\n                       memory types have the XS attribute set to 0."
      },
      "MIDR": {
        "long_name": "Main ID Register",
        "purpose": "Provides identification information for the PE, including an implementer code\nfor the device and a device ID number.\n\nImplementer, bits [24:31]  - The Implementer code. This field must hold an\n                             implementer code that has been assigned by Arm.\n                             Assigned codes include the following: Arm can\n                             assign codes that are not published in this manual.\n                             All values not assigned by Arm are reserved and\n                             must not be used.\nVariant, bits [20:23]      - An implementation defined variant number.\n                             Typically, this field is used to distinguish\n                             between different product variants, or major\n                             revisions of a product.\nArchitecture, bits [16:19] - Architecture version.\nPartNum, bits [4:15]       - An implementation defined primary part number for\n                             the device. On processors implemented by Arm, if\n                             the top four bits of the primary part number are\n                             0x0 or 0x7, the variant and architecture are\n                             encoded differently.\nRevision, bits [0:3]       - An implementation defined revision number for the\n                             device."
      },
      "MPIDR": {
        "long_name": "Multiprocessor Affinity Register",
        "purpose": "In a multiprocessor system, provides an additional PE identification mechanism\nfor scheduling purposes.\n\nM, bit [31]        - Indicates whether this implementation includes the\n                     functionality introduced by the ARMv7 Multiprocessing\n                     Extensions.\nU, bit [30]        - Indicates a Uniprocessor system, as distinct from PE 0 in a\n                     multiprocessor system.\nMT, bit [24]       - Indicates whether the lowest level of affinity consists of\n                     logical PEs that are implemented using a multithreading\n                     type approach. See the description of Aff0 for more\n                     information about affinity levels.\nAff2, bits [16:23] - Affinity level 2. See the description of Aff0 for more\n                     information.\nAff1, bits [8:15]  - Affinity level 1. See the description of Aff0 for more\n                     information.\nAff0, bits [0:7]   - Affinity level 0. This is the affinity level that is most\n                     significant for determining PE behavior. Higher affinity\n                     levels are increasingly less significant in determining PE\n                     behavior. The assigned value of the MPIDR.{Aff2, Aff1,\n                     Aff0} or MPIDR_EL1.{Aff3, Aff2, Aff1, Aff0} set of fields\n                     of each PE must be unique within the system as a whole."
      },
      "MVBAR": {
        "long_name": "Monitor Vector Base Address Register",
        "purpose": "When EL3 is implemented and can use AArch32, holds the vector base address for\nany exception that is taken to Monitor mode.\n\nSecure software must program the MVBAR with the required initial value as part\nof the PE boot sequence.\n\nbits [5:31] - Vector Base Address. Bits[31:5] of the base address of the\n              exception vectors for exceptions taken to this Exception level.\n              Bits[4:0] of an exception vector are the exception offset."
      },
      "MVFR0": {
        "long_name": "Media and VFP Feature Register 0",
        "purpose": "Describes the features provided by the AArch32 Advanced SIMD and Floating-point\nimplementation.\n\nMust be interpreted with MVFR1 and MVFR2.\n\nFor general information about the interpretation of the ID registers see\n'Principles of the ID scheme for fields in ID registers'.\n\nFPRound, bits [28:31]  - Floating-Point Rounding modes.\nFPShVec, bits [24:27]  - Short Vectors.\nFPSqrt, bits [20:23]   - Square Root.\nFPDivide, bits [16:19] - Indicates whether the floating-point implementation\n                         provides support for VFP divide operations.\nFPTrap, bits [12:15]   - Floating Point Exception Trapping.\nFPDP, bits [8:11]      - Double Precision.\nFPSP, bits [4:7]       - Single Precision.\nSIMDReg, bits [0:3]    - Advanced SIMD registers."
      },
      "MVFR1": {
        "long_name": "Media and VFP Feature Register 1",
        "purpose": "Describes the features provided by the AArch32 Advanced SIMD and Floating-point\nimplementation.\n\nMust be interpreted with MVFR0 and MVFR2.\n\nFor general information about the interpretation of the ID registers see\n'Principles of the ID scheme for fields in ID registers'.\n\nSIMDFMAC, bits [28:31] - Advanced SIMD Fused Multiply-Accumulate. Indicates\n                         whether the Advanced SIMD implementation provides fused\n                         multiply accumulate instructions.\nFPHP, bits [24:27]     - Floating Point Half Precision. Indicates the level of\n                         half-precision floating-point support.\nSIMDHP, bits [20:23]   - Advanced SIMD Half Precision. Indicates the level of\n                         half-precision floating-point support.\nSIMDSP, bits [16:19]   - Advanced SIMD Single Precision. Indicates whether the\n                         Advanced SIMD and floating-point implementation\n                         provides single-precision floating-point instructions.\nSIMDInt, bits [12:15]  - Advanced SIMD Integer. Indicates whether the Advanced\n                         SIMD and floating-point implementation provides integer\n                         instructions.\nSIMDLS, bits [8:11]    - Advanced SIMD Load/Store. Indicates whether the\n                         Advanced SIMD and floating-point implementation\n                         provides load/store instructions.\nFPDNaN, bits [4:7]     - Default NaN mode. Indicates whether the floating-point\n                         implementation provides support only for the Default\n                         NaN mode.\nFPFtZ, bits [0:3]      - Flush to Zero mode. Indicates whether the floating-\n                         point implementation provides support only for the\n                         Flush-to-Zero mode of operation."
      },
      "MVFR2": {
        "long_name": "Media and VFP Feature Register 2",
        "purpose": "Describes the features provided by the AArch32 Advanced SIMD and Floating-point\nimplementation.\n\nMust be interpreted with MVFR0 and MVFR1.\n\nFor general information about the interpretation of the ID registers see\n'Principles of the ID scheme for fields in ID registers'.\n\nFPMisc, bits [4:7]   - Indicates whether the floating-point implementation\n                       provides support for miscellaneous VFP features.\n                           0b0000 Not implemented, or no support for\n                       miscellaneous features.\n                           0b0001 Support for Floating-point selection.\n                           0b0010 As 0b0001, and Floating-point Conversion to\n                       Integer with Directed Rounding modes.\n                           0b0011 As 0b0010, and Floating-point Round to Integer\n                       Floating-point.\n                           0b0100 As 0b0011, and Floating-point MaxNum and\n                       MinNum.\nSIMDMisc, bits [0:3] - Indicates whether the Advanced SIMD implementation\n                       provides support for miscellaneous Advanced SIMD\n                       features.\n                           0b0000 Not implemented, or no support for\n                       miscellaneous features.\n                           0b0001 Floating-point Conversion to Integer with\n                       Directed Rounding modes.\n                           0b0010 As 0b0001, and Floating-point Round to Integer\n                       Floating-point.\n                           0b0011 As 0b0010, and Floating-point MaxNum and\n                       MinNum."
      },
      "NMRR": {
        "long_name": "Normal Memory Remap Register",
        "purpose": "Provides additional mapping controls for memory regions that are mapped as\nNormal memory by their entry in the PRRR.\n\nUsed in conjunction with the PRRR.\n\nOR<n>, bits [16:31] - Outer Cacheable property mapping for memory attributes n,\n                      if the region is mapped as Normal memory by the PRRR.TR<n>\n                      entry. n is the value of the TEX[0], C, and B bits\n                      concatenated. The possible values of this field are:\n                          0b00 Region is Non-cacheable.\n                          0b01 Region is Write-Back, Write-Allocate.\n                          0b10 Region is Write-Through, no Write-Allocate.\n                          0b11 Region is Write-Back, no Write-Allocate.\nIR<n>, bits [0:15]  - Inner Cacheable property mapping for memory attributes n,\n                      if the region is mapped as Normal memory by the PRRR.TR<n>\n                      entry. n is the value of the TEX[0], C, and B bits\n                      concatenated. The possible values of this field are:\n                          0b00 Region is Non-cacheable.\n                          0b01 Region is Write-Back, Write-Allocate.\n                          0b10 Region is Write-Through, no Write-Allocate.\n                          0b11 Region is Write-Back, no Write-Allocate."
      },
      "NSACR": {
        "long_name": "Non-Secure Access Control Register",
        "purpose": "When EL3 is implemented and can use AArch32, defines the Non-secure access\npermissions to Trace, Advanced SIMD and floating-point functionality. Also\nincludes implementation defined bits that can define Non-secure access\npermissions for implementation defined functionality.\n\nNSTRCDIS, bit [20] - Disables Non-secure System register accesses to all\n                     implemented trace registers.\nNSASEDIS, bit [15] - Disables Non-secure access to the Advanced SIMD\n                     functionality.\ncp11, bit [11]     - The value of this field is ignored. If this field is\n                     programmed with a different value to the cp10 field then\n                     this field is unknown on a direct read of the NSACR. If the\n                     implementation does not include Advanced SIMD and floating-\n                     point functionality, this field is res0.\ncp10, bit [10]     - Enable Non-secure access to the Advanced SIMD and floating-\n                     point features."
      },
      "PAR": {
        "long_name": "Physical Address Register",
        "purpose": "Returns the output address (OA) from an Address translation instruction that\nexecuted successfully, or fault information if the instruction did not execute\nsuccessfully.\n\nPA, bits [12:31]       - Output address. The output address (OA) corresponding\n                         to the supplied input address. This field returns\n                         address bits[31:12].\nLPAE, bit [11]         - When updating the PAR with the result of the\n                         translation operation, this bit is set as follows:\nNOS, bit [10]          - Not Outer Shareable.\nNS, bit [9]            - Non-secure. The NS attribute for a translation table\n                         entry from a Secure translation regime. For a result\n                         from a Secure translation regime, this bit reflects the\n                         Security state of the physical address space of the\n                         translation. This means it reflects the effect of the\n                         NSTable bits of earlier levels of the translation table\n                         walk if those NSTable bits have an effect on the\n                         translation. For a result from a Non-secure translation\n                         regime, this bit is unknown.\nSH, bit [7]            - Shareability.\nInner[2:0], bits [4:6] - Inner cacheability attribute for the region.\nOuter[1:0], bits [2:3] - Outer cacheability attribute for the region.\nSS, bit [1]            - Supersection.\nF, bit [0]             - Indicates whether the instruction performed a\n                         successful address translation."
      },
      "PMCCFILTR": {
        "long_name": "Performance Monitors Cycle Count Filter Register",
        "purpose": "Determines the modes in which the Cycle Counter, PMCCNTR, increments.\n\nP, bit [31]   - Privileged filtering bit. Controls counting in EL1. If EL3 is\n                implemented, then counting in Non-secure EL1 is further\n                controlled by the PMCCFILTR.NSK bit.\n                    0b0 Count cycles in EL1.\n                    0b1 Do not count cycles in EL1.\nU, bit [30]   - User filtering bit. Controls counting in EL0. If EL3 is\n                implemented, then counting in Non-secure EL0 is further\n                controlled by the PMCCFILTR.NSU bit.\n                    0b0 Count cycles in EL0.\n                    0b1 Do not count cycles in EL0.\nNSK, bit [29] - Non-secure EL1 (kernel) modes filtering bit. Controls counting\n                in Non-secure EL1. If the value of this bit is equal to the\n                value of PMCCFILTR.P, cycles in Non-secure EL1 are counted.\n                Otherwise, cycles in Non-secure EL1 are not counted.\nNSU, bit [28] - Non-secure EL0 (Unprivileged) filtering. Controls counting in\n                Non-secure EL0. If the value of this bit is equal to the value\n                of PMCCFILTR.U, cycles in Non-secure EL0 are counted. Otherwise,\n                cycles in Non-secure EL0 are not counted.\nNSH, bit [27] - EL2 (Hyp mode) filtering bit. Controls counting in EL2.\n                    0b0 Do not count cycles in EL2.\n                    0b1 Count cycles in EL2."
      },
      "PMCCNTR": {
        "long_name": "Performance Monitors Cycle Count Register",
        "purpose": "Holds the value of the processor Cycle Counter, CCNT, that counts processor\nclock cycles. See 'Time as measured by the Performance Monitors cycle counter'\nfor more information.\n\nPMCCFILTR determines the modes and states in which the PMCCNTR can increment.\n\nCCNT, bits [0:63] - Cycle count. Depending on the values of PMCR.{LC,D}, this\n                    field increments in one of the following ways:\n                      - Every processor clock cycle.\n                      - Every 64th processor clock cycle. Writing 1 to PMCR.C\n                    sets this field to 0."
      },
      "PMCEID0": {
        "long_name": "Performance Monitors Common Event Identification register 0",
        "purpose": "Defines which common architectural events and common microarchitectural  events\nare implemented, or counted, using PMU events in the range 0x0000 to 0x001F\n\nWhen the value of a bit in the register is 1 the corresponding common event is\nimplemented and counted.\n\nArm recommends that, if a common event is never counted, the value of the\ncorresponding register bit is 0.\n\nFor more information about the common events and the use of the PMCEIDn\nregisters see 'The PMU event number space and common events'.\n\nID<n>, bits [0:31] - ID[n] corresponds to common event n. For each bit:\n                         0b0 The common event is not implemented, or not\n                     counted.\n                         0b1 The common event is implemented.\n                     A bit that corresponds to a reserved event number is\n                     reserved. The value might be used in a future revision of\n                     the architecture to identify an additional common event.\n                     Such an event might be added retrospectively to an earlier\n                     version of the PMU architecture, provided the event does\n                     not require any additional PMU features and has an event\n                     number that can be represented in the PMCEID<n> registers\n                     of that earlier version of the PMU architecture."
      },
      "PMCEID1": {
        "long_name": "Performance Monitors Common Event Identification register 1",
        "purpose": "Defines which common architectural events and common microarchitectural  events\nare implemented, or counted, using PMU events in the range 0x0020 to 0x003F.\n\nWhen the value of a bit in the register is 1 the corresponding common event is\nimplemented and counted.\n\nArm recommends that, if a common event is never counted, the value of the\ncorresponding register bit is 0.\n\nFor more information about the common events and the use of the PMCEIDn\nregisters see 'The PMU event number space and common events'.\n\nID<n>, bits [0:31] - ID[n] corresponds to common event (0x0020 + n). For each\n                     bit:\n                         0b0 The common event is not implemented, or not\n                     counted.\n                         0b1 The common event is implemented.\n                     A bit that corresponds to a reserved event number is\n                     reserved. The value might be used in a future revision of\n                     the architecture to identify an additional common event.\n                     Such an event might be added retrospectively to an earlier\n                     version of the PMU architecture, provided the event does\n                     not require any additional PMU features and has an event\n                     number that can be represented in the PMCEID<n> registers\n                     of that earlier version of the PMU architecture."
      },
      "PMCEID2": {
        "long_name": "Performance Monitors Common Event Identification register 2",
        "purpose": "Defines which common architectural events and common microarchitectural  events\nare implemented, or counted, using PMU events in the range 0x4000 to 0x401F.\n\nWhen the value of a bit in the register is 1 the corresponding common event is\nimplemented and counted.\n\nArm recommends that, if a common event is never counted, the value of the\ncorresponding register bit is 0.\n\nFor more information about the common events and the use of the PMCEIDn\nregisters see 'The PMU event number space and common events'.\n\nIDhi<n>, bits [0:31] - IDhi[n] corresponds to common event (0x4000 + n). For\n                       each bit:\n                           0b0 The common event is not implemented, or not\n                       counted.\n                           0b1 The common event is implemented.\n                       A bit that corresponds to a reserved event number is\n                       reserved. The value might be used in a future revision of\n                       the architecture to identify an additional common event.\n                       Such an event might be added retrospectively to an\n                       earlier version of the PMU architecture, provided the\n                       event does not require any additional PMU features and\n                       has an event number that can be represented in the\n                       PMCEID<n> registers of that earlier version of the PMU\n                       architecture."
      },
      "PMCEID3": {
        "long_name": "Performance Monitors Common Event Identification register 3",
        "purpose": "Defines which common architectural events and common microarchitectural  events\nare implemented, or counted, using PMU events in the range 0x4020 to 0x403F.\n\nWhen the value of a bit in the register is 1 the corresponding common event is\nimplemented and counted.\n\nArm recommends that, if a common event is never counted, the value of the\ncorresponding register bit is 0.\n\nFor more information about the common events and the use of the PMCEIDn\nregisters see 'The PMU event number space and common events'.\n\nIDhi<n>, bits [0:31] - IDhi[n] corresponds to common event (0x4020 + n). For\n                       each bit:\n                           0b0 The common event is not implemented, or not\n                       counted.\n                           0b1 The common event is implemented.\n                       A bit that corresponds to a reserved event number is\n                       reserved. The value might be used in a future revision of\n                       the architecture to identify an additional common event.\n                       Such an event might be added retrospectively to an\n                       earlier version of the PMU architecture, provided the\n                       event does not require any additional PMU features and\n                       has an event number that can be represented in the\n                       PMCEID<n> registers of that earlier version of the PMU\n                       architecture."
      },
      "PMCNTENCLR": {
        "long_name": "Performance Monitors Count Enable Clear register",
        "purpose": "Disables the Cycle Count Register, PMCCNTR, and any implemented event counters\nPMEVCNTR<n>. Reading this register shows which counters are enabled.\n\nPMCNTENCLR is used in conjunction with the PMCNTENSET register.\n\nC, bit [31]       - PMCCNTR disable bit. Disables the cycle counter register.\n                        0b0 When read, means the cycle counter is disabled. When\n                    written, has no effect.\n                        0b1 When read, means the cycle counter is enabled. When\n                    written, disables the cycle counter.\nP<n>, bits [0:30] - Event counter disable bit for PMEVCNTR<n>. If N is less than\n                    31, then bits [30:N] are RAZ/WI. When EL2 is implemented and\n                    enabled in the current Security state, in EL1 and EL0, N is\n                    the value in MDCR_EL2.HPMN if EL2 is using AArch64, or in\n                    HDCR.HPMN if EL2 is using AArch32. Otherwise, N is the value\n                    in PMCR.N.\n                        0b0 When read, means that PMEVCNTR<n> is disabled. When\n                    written, has no effect.\n                        0b1 When read, means that PMEVCNTR<n> is enabled. When\n                    written, disables PMEVCNTR<n>."
      },
      "PMCNTENSET": {
        "long_name": "Performance Monitors Count Enable Set register",
        "purpose": "Enables the Cycle Count Register, PMCCNTR, and any implemented event counters\nPMEVCNTR<n>. Reading this register shows which counters are enabled.\n\nPMCNTENSET is used in conjunction with the PMCNTENCLR register.\n\nC, bit [31]       - PMCCNTR enable bit. Enables the cycle counter register.\n                        0b0 When read, means the cycle counter is disabled. When\n                    written, has no effect.\n                        0b1 When read, means the cycle counter is enabled. When\n                    written, enables the cycle counter.\nP<n>, bits [0:30] - Event counter enable bit for PMEVCNTR<n>. If N is less than\n                    31, then bits [30:N] are RAZ/WI. When EL2 is implemented and\n                    enabled in the current Security state, in EL1 and EL0, N is\n                    the value in MDCR_EL2.HPMN if EL2 is using AArch64, or in\n                    HDCR.HPMN if EL2 is using AArch32. Otherwise, N is the value\n                    in PMCR.N.\n                        0b0 When read, means that PMEVCNTR<n> is disabled. When\n                    written, has no effect.\n                        0b1 When read, means that PMEVCNTR<n> event counter is\n                    enabled. When written, enables PMEVCNTR<n>."
      },
      "PMCR": {
        "long_name": "Performance Monitors Control Register",
        "purpose": "Provides details of the Performance Monitors implementation, including the\nnumber of counters implemented, and configures and controls the counters.\n\nIMP, bits [24:31]    - Implementer code.\nIDCODE, bits [16:23] - Identification code.\nN, bits [11:15]      - Indicates the number of event counters implemented.\nFZO, bit [9]         - Freeze-on-overflow.\nLP, bit [7]          - Long event counter enable.\nLC, bit [6]          - Long cycle counter enable.\nDP, bit [5]          - Disable cycle counter when event counting is prohibited.\nX, bit [4]           - Enable export of events in an implementation defined PMU\n                       event export bus.\nD, bit [3]           - Clock divider.\nC, bit [2]           - Cycle counter reset.\nP, bit [1]           - Event counter reset.\nE, bit [0]           - Enable."
      },
      "PMEVCNTR<n>": {
        "long_name": "Performance Monitors Event Count Registers",
        "purpose": "Holds event counter n, which counts events, where n is 0 to 30.\n\nbits [0:31] - Event counter n. Value of event counter n, where n is the number\n              of this register and is a number from 0 to 30. If FEAT_PMUv3p5 is\n              implemented, the event counter is 64 bits and only the least-\n              significant part of the event counter is accessible in AArch32\n              state:\n                -  Reads from PMEVCNTR<n> return bits [31:0] of the counter.\n                -  Writes to PMEVCNTR<n> update bits [31:0] and leave bits\n              [63:32] unchanged.\n                -  There is no means to access bits [63:32] directly from\n              AArch32 state.\n                -  If the implementation does not support AArch64 at any\n              Exception level, bits [63:32] are not required to be implemented.\n              If FEAT_PMUv3p5 is not implemented, the event counter is 32 bits."
      },
      "PMEVTYPER<n>": {
        "long_name": "Performance Monitors Event Type Registers",
        "purpose": "Configures event counter n, where n is 0 to 30.\n\nP, bit [31]                   - Privileged filtering bit.\nU, bit [30]                   - User filtering bit.\nNSK, bit [29]                 - Non-secure EL1 (kernel) modes filtering bit.\nNSU, bit [28]                 - Non-secure EL0 (Unprivileged) filtering.\nNSH, bit [27]                 - EL2 (Hyp mode) filtering bit.\nMT, bit [25]                  - Multithreading.\nevtCount[15:10], bits [10:15] - Extension to evtCount[9:0].\nevtCount[9:0], bits [0:9]     - Event to count."
      },
      "PMINTENCLR": {
        "long_name": "Performance Monitors Interrupt Enable Clear register",
        "purpose": "Disables the generation of interrupt requests on overflows from the Cycle Count\nRegister, PMCCNTR, and the event counters PMEVCNTR<n>. Reading the register\nshows which overflow interrupt requests are enabled.\n\nPMINTENCLR is used in conjunction with the PMINTENSET register.\n\nC, bit [31]       - PMCCNTR overflow interrupt request disable bit.\n                        0b0 When read, means the cycle counter overflow\n                    interrupt request is disabled. When written, has no effect.\n                        0b1 When read, means the cycle counter overflow\n                    interrupt request is enabled. When written, disables the\n                    cycle count overflow interrupt request.\nP<n>, bits [0:30] - Event counter overflow interrupt request disable bit for\n                    PMEVCNTR<n>. If N is less than 31, then bits [30:N] are\n                    RAZ/WI. When EL2 is implemented and enabled in the current\n                    Security state, in EL1, N is the value in MDCR_EL2.HPMN if\n                    EL2 is using AArch64, or in HDCR.HPMN if EL2 is using\n                    AArch32. Otherwise, N is the value in PMCR.N.\n                        0b0 When read, means that the PMEVCNTR<n> event counter\n                    interrupt request is disabled. When written, has no effect.\n                        0b1 When read, means that the PMEVCNTR<n> event counter\n                    interrupt request is enabled. When written, disables the\n                    PMEVCNTR<n> interrupt request."
      },
      "PMINTENSET": {
        "long_name": "Performance Monitors Interrupt Enable Set register",
        "purpose": "Enables the generation of interrupt requests on overflows from the Cycle Count\nRegister, PMCCNTR, and the event counters PMEVCNTR<n>. Reading the register\nshows which overflow interrupt requests are enabled.\n\nPMINTENSET is used in conjunction with the PMINTENCLR register.\n\nC, bit [31]       - PMCCNTR overflow interrupt request enable bit.\n                        0b0 When read, means the cycle counter overflow\n                    interrupt request is disabled. When written, has no effect.\n                        0b1 When read, means the cycle counter overflow\n                    interrupt request is enabled. When written, enables the\n                    cycle count overflow interrupt request.\nP<n>, bits [0:30] - Event counter overflow interrupt request enable bit for\n                    PMEVCNTR<n>. If N is less than 31, then bits [30:N] are\n                    RAZ/WI. When EL2 is implemented and enabled in the current\n                    Security state, in EL1, N is the value in MDCR_EL2.HPMN if\n                    EL2 is using AArch64, or in HDCR.HPMN if EL2 is using\n                    AArch32. Otherwise, N is the value in PMCR.N.\n                        0b0 When read, means that the PMEVCNTR<n> event counter\n                    interrupt request is disabled. When written, has no effect.\n                        0b1 When read, means that the PMEVCNTR<n> event counter\n                    interrupt request is enabled. When written, enables the\n                    PMEVCNTR<n> interrupt request."
      },
      "PMMIR": {
        "long_name": "Performance Monitors Machine Identification Register",
        "purpose": "Describes Performance Monitors parameters specific to the implementation to\nsoftware.\n\nBUS_WIDTH, bits [16:19] - Bus width. Indicates the number of bytes each\n                          BUS_ACCESS event relates to. Encoded as Log_2(number\n                          of bytes), plus one. Defined values are:\n                              0b0000 The information is not available.\n                              0b0011 Four bytes.\n                              0b0100 8 bytes.\n                              0b0101 16 bytes.\n                              0b0110 32 bytes.\n                              0b0111 64 bytes.\n                              0b1000 128 bytes.\n                              0b1001 256 bytes.\n                              0b1010 512 bytes.\n                              0b1011 1024 bytes.\n                              0b1100 2048 bytes.\nBUS_SLOTS, bits [8:15]  - Bus count. The largest value by which the BUS_ACCESS\n                          event might increment by in a single BUS_CYCLES cycle.\nSLOTS, bits [0:7]       - Operation width. The largest value by which the\n                          STALL_SLOT event might increment by in a single cycle.\n                          If the STALL_SLOT event is not implemented, this field\n                          might read as zero."
      },
      "PMOVSR": {
        "long_name": "Performance Monitors Overflow Flag Status Register",
        "purpose": "Contains the state of the overflow bit for the Cycle Count Register, PMCCNTR,\nand each of the implemented event counters PMEVCNTR<n>. Writing to this register\nclears these bits.\n\nC, bit [31]       - Cycle counter overflow clear bit. Possible values are:\n                        0b0 When read, means the cycle counter has not\n                    overflowed since this bit was last cleared. When written,\n                    has no effect.\n                        0b1 When read, means the cycle counter has overflowed\n                    since this bit was last cleared. When written, clears the\n                    cycle counter overflow bit to 0.\nP<n>, bits [0:30] - Event counter overflow clear bit for PMEVCNTR<n>. If N is\n                    less than 31, then bits [30:N] are RAZ/WI. When EL2 is\n                    implemented and enabled in the current Security state, in\n                    EL1 and EL0, N is the value in MDCR_EL2.HPMN if EL2 is using\n                    AArch64, or in HDCR.HPMN if EL2 is using AArch32. Otherwise,\n                    N is the value in PMCR.N.\n                        0b0 When read, means that PMEVCNTR<n> has not overflowed\n                    since this bit was last cleared. When written, has no\n                    effect.\n                        0b1 When read, means that PMEVCNTR<n> has overflowed\n                    since this bit was last cleared. When written, clears the\n                    PMEVCNTR<n> overflow bit to 0."
      },
      "PMOVSSET": {
        "long_name": "Performance Monitors Overflow Flag Status Set register",
        "purpose": "Sets the state of the overflow bit for the Cycle Count Register, PMCCNTR, and\neach of the implemented event counters PMEVCNTR<n>.\n\nC, bit [31]       - Cycle counter overflow set bit.\n                        0b0 When read, means the cycle counter has not\n                    overflowed since this bit was last cleared. When written,\n                    has no effect.\n                        0b1 When read, means the cycle counter has overflowed\n                    since this bit was last cleared. When written, sets the\n                    cycle counter overflow bit to 1.\n                    PMCR.LC controls whether an overflow is detected from\n                    unsigned overflow of PMCCNTR[31:0] or unsigned overflow of\n                    PMCCNTR[63:0].\nP<n>, bits [0:30] - Event counter overflow set bit for PMEVCNTR<n>. If N is less\n                    than 31, then bits [30:N] are RAZ/WI. When EL2 is\n                    implemented and enabled in the current Security state, in\n                    EL1 and EL0, N is the value in MDCR_EL2.HPMN if EL2 is using\n                    AArch64, or in HDCR.HPMN if EL2 is using AArch32. Otherwise,\n                    N is the value in PMCR.N.\n                        0b0 When read, means that PMEVCNTR<n> has not overflowed\n                    since this bit was last cleared. When written, has no\n                    effect.\n                        0b1 When read, means that PMEVCNTR<n> has overflowed\n                    since this bit was last . When written, sets the PMEVCNTR<n>\n                    overflow bit to 1.\n                    If FEAT_PMUv3p5 is implemented, MDCR_EL2.HLP, HDCR.HLP, and\n                    PMCR.LP control whether an overflow is detected from\n                    unsigned overflow of PMEVCNTR<n>[31:0] or unsigned overflow\n                    of PMEVCNTR<n>[63:0]. PMEVCNTR<n>[63:32] cannot be accessed\n                    directly in AArch32 state."
      },
      "PMSELR": {
        "long_name": "Performance Monitors Event Counter Selection Register",
        "purpose": "Selects the current event counter PMEVCNTR<n> or the cycle counter, CCNT.\n\nPMSELR is used in conjunction with PMXEVTYPER to determine the event that\nincrements a selected event counter, and the modes and states in which the\nselected counter increments.\n\nIt is also used in conjunction with PMXEVCNTR, to determine the value of a\nselected event counter.\n\nSEL, bits [0:4] - Selects event counter, PMEVCNTR<n>, where n is the value held\n                  in this field. This value identifies which event counter is\n                  accessed when a subsequent access to PMXEVTYPER or PMXEVCNTR\n                  occurs. This field can take any value from 0 (0b00000) to\n                  (PMCR.N)-1, or 31 (0b11111). When PMSELR.SEL is 0b11111, it\n                  selects the cycle counter and:\n                    - A read of the PMXEVTYPER returns the value of PMCCFILTR.\n                    - A write of the PMXEVTYPER writes to PMCCFILTR.\n                    - A read or write of PMXEVCNTR has constrained unpredictable\n                  effects. For more information, see PMXEVCNTR. For more\n                  information about the results of accesses to event counters,\n                  see PMXEVTYPER and PMXEVCNTR. For more information about the\n                  number of counters accessible at each Exception level, see\n                  HDCR.HPMN and MDCR_EL2.HPMN."
      },
      "PMSWINC": {
        "long_name": "Performance Monitors Software Increment register",
        "purpose": "Increments a counter that is configured to count the Software increment event,\nevent 0x00. For more information, see SW_INCR.\n\nP<n>, bits [0:30] - Event counter software increment bit for PMEVCNTR<n>. If N\n                    is less than 31, then bits [30:N] are WI. When EL2 is\n                    implemented and enabled in the current Security state, in\n                    EL1 and EL0, N is the value in MDCR_EL2.HPMN if EL2 is using\n                    AArch64, or in HDCR.HPMN if EL2 is using AArch32. Otherwise,\n                    N is the value in PMCR.N.\n                        0b0 No action. The write to this bit is ignored.\n                        0b1 If PMEVCNTR<n> is enabled and configured to count\n                    the software increment event, increments PMEVCNTR<n> by 1.\n                    If PMEVCNTR<n> is disabled, or not configured to count the\n                    software increment event, the write to this bit is ignored."
      },
      "PMUSERENR": {
        "long_name": "Performance Monitors User Enable Register",
        "purpose": "Enables or disables User mode access to the Performance Monitors.\n\nER, bit [3] - Event counter read trap control:\n                  0b0 EL0 reads of the PMXEVCNTR and PMEVCNTR<n>, and EL0 RW\n              access to the PMSELR, are trapped to Undefined mode if\n              PMUSERENR.EN is also 0.\n                  0b1 Overrides PMUSERENR.EN and enables RO access to PMXEVCNTR\n              and PMEVCNTR<n>, and RW access to PMSELR.\nCR, bit [2] - Cycle counter read trap control:\n                  0b0 EL0 reads of the PMCCNTR are trapped to Undefined mode if\n              PMUSERENR.EN is also 0.\n                  0b1 Overrides PMUSERENR.EN and enables access to PMCCNTR.\nSW, bit [1] - Software increment write trap control:\n                  0b0 EL0 writes to the PMSWINC are trapped to Undefined mode if\n              PMUSERENR.EN is also 0.\n                  0b1 Overrides PMUSERENR.EN and enables access to PMSWINC.\nEN, bit [0] - Traps EL0 accesses to the Performance Monitors registers to\n              Undefined mode, as follows:\n                -  PMCR, PMOVSR, PMSELR, PMCEID0, PMCEID1, PMCCNTR, PMXEVTYPER,\n              PMXEVCNTR, PMCNTENSET, PMCNTENCLR, PMOVSSET, PMEVCNTR<n>,\n              PMEVTYPER<n>, PMCCFILTR, PMSWINC.\n                -  If FEAT_PMUv3p1 is implemented, PMCEID2, and PMCEID3.\n                -  If FEAT_PMUv3p4 is implemented, PMMIR.\n                  0b0 While at EL0, accesses to the specified registers at EL0\n              are trapped to Undefined mode, unless overridden by one of\n              PMUSERENR.{ER, CR, SW}.\n                  0b1 While at EL0, software can access all of the specified\n              registers."
      },
      "PMXEVCNTR": {
        "long_name": "Performance Monitors Selected Event Count Register",
        "purpose": "Reads or writes the value of the selected event counter, PMEVCNTR<n>. PMSELR.SEL\ndetermines which event counter is selected.\n\nPMEVCNTR<n>, bits [0:31] - Value of the selected event counter, PMEVCNTR<n>,\n                           where n is the value stored in PMSELR.SEL. If\n                           FEAT_PMUv3p5 is implemented, the event counter is 64\n                           bits and only the least-significant part of the event\n                           counter is accessible in AArch32 state:\n                             -  Reads from PMXEVCNTR return bits [31:0] of the\n                           counter.\n                             -  Writes to PMXEVCNTR update bits [31:0] and leave\n                           bits [63:32] unchanged.\n                             -  There is no means to access bits [63:32]\n                           directly from AArch32 state.\n                             -  If the implementation does not support AArch64\n                           at any Exception level, bits [63:32] are not required\n                           to be implemented. If FEAT_PMUv3p5 is not\n                           implemented, the event counter is 32 bits."
      },
      "PMXEVTYPER": {
        "long_name": "Performance Monitors Selected Event Type Register",
        "purpose": "When PMSELR.SEL selects an event counter, this accesses a PMEVTYPER<n> register.\nWhen PMSELR.SEL selects the cycle counter, this accesses PMCCFILTR.\n\nbits [0:31] - Event type register or PMCCFILTR. When PMSELR.SEL == 31, this\n              register accesses PMCCFILTR. Otherwise, this register accesses\n              PMEVTYPER<n> where n is the value in PMSELR.SEL."
      },
      "PRRR": {
        "long_name": "Primary Region Remap Register",
        "purpose": "Controls the top level mapping of the TEX[0], C, and B memory region attributes.\n\nNOS<n>, bits [24:31] - Not Outer Shareable.\nNS1, bit [19]        - Mapping of S = 1 attribute for Normal memory regions.\nNS0, bit [18]        - Mapping of S = 0 attribute for Normal memory regions.\nDS1, bit [17]        - Mapping of S = 1 attribute for Device memory.\nDS0, bit [16]        - Mapping of S = 0 attribute for Device memory.\nTR<n>, bits [0:15]   - TR<n> is the primary TEX mapping for memory attributes n,\n                       and defines the mapped memory type for a region with\n                       attributes n."
      },
      "REVIDR": {
        "long_name": "Revision ID Register",
        "purpose": "Provides implementation-specific minor revision information."
      },
      "RMR": {
        "long_name": "Reset Management Register",
        "purpose": "If EL1 or EL3 is the highest implemented Exception level and this register is\nimplemented:\n\n  - A write to the register at the highest implemented Exception level can\nrequest a Warm reset.\n  - If the highest implemented Exception level can use AArch32 and AArch64, this\nregister specifies the Execution state that the PE boots into on a Warm reset.\n\nRR, bit [1]   - Reset Request. Setting this bit to 1 requests a Warm reset.\nAA64, bit [0] - When the highest implemented Exception level can use AArch64,\n                determines which Execution state the PE boots into after a Warm\n                reset:\n                    0b0 AArch32.\n                    0b1 AArch64.\n                On coming out of the Warm reset, execution starts at the\n                implementation defined reset vector address of the specified\n                Execution state. If the highest implemented Exception level\n                cannot use AArch64 this bit is RAZ/WI."
      },
      "RVBAR": {
        "long_name": "Reset Vector Base Address Register",
        "purpose": "If EL3 is not implemented, contains the implementation defined address that\nexecution starts from after reset when executing in AArch32 state.\n\nbits [1:31] - Reset Address[31:1]. Bits [31:1] of the implementation defined\n              address that execution starts from after reset when executing in\n              32-bit state."
      },
      "SCR": {
        "long_name": "Secure Configuration Register",
        "purpose": "When EL3 is implemented and can use AArch32, defines the configuration of the\ncurrent Security state. It specifies:\n\n  - The Security state, either Secure or Non-secure.\n  - What mode the PE branches to if an IRQ, FIQ, or External abort occurs.\n  - Whether the PSTATE.F or PSTATE.A bits can be modified when SCR.NS==1.\n\nTERR, bit [15] - Trap Error record accesses.\nTWE, bit [13]  - Traps WFE instructions to Monitor mode.\nTWI, bit [12]  - Traps WFI instructions to Monitor mode.\nSIF, bit [9]   - Secure instruction fetch.\nHCE, bit [8]   - Hypervisor Call instruction enable.\nSCD, bit [7]   - Secure Monitor Call disable.\nnET, bit [6]   - Not Early Termination.\nAW, bit [5]    - When the value of SCR.EA is 1 and the value of HCR.AMO is 0,\n                 this bit controls whether PSTATE.A masks an External abort\n                 taken from Non-secure state.\nFW, bit [4]    - When the value of SCR.FIQ is 1 and the value of HCR.FMO is 0,\n                 this bit controls whether PSTATE.F masks an FIQ interrupt taken\n                 from Non-secure state.\nEA, bit [3]    - External Abort handler.\nFIQ, bit [2]   - FIQ handler.\nIRQ, bit [1]   - IRQ handler.\nNS, bit [0]    - Non-secure bit."
      },
      "SCTLR": {
        "long_name": "System Control Register",
        "purpose": "Provides the top level control of the system, including its memory system.\n\nDSSBS, bit [31]  - Default PSTATE.SSBS value on Exception Entry.\nTE, bit [30]     - T32 Exception Enable.\nAFE, bit [29]    - Access Flag Enable.\nTRE, bit [28]    - TEX remap enable.\nEE, bit [25]     - The value of the PSTATE.E bit on branch to an exception\n                   vector or coming out of reset, and the endianness of stage 1\n                   translation table walks in the PL1&0 translation regime.\nSPAN, bit [23]   - Set Privileged Access Never, on taking an exception to EL1\n                   from either Secure or Non-secure state, or to EL3 from Secure\n                   state when EL3 is using AArch32.\nUWXN, bit [20]   - Unprivileged write permission implies PL1 XN (Execute-never).\nWXN, bit [19]    - Write permission implies XN (Execute-never).\nnTWE, bit [18]   - Traps EL0 execution of WFE instructions to Undefined mode.\nnTWI, bit [16]   - Traps EL0 execution of WFI instructions to Undefined mode.\nV, bit [13]      - Vectors bit.\nI, bit [12]      - Instruction access Cacheability control, for accesses at EL1\n                   and EL0:\nEnRCTX, bit [10] - Enable EL0 Access to the AArch32 CFPRCTX, DVPRCTX and CPPRCTX\n                   instructions.\nSED, bit [8]     - SETEND instruction disable.\nITD, bit [7]     - IT Disable.\nUNK, bit [6]     - Writes to this bit are IGNORED.\nCP15BEN, bit [5] - System instruction memory barrier enable.\nLSMAOE, bit [4]  - Load Multiple and Store Multiple Atomicity and Ordering\n                   Enable.\nnTLSMD, bit [3]  - No Trap Load Multiple and Store Multiple to Device-\n                   nGRE/Device-nGnRE/Device-nGnRnE memory.\nC, bit [2]       - Cacheability control, for data accesses at EL1 and EL0:\nA, bit [1]       - Alignment check enable.\nM, bit [0]       - MMU enable for EL1 and EL0 stage 1 address translation."
      },
      "SDCR": {
        "long_name": "Secure Debug Control Register",
        "purpose": "Provides EL3 configuration options for self-hosted debug, trace, and the\nPerformance Monitors Extension.\n\nMTPME, bit [28]   - Multi-threaded PMU Enable.\nTDCC, bit [27]    - Trap DCC.\nSCCD, bit [23]    - Secure Cycle Counter Disable.\nEPMAD, bit [21]   - External Performance Monitors Non-secure access disable.\nEPMAD, bit [21]   - External Performance Monitors access disable.\nEDAD, bit [20]    - External debug Non-secure access disable.\nEDAD, bit [20]    - External debug access disable.\nEDAD, bit [20]    - External debug access disable.\nTTRF, bit [19]    - Trap Trace Filter controls.\nSTE, bit [18]     - Secure Trace Enable.\nSPME, bit [17]    - Secure Performance Monitors Enable.\nSPME, bit [17]    - Secure Performance Monitors Enable.\nSPD, bits [14:15] - AArch32 Secure self-hosted Privileged Debug."
      },
      "SDER": {
        "long_name": "Secure Debug Enable Register",
        "purpose": "Controls invasive and non-invasive debug in the Secure EL0 mode.\n\nSUNIDEN, bit [1] - Secure User Non-Invasive Debug Enable.\n                       0b0 This bit does not affect Performance Monitors event\n                   counting at Secure EL0\n                       0b1 If EL3 or EL1 is using AArch32, Performance Monitors\n                   event counting is allowed in Secure EL0.\nSUIDEN, bit [0]  - Secure User Invasive Debug Enable.\n                       0b0 This bit does not affect the generation of debug\n                   exceptions at Secure EL0.\n                       0b1 If EL3 or EL1 is using AArch32, debug exceptions from\n                   Secure EL0 are enabled."
      },
      "SPSR": {
        "long_name": "Saved Program Status Register",
        "purpose": "Holds the saved process state for the current mode.\n\nN, bit [31]           - Negative Condition flag.\nZ, bit [30]           - Zero Condition flag.\nC, bit [29]           - Carry Condition flag.\nV, bit [28]           - Overflow Condition flag.\nQ, bit [27]           - Overflow or saturation flag.\nIT, bits [25:26]      - If-Then.\nJ, bit [24]           - res0.\nSSBS, bit [23]        - Speculative Store Bypass.\nPAN, bit [22]         - Privileged Access Never.\nDIT, bit [21]         - Data Independent Timing.\nIL, bit [20]          - Illegal Execution state.\nGE, bits [16:19]      - Greater than or Equal flags.\nIT[7:2], bits [10:15] - This field is bits[7:2] of IT[7:0].\nE, bit [9]            - Endianness.\nA, bit [8]            - SError interrupt mask.\nI, bit [7]            - IRQ interrupt mask.\nF, bit [6]            - FIQ interrupt mask.\nT, bit [5]            - T32 Instruction set state.\nM[4:0], bits [0:4]    - Mode."
      },
      "SPSR_abt": {
        "long_name": "Saved Program Status Register (Abort mode)",
        "purpose": "Holds the saved process state when an exception is taken to Abort mode.\n\nN, bit [31]           - Negative Condition flag.\nZ, bit [30]           - Zero Condition flag.\nC, bit [29]           - Carry Condition flag.\nV, bit [28]           - Overflow Condition flag.\nQ, bit [27]           - Overflow or saturation flag.\nIT, bits [25:26]      - If-Then.\nJ, bit [24]           - res0.\nSSBS, bit [23]        - Speculative Store Bypass.\nPAN, bit [22]         - Privileged Access Never.\nDIT, bit [21]         - Data Independent Timing.\nIL, bit [20]          - Illegal Execution state.\nGE, bits [16:19]      - Greater than or Equal flags.\nIT[7:2], bits [10:15] - This field is bits[7:2] of IT[7:0].\nE, bit [9]            - Endianness.\nA, bit [8]            - SError interrupt mask.\nI, bit [7]            - IRQ interrupt mask.\nF, bit [6]            - FIQ interrupt mask.\nT, bit [5]            - T32 Instruction set state.\nM[4:0], bits [0:4]    - Mode."
      },
      "SPSR_fiq": {
        "long_name": "Saved Program Status Register (FIQ mode)",
        "purpose": "Holds the saved process state when an exception is taken to FIQ mode.\n\nN, bit [31]           - Negative Condition flag.\nZ, bit [30]           - Zero Condition flag.\nC, bit [29]           - Carry Condition flag.\nV, bit [28]           - Overflow Condition flag.\nQ, bit [27]           - Overflow or saturation flag.\nIT, bits [25:26]      - If-Then.\nJ, bit [24]           - res0.\nSSBS, bit [23]        - Speculative Store Bypass.\nPAN, bit [22]         - Privileged Access Never.\nDIT, bit [21]         - Data Independent Timing.\nIL, bit [20]          - Illegal Execution state.\nGE, bits [16:19]      - Greater than or Equal flags.\nIT[7:2], bits [10:15] - This field is bits[7:2] of IT[7:0].\nE, bit [9]            - Endianness.\nA, bit [8]            - SError interrupt mask.\nI, bit [7]            - IRQ interrupt mask.\nF, bit [6]            - FIQ interrupt mask.\nT, bit [5]            - T32 Instruction set state.\nM[4:0], bits [0:4]    - Mode."
      },
      "SPSR_hyp": {
        "long_name": "Saved Program Status Register (Hyp mode)",
        "purpose": "Holds the saved process state when an exception is taken to Hyp mode.\n\nN, bit [31]           - Negative Condition flag.\nZ, bit [30]           - Zero Condition flag.\nC, bit [29]           - Carry Condition flag.\nV, bit [28]           - Overflow Condition flag.\nQ, bit [27]           - Overflow or saturation flag.\nIT, bits [25:26]      - If-Then.\nJ, bit [24]           - res0.\nSSBS, bit [23]        - Speculative Store Bypass.\nPAN, bit [22]         - Privileged Access Never.\nDIT, bit [21]         - Data Independent Timing.\nIL, bit [20]          - Illegal Execution state.\nGE, bits [16:19]      - Greater than or Equal flags.\nIT[7:2], bits [10:15] - This field is bits[7:2] of IT[7:0].\nE, bit [9]            - Endianness.\nA, bit [8]            - SError interrupt mask.\nI, bit [7]            - IRQ interrupt mask.\nF, bit [6]            - FIQ interrupt mask.\nT, bit [5]            - T32 Instruction set state.\nM[4:0], bits [0:4]    - Mode."
      },
      "SPSR_irq": {
        "long_name": "Saved Program Status Register (IRQ mode)",
        "purpose": "Holds the saved process state when an exception is taken to IRQ mode.\n\nN, bit [31]           - Negative Condition flag.\nZ, bit [30]           - Zero Condition flag.\nC, bit [29]           - Carry Condition flag.\nV, bit [28]           - Overflow Condition flag.\nQ, bit [27]           - Overflow or saturation flag.\nIT, bits [25:26]      - If-Then.\nJ, bit [24]           - res0.\nSSBS, bit [23]        - Speculative Store Bypass.\nPAN, bit [22]         - Privileged Access Never.\nDIT, bit [21]         - Data Independent Timing.\nIL, bit [20]          - Illegal Execution state.\nGE, bits [16:19]      - Greater than or Equal flags.\nIT[7:2], bits [10:15] - This field is bits[7:2] of IT[7:0].\nE, bit [9]            - Endianness.\nA, bit [8]            - SError interrupt mask.\nI, bit [7]            - IRQ interrupt mask.\nF, bit [6]            - FIQ interrupt mask.\nT, bit [5]            - T32 Instruction set state.\nM[4:0], bits [0:4]    - Mode."
      },
      "SPSR_mon": {
        "long_name": "Saved Program Status Register (Monitor mode)",
        "purpose": "Holds the saved process state when an exception is taken to Monitor mode.\n\nN, bit [31]           - Negative Condition flag.\nZ, bit [30]           - Zero Condition flag.\nC, bit [29]           - Carry Condition flag.\nV, bit [28]           - Overflow Condition flag.\nQ, bit [27]           - Overflow or saturation flag.\nIT, bits [25:26]      - If-Then.\nJ, bit [24]           - res0.\nSSBS, bit [23]        - Speculative Store Bypass.\nPAN, bit [22]         - Privileged Access Never.\nDIT, bit [21]         - Data Independent Timing.\nIL, bit [20]          - Illegal Execution state.\nGE, bits [16:19]      - Greater than or Equal flags.\nIT[7:2], bits [10:15] - This field is bits[7:2] of IT[7:0].\nE, bit [9]            - Endianness.\nA, bit [8]            - SError interrupt mask.\nI, bit [7]            - IRQ interrupt mask.\nF, bit [6]            - FIQ interrupt mask.\nT, bit [5]            - T32 Instruction set state.\nM[4:0], bits [0:4]    - Mode."
      },
      "SPSR_svc": {
        "long_name": "Saved Program Status Register (Supervisor mode)",
        "purpose": "Holds the saved process state when an exception is taken to Supervisor mode.\n\nN, bit [31]           - Negative Condition flag.\nZ, bit [30]           - Zero Condition flag.\nC, bit [29]           - Carry Condition flag.\nV, bit [28]           - Overflow Condition flag.\nQ, bit [27]           - Overflow or saturation flag.\nIT, bits [25:26]      - If-Then.\nJ, bit [24]           - res0.\nSSBS, bit [23]        - Speculative Store Bypass.\nPAN, bit [22]         - Privileged Access Never.\nDIT, bit [21]         - Data Independent Timing.\nIL, bit [20]          - Illegal Execution state.\nGE, bits [16:19]      - Greater than or Equal flags.\nIT[7:2], bits [10:15] - This field is bits[7:2] of IT[7:0].\nE, bit [9]            - Endianness.\nA, bit [8]            - SError interrupt mask.\nI, bit [7]            - IRQ interrupt mask.\nF, bit [6]            - FIQ interrupt mask.\nT, bit [5]            - T32 Instruction set state.\nM[4:0], bits [0:4]    - Mode."
      },
      "SPSR_und": {
        "long_name": "Saved Program Status Register (Undefined mode)",
        "purpose": "Holds the saved process state when an exception is taken to Undefined mode.\n\nN, bit [31]           - Negative Condition flag.\nZ, bit [30]           - Zero Condition flag.\nC, bit [29]           - Carry Condition flag.\nV, bit [28]           - Overflow Condition flag.\nQ, bit [27]           - Overflow or saturation flag.\nIT, bits [25:26]      - If-Then.\nJ, bit [24]           - res0.\nSSBS, bit [23]        - Speculative Store Bypass.\nPAN, bit [22]         - Privileged Access Never.\nDIT, bit [21]         - Data Independent Timing.\nIL, bit [20]          - Illegal Execution state.\nGE, bits [16:19]      - Greater than or Equal flags.\nIT[7:2], bits [10:15] - This field is bits[7:2] of IT[7:0].\nE, bit [9]            - Endianness.\nA, bit [8]            - SError interrupt mask.\nI, bit [7]            - IRQ interrupt mask.\nF, bit [6]            - FIQ interrupt mask.\nT, bit [5]            - T32 Instruction set state.\nM[4:0], bits [0:4]    - Mode."
      },
      "TCMTR": {
        "long_name": "TCM Type Register",
        "purpose": "Provides information about the implementation of the TCM."
      },
      "TLBTR": {
        "long_name": "TLB Type Register",
        "purpose": "Provides information about the TLB implementation. The register must define\nwhether the implementation provides separate instruction and data TLBs, or a\nunified TLB. Normally, the implementation defined information in this register\nincludes the number of lockable entries in the TLB.\n\nnU, bit [0] - Not Unified TLB. Indicates whether the implementation has a\n              unified TLB:\n                  0b0 Unified TLB.\n                  0b1 Separate Instruction and Data TLBs."
      },
      "TPIDRPRW": {
        "long_name": "PL1 Software Thread ID Register",
        "purpose": "Provides a location where software executing at EL1 or higher can store thread\nidentifying information that is not visible to software executing at EL0, for OS\nmanagement purposes.\n\nThe PE makes no use of this register.\n\nbits [0:31] - Thread ID. Thread identifying information stored by software\n              running at this Exception level."
      },
      "TPIDRURO": {
        "long_name": "PL0 Read-Only Software Thread ID Register",
        "purpose": "Provides a location where software executing at EL1 or higher can store thread\nidentifying information that is visible to software executing at EL0, for OS\nmanagement purposes.\n\nThe PE makes no use of this register.\n\nbits [0:31] - Thread ID. Thread identifying information stored by software\n              running at this Exception level."
      },
      "TPIDRURW": {
        "long_name": "PL0 Read/Write Software Thread ID Register",
        "purpose": "Provides a location where software executing at EL0 can store thread identifying\ninformation, for OS management purposes.\n\nThe PE makes no use of this register.\n\nbits [0:31] - Thread ID. Thread identifying information stored by software\n              running at this Exception level."
      },
      "TRFCR": {
        "long_name": "Trace Filter Control Register",
        "purpose": "Provides EL1 controls for Trace.\n\nTS, bits [5:6] - Timestamp Control. Controls which timebase is used for trace\n                 timestamps.\n                     0b01 Virtual timestamp. The traced timestamp is the\n                 physical counter value minus the value of CNTVOFF.\n                     0b10 Guest physical timestamp. The traced timestamp is the\n                 physical counter value minus a physical offset. If any of the\n                 following are true, the physical offset is zero, otherwise the\n                 physical offset is the value of CNTPOFF_EL2:\n                   - EL3 is implemented and is using AArch32.\n                   - EL3 is implemented, using AArch64, and SCR_EL3.ECVEn ==\n                 0b0.\n                   - EL2 is using AArch32.\n                   - EL2 is using AArch64 and CNTHCTL_EL2.ECV == 0b0.\n                     0b11 Physical timestamp. The traced timestamp is the\n                 physical counter value.\nE1TRE, bit [1] - EL1 Trace Enable.\n                     0b0 Tracing is prohibited in PL1 modes.\n                     0b1 Tracing is allowed in PL1 modes.\nE0TRE, bit [0] - EL0 Trace Enable.\n                     0b0 Tracing is prohibited at EL0.\n                     0b1 Tracing is allowed at EL0."
      },
      "TTBCR": {
        "long_name": "Translation Table Base Control Register",
        "purpose": "The control register for stage 1 of the PL1&0 translation regime. Its controls\ninclude:\n\n  - Where the VA range is split between addresses translated using TTBR0 and\naddresses translated using TTBR1.\n  - The translation table format used by this stage of translation.\n\nFrom Armv8.2, when the value of TTBCR.{EAE, T2E} is {1, 1}, TTBCR is used with\nTTBCR2.\n\nEAE, bit [31] - Extended Address Enable.\nPD1, bit [5]  - Translation table walk disable for translations using TTBR1.\n                This bit controls whether a translation table walk is performed\n                on a TLB miss, for an address that is translated using TTBR1.\nPD0, bit [4]  - Translation table walk disable for translations using TTBR0.\n                This bit controls whether a translation table walk is performed\n                on a TLB miss for an address that is translated using TTBR0.\nN, bits [0:2] - Indicate the width of the base address held in TTBR0. In TTBR0,\n                the base address field is bits[31:14-N]. The value of N also\n                determines:\n                  - Whether TTBR0 or TTBR1 is used as the base address for\n                translation table walks.\n                  - The size of the translation table pointed to by TTBR0. N can\n                take any value from 0 to 7, that is, from 0b000 to 0b111. When N\n                has its reset value of 0, the translation table base is\n                compatible with Armv5 and Armv6."
      },
      "TTBCR2": {
        "long_name": "Translation Table Base Control Register 2",
        "purpose": "The second control register for stage 1 of the PL1&0 translation regime.\n\nIf FEAT_AA32HPD is not implemented then this register is not implemented and its\nencoding is undefined. Otherwise:\n\n  - When the value of TTBCR.{EAE, T2E} is not {1, 1} the contents of TTBCR2 are\ntreated as zero for all purposes other than reading or writing the register.\n  - When the value of TTBCR.{EAE, T2E} is {1, 1} TTBCR2 is used with TTBCR.\n\nHWU162, bit [18] - Hardware Use.\nHWU161, bit [17] - Hardware Use.\nHWU160, bit [16] - Hardware Use.\nHWU159, bit [15] - Hardware Use.\nHWU062, bit [14] - Hardware Use.\nHWU061, bit [13] - Hardware Use.\nHWU060, bit [12] - Hardware Use.\nHWU059, bit [11] - Hardware Use.\nHPD1, bit [10]   - Hierarchical Permission Disables.\nHPD0, bit [9]    - Hierarchical Permission Disables."
      },
      "TTBR0": {
        "long_name": "Translation Table Base Register 0",
        "purpose": "Holds the base address of the translation table for the initial lookup for stage\n1 of the translation of an address from the lower VA range in the PL1&0\ntranslation regime, and other information for this translation regime.\n\nTTB0, bits [7:31] - Translation table base address, bits[31:x], where x is\n                    14-(TTBCR.N). Register bits [x-1:7] are res0, with the\n                    additional requirement that if these bits are not all zero,\n                    this is a misaligned translation table base address, with\n                    effects that are constrained unpredictable, and must be one\n                    of the following:\n                      - Register bits [x-1:7] are treated as if all the bits are\n                    zero. The value read back from these bits is either the\n                    value written or zero.\n                      - The result of the calculation of an address for a\n                    translation table walk using this register can be corrupted\n                    in those bits that are nonzero.\nIRGN, bit [6]     - Inner region bits. Bits [0,6] of this register together\n                    indicate the Inner Cacheability attributes for the memory\n                    associated with the translation table walks.\nNOS, bit [5]      - Not Outer Shareable.\nRGN, bits [3:4]   - Region bits.\nIMP, bit [2]      - The effect of this bit is implementation defined. If the\n                    translation table implementation does not include any\n                    implementation defined features this bit is res0.\nS, bit [1]        - Shareable.\nIRGN[1], bit [0]  - This field is bit[1] of IRGN[1:0]. See IRGN[0] for the field\n                    description."
      },
      "TTBR1": {
        "long_name": "Translation Table Base Register 1",
        "purpose": "Holds the base address of the translation table for the initial lookup for stage\n1 of the translation of an address from the higher VA range in the PL1&0\ntranslation regime, and other information for this translation regime.\n\nTTB1, bits [7:31] - Translation table base address, bits[31:14]. Register bits\n                    [13:7] are res0, with the additional requirement that if\n                    these bits are not all zero, this is a misaligned\n                    translation table base address, with effects that are\n                    constrained unpredictable, and must be one of the following:\n                      - Register bits [13:7] are treated as if all the bits are\n                    zero. The value read back from these bits is either the\n                    value written or zero.\n                      - The result of the calculation of an address for a\n                    translation table walk using this register can be corrupted\n                    in those bits that are nonzero.\nIRGN, bit [6]     - Inner region bits. IRGN[1:0] indicate the Inner Cacheability\n                    attributes for the memory associated with the translation\n                    table walks.\nNOS, bit [5]      - Not Outer Shareable.\nRGN, bits [3:4]   - Region bits.\nIMP, bit [2]      - The effect of this bit is implementation defined. If the\n                    translation table implementation does not include any\n                    implementation defined features this bit is res0.\nS, bit [1]        - Shareable.\nIRGN[0], bit [0]  - This field is bit[0] of IRGN[1:0]. See IRGN[1] for the field\n                    description."
      },
      "VBAR": {
        "long_name": "Vector Base Address Register",
        "purpose": "When high exception vectors are not selected, holds the vector base address for\nexceptions that are not taken to Monitor mode or to Hyp mode.\n\nSoftware must program VBAR(NS) with the required initial value as part of the PE\nboot sequence.\n\nbits [5:31] - Vector Base Address. Bits[31:5] of the base address of the\n              exception vectors for exceptions taken to this Exception level.\n              Bits[4:0] of an exception vector are the exception offset."
      },
      "VDFSR": {
        "long_name": "Virtual SError Exception Syndrome Register",
        "purpose": "Provides the syndrome value reported to software on taking a virtual SError\ninterrupt exception to EL1, or on executing an ESB instruction at EL1.\n\nWhen the virtual SError interrupt injected using HCR.VA is taken to EL1 using\nAArch32, then the syndrome value is reported in DFSR.{AET, ExT} and the\nremainder of DFSR is set as defined by VMSAv8-32. For more information, see The\nAArch32 Virtual Memory System Architecture.\n\nIf the virtual SError interrupt injected using HCR.VA is deferred by an ESB\ninstruction, then the syndrome value is written to VDISR.\n\nAET, bits [14:15] - When a virtual SError interrupt is taken to EL1 using\n                    AArch32, DFSR[15:4] is set to VDFSR.AET. When a virtual\n                    SError interrupt is deferred by an ESB instruction,\n                    VDISR[15:4] is set to VDFSR.AET.\nExT, bit [12]     - When a virtual SError interrupt is taken to EL1 using\n                    AArch32, DFSR[12] is set to VDFSR.ExT. When a virtual SError\n                    interrupt is deferred by an ESB instruction, VDISR[12] is\n                    set to VDFSR.ExT."
      },
      "VDISR": {
        "long_name": "Virtual Deferred Interrupt Status Register",
        "purpose": "Records that an SError interrupt has been consumed by an ESB instruction.\n\nA, bit [31]         - Set to 1 when an ESB instruction defers a virtual SError\n                      interrupt.\nAET, bits [14:15]   - The value copied from VDFSR.AET.\nExT, bit [12]       - The value copied from VDFSR.ExT.\nFS, bit [10]        - Fault status code. Set to 0b10110 when an ESB instruction\n                      defers a virtual SError interrupt.\n                          0b10110 Asynchronous SError interrupt.\n                      All other values are reserved. The FS field is split as\n                      follows:\n                        - FS[4] is VDISR[10].\n                        - FS[3:0] is VDISR[3:0].\nLPAE, bit [9]       - Format. Set to TTBCR.EAE when an ESB instruction defers a\n                      virtual SError interrupt.\n                          0b0 Using the Short-descriptor translation table\n                      format.\nFS[3:0], bits [0:3] - This field is bits[3:0] of FS[4:0]. See FS[4] for the\n                      field description."
      },
      "VMPIDR": {
        "long_name": "Virtualization Multiprocessor ID Register",
        "purpose": "Holds the value of the Virtualization Multiprocessor ID. This is the value\nreturned by Non-secure EL1 reads of MPIDR.\n\nM, bit [31]        - Indicates whether this implementation includes the\n                     functionality introduced by the ARMv7 Multiprocessing\n                     Extensions.\nU, bit [30]        - Indicates a Uniprocessor system, as distinct from PE 0 in a\n                     multiprocessor system.\nMT, bit [24]       - Indicates whether the lowest level of affinity consists of\n                     logical PEs that are implemented using a multithreading\n                     type approach. See the description of Aff0 for more\n                     information about affinity levels.\nAff2, bits [16:23] - Affinity level 2. See the description of Aff0 for more\n                     information.\nAff1, bits [8:15]  - Affinity level 1. See the description of Aff0 for more\n                     information.\nAff0, bits [0:7]   - Affinity level 0. This is the affinity level that is most\n                     significant for determining PE behavior. Higher affinity\n                     levels are increasingly less significant in determining PE\n                     behavior. The assigned value of the MPIDR.{Aff2, Aff1,\n                     Aff0} or MPIDR_EL1.{Aff3, Aff2, Aff1, Aff0} set of fields\n                     of each PE must be unique within the system as a whole."
      },
      "VPIDR": {
        "long_name": "Virtualization Processor ID Register",
        "purpose": "Holds the value of the Virtualization Processor ID. This is the value returned\nby Non-secure EL1 reads of MIDR.\n\nImplementer, bits [24:31]  - The Implementer code. This field must hold an\n                             implementer code that has been assigned by Arm.\n                             Assigned codes include the following: Arm can\n                             assign codes that are not published in this manual.\n                             All values not assigned by Arm are reserved and\n                             must not be used.\nVariant, bits [20:23]      - An implementation defined variant number.\n                             Typically, this field is used to distinguish\n                             between different product variants, or major\n                             revisions of a product.\nArchitecture, bits [16:19] - Architecture version.\nPartNum, bits [4:15]       - An implementation defined primary part number for\n                             the device. On processors implemented by Arm, if\n                             the top four bits of the primary part number are\n                             0x0 or 0x7, the variant and architecture are\n                             encoded differently.\nRevision, bits [0:3]       - An implementation defined revision number for the\n                             device."
      },
      "VTCR": {
        "long_name": "Virtualization Translation Control Register",
        "purpose": "The control register for stage 2 of the Non-secure PL1&0 translation regime.\n\nThis stage of translation always uses the Long-descriptor translation table\nformat.\n\nHWU62, bit [28]     - Hardware Use.\nHWU61, bit [27]     - Hardware Use.\nHWU60, bit [26]     - Hardware Use.\nHWU59, bit [25]     - Hardware Use.\nSH0, bits [12:13]   - Shareability attribute for memory associated with\n                      translation table walks using VTTBR.\nORGN0, bits [10:11] - Outer cacheability attribute for memory associated with\n                      translation table walks using VTTBR.\nIRGN0, bits [8:9]   - Inner cacheability attribute for memory associated with\n                      translation table walks using VTTBR.\nSL0, bits [6:7]     - Starting level for translation table walks using VTTBR.\nS, bit [4]          - Sign extension bit.\nT0SZ, bits [0:3]    - The size offset of the memory region addressed by VTTBR."
      },
      "VTTBR": {
        "long_name": "Virtualization Translation Table Base Register",
        "purpose": "Holds the base address of the translation table for the initial lookup for stage\n2 of an address translation in the Non-secure PL1&0 translation regime, and\nother information for this translation regime.\n\nVMID, bits [48:55] - The VMID for the translation table.\nBADDR, bits [1:47] - Translation table base address, bits[47:x], Bits [x-1:1]\n                     are res0, with the additional requirement that if\n                     bits[x-1:3] are not all zero, this is a misaligned\n                     translation table base address, with effects that are\n                     constrained unpredictable, and must be one of the\n                     following:\n                       - Register bits [x-1:3] are treated as if all the bits\n                     are zero. The value read back from these bits is either the\n                     value written or zero.\n                       - The result of the calculation of an address for a\n                     translation table walk using this register can be corrupted\n                     in those bits that are nonzero. x is determined from the\n                     value of VTCR.SL0 and VTCR.T0SZ as follows:\n                       - If VTCR.SL0 is 0b00, meaning that lookup starts at\n                     level 2, then x is 14 - VTCR.T0SZ.\n                       - If VTCR.SL0 is 0b01, meaning that lookup starts at\n                     level 1, then x is 5 - VTCR.T0SZ.\n                       - If VTCR.SL0 is either 0b10 or 0b11 then a stage 2 level\n                     1 Translation fault is generated. If bits[47:40] of the\n                     translation table base address are not zero, an Address\n                     size fault is generated.\nCnP, bit [0]       - Common not Private. This bit indicates whether each entry\n                     that is pointed to by VTTBR is a member of a common set\n                     that can be used by every PE in the Inner Shareable domain\n                     for which the value of VTTBR.CnP is 1."
      }
    }
  }
}